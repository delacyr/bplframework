<html>
<head>
<title>The Java Language Specification
 Execution</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="11.doc.html">Prev</a> | <a href="13.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="44410"></a>
<p><strong>
CHAPTER
 12 </strong></p>
<a name="44411"></a>
<h1>Execution</h1>
<hr><p>
<a name="44413"></a>
This chapter specifies activities that occur during execution of a Java program. 
It is organized around the life cycle of a Java Virtual Machine and of the classes, 
interfaces, and objects that form a Java program.
<p><a name="46419"></a>
A Java Virtual Machine starts up by loading a specified class and then invoking the method <code>main</code> in this specified class. Section <a href="12.doc.html#44444">&#167;12.1</a> outlines the loading, linking, and initialization steps involved in executing <code>main</code>, as an introduction to the concepts in this chapter. Further sections specify the details of loading <a href="12.doc.html#44459">(&#167;12.2)</a>, linking <a href="12.doc.html#44487">(&#167;12.3)</a>, and initialization <a href="12.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="46572"></a>
The chapter continues with a specification of the procedures for creation of new class instances <a href="12.doc.html#44670">(&#167;12.5)</a>; finalization of class instances <a href="12.doc.html#44748">(&#167;12.6)</a>; and finalization of classes <a href="12.doc.html#48744">(&#167;12.7)</a>. It concludes by describing the unloading of classes <a href="12.doc.html#44850">(&#167;12.8)</a> and the procedure followed when a virtual machine exits <a href="12.doc.html#44857">(&#167;12.9)</a>.<p>
<a name="44444"></a>
<h2>12.1    Virtual Machine Start-Up</h2>
<a name="44445"></a>
A Java Virtual Machine starts execution by invoking the method <code>main</code> of some 
specified class, passing it a single argument, which is an array of strings. In the 
examples in this specification, this first class is typically called <code>Test</code>.
<p><a name="46661"></a>
The manner in which the initial class is specified to the Java Virtual Machine is beyond the scope of this specification, but it is typical, in host environments that use command lines, for the fully-qualified name of the class to be specified as a command-line argument and for following command-line arguments to be used as strings to be provided as the argument to the method <code>main</code>. For example, in a UNIX implementation, the command line:<p>
<pre><a name="46662"></a>java Test reboot Bob Dot Enzo
</pre><a name="46663"></a>
will typically start a Java Virtual Machine by invoking method <code>main</code> of class <code>Test</code> 
(a class in an unnamed package), passing it an array containing the four strings 
<code>"reboot"</code>, <code>"Bob"</code>, <code>"Dot"</code>, and <code>"Enzo"</code>.
<p><a name="46666"></a>
We now outline the steps the virtual machine may take to execute <code>Test</code>, as an example of the loading, linking, and initialization processes that are described further in later sections.<p>
<a name="46619"></a>
<h3>12.1.1    Load the Class <code>Test</code></h3>
<a name="46533"></a>
The initial attempt to execute the method <code>main</code> of class <code>Test</code> discovers that the 
class <code>Test</code> is not loaded-that is, that the virtual machine does not currently contain
a binary representation for this class. The virtual machine then uses a class 
loader <a href="javalang.doc13.html#14462">(&#167;20.14)</a> to attempt to find such a binary representation. If this process 
fails, then an error is thrown. This loading process is described further in <a href="12.doc.html#44459">&#167;12.2</a>.
<p><a name="46620"></a>
<h3>12.1.2    Link <code>Test</code>: Verify, Prepare, (Optionally) Resolve</h3>
<a name="47121"></a>
After <code>Test</code> is loaded, it must be initialized before <code>main</code> can be invoked. And <code>Test</code>, 
like all (class or interface) types, must be linked before it is initialized. Linking 
involves verification, preparation and (optionally) resolution. Linking is described 
further in <a href="12.doc.html#44487">&#167;12.3</a>.
<p><a name="47125"></a>
Verification checks that the loaded representation of <code>Test</code> is well-formed, with a proper symbol table. Verification also checks that the code that implements <code>Test</code> obeys the semantic requirements of Java and the Java Virtual Machine. If a problem is detected during verification, then an error is thrown. Verification is described further in <a href="12.doc.html#44491">&#167;12.3.1</a>.<p>
<a name="48984"></a>
Preparation involves allocation of static storage and any data structures that are used internally by the virtual machine, such as method tables. If a problem is detected during preparation, then an error is thrown. Preparation is described further in <a href="12.doc.html#47979">&#167;12.3.2</a>.<p>
<a name="46935"></a>
Resolution is the process of checking symbolic references from <code>Test</code> to other classes and interfaces, by loading the other classes and interfaces that are mentioned and checking that the references are correct.<p>
<a name="48724"></a>
The resolution step is optional at the time of initial linkage. An implementation may resolve symbolic references from a class or interface that is being linked very early, even to the point of resolving all symbolic references from the classes and interfaces that are further referenced, recursively. (This resolution may result in errors from these further loading and linking steps.) This implementation choice represents one extreme and is similar to the kind of "static" linkage that has been done for many years in simple implementations of the C language. (In these implementations, a compiled program is typically represented as an "<code>a.out</code>" file that contains &#32;a fully-linked version of the program, including completely resolved links to library routines used by the program. Copies of these library routines are included in the "<code>a.out</code>" file.)<p>
<a name="46603"></a>
An implementation may instead choose to resolve a symbolic reference only when it is actively used; consistent use of this strategy for all symbolic references would represent the "laziest" form of resolution. In this case, if <code>Test</code> had several symbolic references to another class, then the references might be resolved one at a time, as they are used, or perhaps not at all, if these references were never used during execution of the program.<p>
<a name="46604"></a>
The only requirement on when resolution is performed is that any errors detected during resolution must be thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error. Using the "static" example implementation choice described above, loading and linkage errors could occur before the program is executed if they involved a class or interface mentioned in the class <code>Test</code> or any of the further, recursively referenced, classes and interfaces. In a system &#32;that implemented the "laziest" resolution, these errors would be thrown only when an incorrect symbolic reference is actively used.<p>
<a name="46607"></a>
The resolution process is described further in <a href="12.doc.html#44524">&#167;12.3.3</a>.<p>
<a name="46634"></a>
<h3>12.1.3    Initialize <code>Test</code>: Execute Initializers</h3>
<a name="46618"></a>
In our continuing example, the virtual machine is still trying to execute the 
method <code>main</code> of class <code>Test</code>. This is an attempted active use <a href="12.doc.html#44560">(&#167;12.4.1)</a> of the class, 
which is permitted only if the class has been initialized.
<p><a name="46639"></a>
Initialization consists of execution of any class variable initializers and static initializers of the class <code>Test</code>, in textual order. But before <code>Test</code> can be initialized, its direct superclass must be initialized, as well as the direct superclass of its direct superclass, and so on, recursively. In the simplest case, <code>Test</code> has <code>Object</code> as its implicit direct superclass; if class <code>Object</code> has not yet been initialized, then it must be initialized before <code>Test</code> is initialized. Class <code>Object</code> has no superclass, so the recursion terminates here.<p>
<a name="47019"></a>
If class <code>Test</code> has another class <code>Super</code> as its superclass, then <code>Super</code> must be initialized before <code>Test</code>. This requires loading, verifying, and preparing <code>Super</code> if this has not already been done and, depending on the implementation, may also involve resolving the symbolic references from <code>Super</code> and so on, recursively.<p>
<a name="47072"></a>
Initialization may thus cause loading, linking, and initialization errors, including such errors involving other types.<p>
<a name="47023"></a>
The initialization process is described further in <a href="12.doc.html#44557">&#167;12.4</a>.<p>
<a name="47024"></a>
<h3>12.1.4    Invoke <code>Test.main</code></h3>
<a name="46653"></a>
Finally, after completion of the initialization for class <code>Test</code> (during which other 
consequential loading, linking, and initializing may have occurred), the method 
<code>main</code> of <code>Test</code> is invoked.
<p><a name="46532"></a>
The method <code>main</code> must be declared <code>public</code>, <code>static</code>, and <code>void</code>. It must accept a single argument that is an array of strings.<p>
<a name="44459"></a>
<h2>12.2    Loading of Classes and Interfaces</h2>
<a name="44460"></a>
<i>Loading</i> refers to the process of finding the binary form of a class or interface type 
with a particular name, perhaps by computing it on the fly, but more typically by 
retrieving a binary representation previously computed from source code by a 
compiler, and constructing, from that binary form, a <code>Class</code> object to represent the 
class or interface.
<p><a name="48259"></a>
The binary format of a class or interface is normally the <code>class</code> file format described in <i>The Java Virtual Machine</i>, but other formats are possible, provided they meet the requirements specified in <a href="13.doc.html#44909">&#167;13.1</a>. The method <code>defineClass</code> <a href="javalang.doc13.html#52452">(&#167;20.14.3)</a> of class <code>ClassLoader</code> may be used to construct <code>Class</code> objects from binary representations in the <code>class</code> file format.<p>
<a name="48266"></a>
A Java Virtual Machine system should maintain an internal table of classes and interfaces that have been loaded for the sake of resolving symbolic references. Each entry in the table should consist of a fully qualified class name (as a string), a class loader, and a <code>Class</code> object. Whenever a symbolic reference to a class or interface is to be resolved, a class loader is identified that is responsible for loading the class or interface, if necessary. The table should be consulted first, however; if it already contains an entry for that class name and class loader, then the class object in that entry should be used and no method of the class loader should be invoked. If the table contains no such entry, then the method <code>loadClass</code> <a href="javalang.doc13.html#14061">(&#167;20.14.2)</a> of the class loader should be invoked, giving it the name of the class or interface. If and when it returns, the class object that it returns should be used to make a new entry in the table for that class name and class loader.<p>
<a name="47927"></a>
The purpose of this internal table is to allow the verification process <a href="12.doc.html#44491">(&#167;12.3.1)</a> to assume, for its purposes, that two classes or interfaces are the same if they have the same name and the same class loader. This property allows a class to be verified without loading all the classes and interfaces that it uses, whether actively or passively. Well-behaved class loaders do maintain this property: given the same name twice, a good class loader should return the same class object each time. But without the internal table, a malicious class loader could violate this property and undermine the security of the Java type system. A basic principle of the design of the Java language is that the type system cannot be subverted by code written in Java, not even by implementations of such otherwise sensitive system classes as <code>ClassLoader</code> <a href="javalang.doc13.html#14462">(&#167;20.14)</a> and <code>SecurityManager</code> <a href="javalang.doc16.html#46274">(&#167;20.17)</a>.<p>
<a name="47984"></a>
An entry may be deleted from the internal table only after unloading <a href="12.doc.html#44850">(&#167;12.8)</a> the class or interface represented by the class object in the entry.<p>
<a name="47907"></a>
<h3>12.2.1    The Loading Process</h3>
<a name="44471"></a>
The loading process is implemented by the class <code>ClassLoader</code> <a href="javalang.doc13.html#14462">(&#167;20.14)</a> and its 
subclasses. Different subclasses of <code>ClassLoader</code> may implement different loading
policies. In particular, a class loader may cache binary representations of 
classes and interfaces, prefetch them based on expected usage, or load a group of 
related classes together. These activities may not be completely transparent to a 
running Java application if, for example, a newly compiled version of a class is 
not found because an older version is cached by a class loader. It is the responsibility
of a class loader, however, to reflect loading errors only at points in the program
they could have arisen without prefetching or group loading.
<p><a name="44476"></a>
If an error occurs during class loading, then an instance of one of the following subclasses of class <code>LinkageError</code> will be thrown at any point in the Java program that (directly or indirectly) uses the type:<p>
<ul><a name="44477"></a>
<li><code>ClassCircularityError</code>: A class or interface could not be loaded because it would be its own superclass or superinterface <a href="13.doc.html#44994">(&#167;13.4.4)</a>.
<a name="44481"></a>
<li><code>ClassFormatError</code>: The binary data that purports to specify a requested compiled class or interface is malformed.
<a name="44482"></a>
<li><code>NoClassDefFoundError</code>: No definition for a requested class or interface could be found by the relevant class loader.
</ul><a name="46207"></a>
Because loading involves the allocation of new data structures, it may fail with an <code>OutOfMemoryError</code>.<p>
<a name="44484"></a>
<h3>12.2.2    Loading: Implications for Code Generation</h3>
<a name="44485"></a>
A cooperating class loader can enable a code generator to generate code for a 
group of class and interface types-perhaps an entire package-by loading the 
binary code for these types as a group. A format can be designed that allows all 
the internal symbolic references in such a group to be resolved, before the group is 
loaded. Such a strategy may also allow the generated code to be optimized before 
loading based on the known concrete types in the group. This approach may be 
useful in specific cases, but is discouraged as a general technique, since such a 
class file format is unlikely to be widely understood.
<p><a name="44487"></a>
<h2>12.3    Linking of Classes and Interfaces</h2>
<a name="44488"></a>
<i>Linking</i> is the process of taking a binary form of a class or interface type and combining
it into the runtime state of the Java Virtual Machine, so that it can be executed.
A class or interface type is always loaded before it is linked. Three different 
activities are involved in linking: verification, preparation, and resolution of symbolic
references.
<p><a name="46466"></a>
Java allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that the semantics of the language are respected, that a class or interface is completely verified and prepared before it is initialized, and that errors detected during linkage are thrown at a point in the program where some action is taken by the program that might require linkage to the class or interface involved in the error.<p>
<a name="46467"></a>
For example, an implementation may choose to resolve each symbolic reference in a class or interface individually, only when it is used (lazy or late resolution), or to resolve them all at once while the class is being verified (static resolution). This means that the resolution process may continue, in some implementations, after a class or interface has been initialized.<p>
<a name="46201"></a>
Because linking involves the allocation of new data structures, it may fail with an <code>OutOfMemoryError</code>.<p>
<a name="44491"></a>
<h3>12.3.1    Verification of the Binary Representation</h3>
<a name="44492"></a>
<i>Verification</i> ensures that the binary representation of a class or interface is structurally
correct. For example, it checks that every instruction has a valid operation 
code; that every branch instruction branches to the start of some other instruction, 
rather than into the middle of an instruction; that every method is provided with a 
structurally correct signature; and that every instruction obeys the type discipline 
of the Java language.
<p><a name="44493"></a>
For a more detailed description of the verification process, see the separate volume of this series, <i>The Java Virtual Machine Specification</i>.<p>
<a name="44494"></a>
If an error occurs during verification, then an instance of the following subclass of class <code>LinkageError</code> will be thrown at the point in the Java program that caused the class to be verified:<p>
<ul><a name="47964"></a>
<li><code>VerifyError</code>: The binary definition for a class or interface failed to pass a set of required checks to verify that it obeys the semantics of the Java language and that it cannot violate the integrity of the Java Virtual Machine. (See <a href="13.doc.html#44987">&#167;13.4.2</a>, <a href="13.doc.html#44994">&#167;13.4.4</a>, <a href="13.doc.html#45139">&#167;13.4.8</a>, and <a href="13.doc.html#45238">&#167;13.4.16</a> for some examples.)
</ul><a name="47979"></a>
<h3>12.3.2    Preparation of a Class or Interface Type</h3>
<a name="44510"></a>
<i>Preparation</i> involves creating the <code>static</code> fields (class variables and constants) for 
a class or interface and initializing such fields to the standard default values 
<a href="4.doc.html#10931">(&#167;4.5.4)</a>. This does not require the execution of any Java code; explicit initializers 
for <code>static</code> fields are executed as part of initialization <a href="12.doc.html#44557">(&#167;12.4)</a>, not preparation.
<p><a name="46216"></a>
Java implementations must detect the following error during preparation:<p>
<ul><a name="46217"></a>
<li><code>AbstractMethodError</code>: A class that is not declared to be <code>abstract</code> has an <code>abstract</code> method. This can occur, for example, if a method that is originally not <code>abstract</code> is changed to be <code>abstract</code> after another class that inherits the now <code>abstract</code> method declaration has been compiled <a href="13.doc.html#45214">(&#167;13.4.15)</a>.
</ul><a name="46228"></a>
If such an error is detected, then an instance of <code>AbstractMethodError</code> should be 
thrown at the point in the Java program that caused the class to be prepared.
<p><a name="46239"></a>
Implementations of the Java Virtual Machine may precompute additional data structures at preparation time in order to make later operations on a class or interface more efficient. One particularly useful data structure is a "method table" or other data structure that allows any method to be invoked on instances of a class without requiring a search of superclasses at invocation time.<p>
<a name="44524"></a>
<h3>12.3.3    Resolution of Symbolic References</h3>
<a name="44525"></a>
A Java binary file references other classes and interfaces and their fields, methods, 
and constructors symbolically, using the fully-qualified names of the other classes 
and interfaces <a href="13.doc.html#44909">(&#167;13.1)</a>. For fields and methods, these symbolic references include 
the name of the class or interface type that declares the field or method as well as 
the name of the field or method itself, together with appropriate type information.
<p><a name="44529"></a>
Before a symbolic reference can be used it must be undergo <i>resolution</i>, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly.<p>
<a name="44530"></a>
If an error occurs during resolution, then an error will be thrown. Most typically, this will be an instance of one of the following subclasses of the class <code>IncompatibleClassChangeError</code>, but it may also be an instance of some other subclass of <code>IncompatibleClassChangeError</code> or even an instance of the class <code>IncompatibleClassChangeError</code> itself. This error may be thrown at any point in the program that uses a symbolic reference to the type, directly or indirectly:<p>
<ul><a name="44531"></a>
<li><code>IllegalAccessError</code>: A symbolic reference has been encountered that specifies a use or assignment of a field, or invocation of a method, or creation of an instance of a class, to which the code containing the reference does not have access because the field or method was declared <code>private</code>, <code>protected</code>, or default access (not <code>public</code>), or because the class was not declared <code>public</code>. This can occur, for example, if a field that is originally declared <code>public</code> is changed to be <code>private</code> after another class that refers to the field has been compiled <a href="13.doc.html#47259">(&#167;13.4.6)</a>.
<a name="44535"></a>
<li><code>InstantiationError</code>: A symbolic reference has been encountered that is used in a class instance creation expression, but an instance cannot be created because the reference turns out to refer to an interface or to an <code>abstract</code> class. This can occur, for example, if a class that is originally not <code>abstract</code> is changed to be <code>abstract</code> after another class that refers to the class in question has been compiled <a href="13.doc.html#44980">(&#167;13.4.1)</a>.
<a name="44539"></a>
<li><code>NoSuchFieldError</code>: A symbolic reference has been encountered that refers to a specific field of a specific class or interface, but the class or interface does not declare a field of that name (it is specifically not sufficient for it simply to be an inherited field of that class or interface). This can occur, for example, if a field declaration was deleted from a class after another class that refers to the field was compiled <a href="13.doc.html#45118">(&#167;13.4.7)</a>.
<a name="44543"></a>
<li><code>NoSuchMethodError</code>: A symbolic reference has been encountered that refers to a specific method of a specific class or interface, but the class or interface does not declare a method of that signature (it is specifically not sufficient for it simply to be an inherited method of that class or interface). This can occur, for example, if a method declaration was deleted from a class after another class that refers to the method was compiled <a href="13.doc.html#45197">(&#167;13.4.12)</a>.
</ul><a name="49761"></a>
Additionally, an <code>UnsatisfiedLinkError</code> (a subclass of <code>LinkageError</code>) may be thrown if a class declares a <code>native</code> method for which no implementation can be found. The error will occur if the method is used, or earlier depending on what kind of resolution strategy is being used by the virtual machine <a href="12.doc.html#44487">(&#167;12.3)</a>.<p>
<a name="44547"></a>
<h3>12.3.4    Linking: Implications for Code Generation</h3>
<a name="44548"></a>
The symbolic references within a group of types may be resolved even before the 
group is loaded <a href="12.doc.html#44484">(&#167;12.2.2)</a>, in an implementation that uses a special (non-standard) 
binary format <a href="13.doc.html#44909">(&#167;13.1)</a>. This corresponds to the traditional practice of "linkage 
editing." Even if this is not done, a Java implementation has a lot of flexibility. It 
may resolve all symbolic references from a type at the point of the first linkage 
activity on the type, or defer the resolution of each symbolic reference to the first 
use of that reference.
<p><a name="44555"></a>
We note that the flexibility accorded the Java implementation in the linkage process does not affect correctly formed Java programs, which should never encounter linkage errors.<p>
<a name="44557"></a>
<h2>12.4    Initialization of Classes and Interfaces</h2>
<a name="44558"></a>
Initialization of a class consists of executing its static initializers and the initializers
for <code>static</code> fields (class variables) declared in the class. Initialization of an 
interface consists of executing the initializers for fields (constants) declared there.
<p><a name="47219"></a>
Before a class is initialized, its superclass must be initialized, but interfaces implemented by the class need not be initialized. Similarly, the superinterfaces of an interface need not be initialized before the interface is initialized.<p>
<a name="44560"></a>
<h3>12.4.1    When Initialization Occurs</h3>
<a name="44561"></a>
A class or interface type <i>T</i> will be <i>initialized</i> at its first <i>active use</i>, which occurs if:
<p><ul><a name="44562"></a>
<li><i>T</i> is a class and a method actually declared in <i>T</i> (rather than inherited from a superclass) is invoked.
<a name="44563"></a>
<li><i>T</i> is a class and a constructor for class <i>T</i> is invoked, or <i>U</i> is an array with element type <i>T</i>, and an array of type <i>U</i> is created.
<a name="44564"></a>
<li>A non-constant field declared in <i>T</i> (rather than inherited from a superclass or superinterface) is used or assigned. A <i>constant field</i> is one that is (explicitly or implicitly) both <code>final</code> and <code>static</code>, and that is initialized with the value of a compile-time constant expression <a href="15.doc.html#5313">(&#167;15.27)</a>. Java specifies that a reference to a constant field must be resolved at compile time to a copy of the compile-time constant value, so uses of such a field are never active uses. See <a href="13.doc.html#45139">&#167;13.4.8</a> for a further discussion.
</ul><a name="44568"></a>
All other uses of a type are <i>passive uses</i>.
<p><a name="46862"></a>
The intent here is that a class or interface type has a set of initializers that put it in a consistent state, and that this state is the first state that is observed by other classes. The static initializers and class variable initializers are executed in textual order, and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope <a href="8.doc.html#39245">(&#167;8.5)</a>. This restriction is designed to detect, at compile time, most circular or otherwise malformed initializations. &#32;<p>
<a name="46874"></a>
As shown in an example in <a href="8.doc.html#39245">&#167;8.5</a>, the fact that initialization code is unrestricted allows examples to be constructed where the value of a class variable can be observed when it still has its initial default value, before its initializing expression is evaluated, but such examples are rare in practice. (Such examples can be also constructed for instance variable initialization; see the example at the end of <a href="12.doc.html#44670">&#167;12.5</a>). Java provides the full power of the language in these initializers; programmers must exercise some care. This power places an extra burden on code generators, but this burden would arise in any case because Java is concurrent <a href="12.doc.html#44667">(&#167;12.4.3)</a>.<p>
<a name="44569"></a>
Before a class is initialized, its superclasses are initialized, if they have not previously been initialized.<p>
<a name="44570"></a>
Thus, the test program:<p>
<pre><a name="44571"></a>
class Super {
<a name="44572"></a>	static { System.out.print("Super "); }
<a name="44573"></a>}
<a name="44574"></a>
class One {
<a name="44575"></a>	static { System.out.print("One "); }
<a name="44576"></a>}
<a name="44577"></a>
class Two extends Super {
<a name="44578"></a>	static { System.out.print("Two "); }
<a name="44579"></a>}
<a name="44580"></a>
class Test {
<a name="44581"></a>	public static void main(String[] args) {
<a name="44582"></a>		One o = null;
<a name="44583"></a>		Two t = new Two();
<a name="44584"></a>		System.out.println((Object)o == (Object)t);
<a name="44585"></a>	}
<a name="44586"></a>}
</pre><a name="44587"></a>
prints:
<p><pre><a name="44588"></a>Super Two false
</pre><a name="44589"></a>
The class <code>One</code> is never initialized, because it not used actively and therefore is 
never linked to. The class <code>Two</code> is initialized only after its superclass <code>Super</code> has 
been initialized.
<p><a name="44590"></a>
A reference to a field is an active use of only the class or interface that actually declares it, even though it might be referred to through the name of a subclass, a subinterface, or a class that implements an interface. The test program:<p>
<pre><a name="44591"></a>
class Super { static int taxi = 1729; }
<a name="44592"></a>
class Sub extends Super {
<a name="44593"></a>	static { System.out.print("Sub "); }
<a name="44594"></a>}
<a name="44595"></a>
class Test {
<a name="44596"></a>	public static void main(String[] args) {
<a name="44597"></a>		System.out.println(Sub.taxi);
<a name="44598"></a>	}
<a name="44599"></a>}
</pre><a name="44600"></a>
prints only:
<p><pre><a name="44601"></a>1729
</pre><a name="44602"></a>
because the class <code>Sub</code> is never initialized; the reference to <code>Sub.taxi</code> is a reference 
to a field actually declared in class <code>Super</code> and is not an active use of the class <code>Sub</code>.
<p><a name="44603"></a>
Initialization of an interface does not, of itself, require initialization of any of its superinterfaces. Thus, the test program:<p>
<pre><a name="44604"></a>
interface I {
<a name="44605"></a>	int i = 1, ii = Test.out("ii", 2);
<a name="44606"></a>}
<a name="44607"></a>
interface J extends I {
<a name="44608"></a>	int j = Test.out("j", 3), jj = Test.out("jj", 4);
<a name="44609"></a>}
<a name="44610"></a>
interface K extends J {
<a name="44611"></a>	int k = Test.out("k", 5);
<a name="44612"></a>}
<a name="44613"></a>
class Test {
<a name="44614"></a>
	public static void main(String[] args) {
<a name="44615"></a>		System.out.println(J.i);
<a name="44616"></a>		System.out.println(K.j);
<a name="44617"></a>	}
<a name="44618"></a>
	static int out(String s, int i) {
<a name="44619"></a>		System.out.println(s + "=" + i);
<a name="44620"></a>		return i;
<a name="44621"></a>	}
<a name="44622"></a>}
</pre><a name="44623"></a>
produces the output:
<p><pre><a name="44624"></a>
1
<a name="44625"></a>j=3
<a name="44626"></a>jj=4
<a name="44627"></a>3
</pre><a name="44628"></a>
The reference to <code>J.i</code> is to a field that is a compile-time constant; therefore, it does 
not cause <code>I</code> to be initialized. The reference to <code>K.j</code> is a reference to a field actually 
declared in interface <code>J</code> that is not a compile-time constant; this causes initialization
of the fields of interface <code>J</code>, but not those of its superinterface <code>I</code>, nor those of 
interface <code>K</code>. Despite the fact that the name <code>K</code> is used to refer to field <code>j</code> of interface 
<code>J</code>, interface <code>K</code> is not actively used.
<p><a name="44630"></a>
<h3>12.4.2    Detailed Initialization Procedure</h3>
<a name="44631"></a>
Because Java is multithreaded, initialization of a class or interface requires careful 
synchronization, since some other thread may be trying to initialize the same class 
or interface at the same time. There is also the possibility that initialization of a 
class or interface may be requested recursively as part of the initialization of that 
class or interface; for example, a variable initializer in class <i>A</i> might invoke a 
method of an unrelated class <i>B</i>, which might in turn invoke a method of class <i>A</i>. 
The implementation of the Java Virtual Machine is responsible for taking care of 
synchronization and recursive initialization by using the following procedure. It 
assumes that the <code>Class</code> object has already been verified and prepared, and that the 
<code>Class</code> object contains state that indicates one of four situations:
<p><ul><a name="44632"></a>
<li>This <code>Class</code> object is verified and prepared but not initialized.
<a name="44633"></a>
<li>This <code>Class</code> object is being initialized by some particular thread <i>T</i>.
<a name="44634"></a>
<li>This <code>Class</code> object is fully initialized and ready for use.
<a name="44635"></a>
<li>This <code>Class</code> object is in an erroneous state, perhaps because the verification or preparation step failed, or because initialization was attempted and failed.
</ul><a name="44636"></a>
The procedure for initializing a class or interface is then as follows:
<p><ol>
<a name="44640"></a>
<li>Synchronize <a href="14.doc.html#79287">(&#167;14.17)</a> on the <code>Class</code> object that represents the class or interface to be initialized. This involves waiting until the current thread can obtain the lock for that object <a href="17.doc.html#28460">(&#167;17.13)</a>.
<a name="44644"></a>
<li>If initialization is in progress for the class or interface by some other thread, then <code>wait</code> <a href="javalang.doc1.html#33394">(&#167;20.1.6)</a> on this <code>Class</code> object (which temporarily releases the lock). When the current thread awakens from the <code>wait</code>, repeat this step.
<a name="44648"></a>
<li>If initialization is in progress for the class or interface by the current thread, then this must be a recursive request for initialization. Release the lock on the <code>Class</code> object and complete normally.
<a name="44649"></a>
<li>If the class or interface has already been initialized, then no further action is required. Release the lock on the <code>Class</code> object and complete normally.
<a name="44650"></a>
<li>If the <code>Class</code> object is in an erroneous state, then initialization is not possible. Release the lock on the <code>Class</code> object and throw a <code>NoClassDefFoundError</code>.
<a name="44651"></a>
<li>Otherwise, record the fact that initialization of the <code>Class</code> object is now in progress by the current thread and release the lock on the <code>Class</code> object.
<a name="44652"></a>
<li>Next, if the <code>Class</code> object represents a class rather than an interface, and the superclass of this class has not yet been initialized, then recursively perform this entire procedure for the superclass. If necessary, verify and prepare the superclass first. If the initialization of the superclass completes abruptly because of a thrown exception, then lock this <code>Class</code> object, label it erroneous, notify all waiting threads <a href="javalang.doc1.html#13790">(&#167;20.1.10)</a>, release the lock, and complete abruptly, throwing the same exception that resulted from initializing the superclass.
<a name="44656"></a>
<li>Next, execute either the class variable initializers and static initializers of the class, or the field initializers of the interface, in textual order, as though they were a single block, except that <code>final</code> class variables and fields of interfaces whose values are compile-time constants are initialized first (<a href="8.doc.html#38010">&#167;8.3.2.1</a>, <a href="9.doc.html#40720">&#167;9.3.1</a>, <a href="13.doc.html#45139">&#167;13.4.8</a>).
<a name="44657"></a>
<li>If the execution of the initializers completes normally, then lock this <code>Class</code> object, &#32;label it fully initialized, notify all waiting threads <a href="javalang.doc1.html#13790">(&#167;20.1.10)</a>, release the lock, and complete this procedure normally.
<a name="44661"></a>
<li>Otherwise, the initializers must have completed abruptly by throwing some exception &#32;<i>E</i>. If the class of <i>E</i> is not <code>Error</code> or one of its subclasses, then create a new instance of the class <code>ExceptionInInitializerError</code>, with <i>E</i> as the argument, and use this object in place of <i>E</i> in the following step. But if a new instance of <code>ExceptionInInitializerError</code> cannot be created because an <code>OutOfMemoryError</code> occurs, then instead use an <code>OutOfMemoryError</code> object in place of <i>E</i> in the following step.
<a name="44665"></a>
<li>Lock the <code>Class</code> object, label it erroneous, notify all waiting threads <a href="javalang.doc1.html#13790">(&#167;20.1.10)</a>, release the lock, and complete this procedure abruptly with reason <i>E</i> or its replacement as determined in the previous step.
</ol>
<a name="44666"></a>
(Due to a flaw in some early implementations of Java, a exception during class initialization
was ignored, rather than causing an <code>ExceptionInInitializerError</code> 
as described here.) 
<p><a name="44667"></a>
<h3>12.4.3    Initialization: Implications for Code Generation</h3>
<a name="44668"></a>
Code generators need to preserve the points of possible initialization of a class or 
interface, inserting an invocation of the initialization procedure just described. If 
this initialization procedure completes normally and the <code>Class</code> object is fully initialized
and ready for use, then the invocation of the initialization procedure is no 
longer necessary and it may be eliminated from the code-for example, by patching
it out or otherwise regenerating the code.
<p><a name="46847"></a>
Compile-time analysis may, in some cases, be able to eliminate many of the checks that a type has been initialized from the generated code, if an initialization order for a group of related types can be determined. Such analysis must, however, fully account for the fact that Java is concurrent and that initialization code is unrestricted.<p>
<a name="44670"></a>
<h2>12.5    Creation of New Class Instances</h2>
<a name="44671"></a>
A new class instance is explicitly created when one of the following situations 
occurs:
<p><ul><a name="44675"></a>
<li>Evaluation of a class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a> creates a new instance of the class whose name appears in the expression.
<a name="44679"></a>
<li>Invocation of the <code>newInstance</code> method <a href="javalang.doc2.html#15088">(&#167;20.3.6)</a> of class <code>Class</code> creates a new instance of the class represented by the <code>Class</code> object for which the method was invoked.
</ul><a name="44680"></a>
A new class instance may be implicitly created in the following situations:
<p><ul><a name="44684"></a>
<li>Loading of a class or interface that contains a <code>String</code> literal <a href="3.doc.html#101083">(&#167;3.10.5)</a> may create a new <code>String</code> object <a href="javalang.doc11.html#14460">(&#167;20.12)</a> to represent that literal. (This might not occur if the same <code>String</code> has previously been interned <a href="3.doc.html#101083">(&#167;3.10.5)</a>.)
<a name="44691"></a>
<li>Execution of a string concatenation operator <a href="15.doc.html#39990">(&#167;15.17.1)</a> that is not part of a constant expression sometimes creates a new <code>String</code> object to represent the result. String concatenation operators may also create temporary wrapper objects for a value of a primitive type.
</ul><a name="44692"></a>
Each of these situations identifies a particular constructor to be called with specified
arguments (possibly none) as part of the class instance creation process.
<p><a name="44693"></a>
Whenever a new class instance is created, memory space is allocated for it with room for all the instance variables declared in the class type and all the instance variables declared in each superclass of the class type, including all the instance variables that may be hidden. If there is not sufficient space available to allocate memory for the object, then creation of the class instance completes abruptly with an <code>OutOfMemoryError</code>. Otherwise, all the instance variables in the new object, including those declared in superclasses, are initialized to their default values <a href="4.doc.html#10931">(&#167;4.5.4)</a>. Just before a reference to the newly created object is returned as the result, the indicated constructor is processed to initialize the new object using the following procedure:<p>
<ol>
<a name="44697"></a>
<li>Assign the arguments for the constructor to newly created parameter variables for this constructor invocation.
<a name="44698"></a>
<li>If this constructor begins with an explicit constructor invocation of another constructor in the same class (using <code>this</code>), then evaluate the arguments and process that constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason; otherwise, continue with step 5.
<a name="44699"></a>
<li>This constructor does not begin with an explicit constructor invocation of another constructor in the same class (using <code>this</code>). If this constructor is for a class other than <code>Object</code>, then this constructor will begin with a explicit or implicit invocation of a superclass constructor (using <code>super</code>). Evaluate the arguments and process that superclass constructor invocation recursively using these same five steps. If that constructor invocation completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, continue with step 4.
<a name="44700"></a>
<li>Execute the instance variable initializers for this class, assigning their values to the corresponding instance variables, in the left-to-right order in which they appear textually in the source code for the class. If execution of any of these initializers results in an exception, then no further initializers are processed and this procedure completes abruptly with that same exception. Otherwise, continue with step 5. (In some early Java implementations, the compiler incorrectly omitted the code to initialize a field if the field initializer expression was a constant expression whose value was equal to the default initialization value for its type.)
<a name="44701"></a>
<li>Execute the rest of the body of this constructor. If that execution completes abruptly, then this procedure completes abruptly for the same reason. Otherwise, this procedure completes normally.
</ol>
<a name="44702"></a>
In the example:
<p><pre><a name="44703"></a>
class Point {
<a name="44704"></a>	int x, y;
<a name="44705"></a>	Point() { x = 1; y = 1; }
<a name="44706"></a>}
<a name="44707"></a>
class ColoredPoint extends Point {
<a name="44708"></a>	int color = 0xFF00FF;
<a name="44709"></a>}
<a name="44710"></a>
class Test {
<a name="44711"></a>	public static void main(String[] args) {
<a name="44712"></a>		ColoredPoint cp = new ColoredPoint();
<a name="44713"></a>		System.out.println(cp.color);
<a name="44714"></a>	}
<a name="44715"></a>}
</pre><a name="44716"></a>
a new instance of <code>ColoredPoint</code> is created. First, space is allocated for the new 
<code>ColoredPoint</code>, to hold the fields <code>x</code>, <code>y</code>, and <code>color</code>. All these fields are then initialized
to their default values (in this case, <code>0</code> for each field). Next, the <code>ColoredPoint</code> 
constructor with no arguments is first invoked. Since <code>ColoredPoint</code> declares no 
constructors, a default constructor of the form:
<p><pre><a name="44717"></a>ColoredPoint() { super(); }
</pre><a name="44718"></a>
is provided for it automatically by the Java compiler.
<p><a name="44719"></a>
This constructor then invokes the <code>Point</code> constructor with no arguments. The <code>Point</code> constructor does not begin with an invocation of a constructor, so the compiler provides an implicit invocation of its superclass constructor of no arguments, as though it had been written:<p>
<pre><a name="44720"></a>Point() { super(); x = 1; y = 1; }
</pre><a name="44721"></a>
Therefore, the constructor for <code>Object</code> which takes no arguments is invoked.
<p><a name="46262"></a>
The class <code>Object</code> has no superclass, so the recursion terminates here. Next, any instance variable initializers and static initializers of <code>Object</code> are invoked. Next, the body of the constructor of <code>Object</code> that takes no arguments is executed. No such constructor is declared in <code>Object</code>, so the compiler supplies a default one, which in this special case is:<p>
<pre><a name="44722"></a>Object() { }
</pre><a name="44723"></a>
This constructor executes without effect and returns.
<p><a name="44724"></a>
Next, all initializers for the instance variables of class <code>Point</code> are executed. As it happens, the declarations of <code>x</code> and <code>y</code> do not provide any initialization expressions, so no action is required for this step of the example. Then the body of the <code>Point</code> constructor is executed, setting <code>x</code> to <code>1</code> and <code>y</code> to <code>1</code>.<p>
<a name="44725"></a>
Next, the initializers for the instance variables of class <code>ColoredPoint</code> are executed. This step assigns the value <code>0xFF00FF</code> to <code>color</code>. Finally, the rest of the body of the <code>ColoredPoint</code> constructor is executed (the part after the invocation of <code>super</code>); there happen to be no statements in the rest of the body, so no further action is required and initialization is complete.<p>
<a name="44726"></a>
Unlike C++, the Java language does not specify altered rules for method dispatch during the creation of a new class instance. If methods are invoked that are overridden in subclasses in the object being initialized, then these overriding methods are used, even before the new object is completely initialized. Thus, compiling and running the example:<p>
<pre><a name="44727"></a>
class Super {
<a name="44728"></a>	Super() { printThree(); }
<a name="44729"></a>	void printThree() { System.out.println("three"); }
<a name="44730"></a>}
</pre><pre><a name="48312"></a>
class Test extends Super {
<a name="44732"></a>	int indiana = (int)Math.PI;													// That is, 3
<a name="44733"></a>
	public static void main(String[] args) {
<a name="44734"></a>		Test t = new Test();
<a name="44735"></a>		t.printThree();
<a name="44736"></a>	}
<a name="44737"></a>	void printThree() { System.out.println(indiana); }
<a name="44738"></a>}
</pre><a name="44739"></a>
produces the output:
<p><pre><a name="44740"></a>
<code>0
</code><a name="44741"></a>3
</pre><a name="44742"></a>
This shows that the invocation of <code>printThree</code> in the constructor for class <code>Super</code> 
does not invoke the definition of <code>printThree</code> in class <code>Super</code>, but rather invokes 
the overriding definition of <code>printThree</code> in class <code>Test</code>. This method therefore 
runs before the field initializers of <code>Test</code> have been executed, which is why the first 
value output is <code>0</code>, the default value to which the field <code>three</code> of <code>Test</code> is initialized. 
The later invocation of <code>printThree</code> in method <code>main</code> invokes the same definition 
of <code>printThree</code>, but by that point the initializer for instance variable <code>three</code> has 
been executed, and so the value <code>3</code> is printed.
<p><a name="44746"></a>
See <a href="8.doc.html#41652">&#167;8.6</a> for more details on constructor declarations.<p>
<a name="44748"></a>
<h2>12.6    Finalization of Class Instances</h2>
<a name="44752"></a>
The class <code>Object</code> has a <code>protected</code> method called <code>finalize</code> &#32;<a href="javalang.doc1.html#23198">(&#167;20.1.11)</a>; this 
method can be overridden by other classes. The particular definition of <code>finalize</code> 
that can be invoked for an object is called the <i>finalizer</i> of that object. Before the 
storage for an object is reclaimed by the garbage collector, the Java Virtual 
Machine will invoke the finalizer<i> </i>of that object.
<p><a name="44753"></a>
Finalizers provide a chance to free up resources (such as file descriptors or operating system graphics contexts) that cannot be freed automatically by an automatic storage manager. In such situations, simply reclaiming the memory used by an object would not guarantee that the resources it held would be reclaimed.<p>
<a name="44754"></a>
The Java language does not specify how soon a finalizer will be invoked, except to say that it will happen before the storage for the object is reused. Also, the Java language does not specify which thread will invoke the finalizer for any given object. If an uncaught exception is thrown during the finalization, the exception is ignored and finalization of that object terminates.<p>
<a name="44755"></a>
The <code>finalize</code> method declared in class <code>Object</code> takes no action. However, the fact that class <code>Object</code> declares a <code>finalize</code> method means that the <code>finalize</code> method for any class can always invoke the <code>finalize</code> method for its superclass, which is usually good practice. (Unlike constructors, finalizers do not automatically invoke the finalizer for the superclass; such an invocation must be coded explicitly.)<p>
<a name="44756"></a>
For efficiency, an implementation may keep track of classes that do not override the <code>finalize</code> method of class <code>Object</code>, or override it in a trivial way, such as:<p>
<pre><a name="44757"></a>protected void finalize() throws Throwable {<br>
	super.finalize();<br>
}
</pre><a name="44758"></a>
We encourage implementations to treat such objects as having a finalizer that is 
not overridden, and to finalize them more efficiently, as described in <a href="12.doc.html#44760">&#167;12.6.1</a>.
<p><a name="44759"></a>
A finalizer may be invoked explicitly, just like any other method.<p>
<a name="44760"></a>
<h3>12.6.1    Implementing Finalization</h3>
<a name="44761"></a>
Every object can be characterized by two attributes: it may be <i>reachable</i>, <i>finalizer-
reachable</i>, or <i>unreachable</i>, and it may also be <i>unfinalized</i>, <i>finalizable</i>, or <i>finalized</i>.
<p><a name="44762"></a>
A <i>reachable</i> object is any object that can be accessed in any potential continuing computation from any live thread. Optimizing transformations of a program can be designed that reduce the number of objects that are reachable to be less than those which would naively be considered reachable. For example, a compiler or code generator may choose, explicitly or implicitly, to set a variable or parameter that will no longer be used to <code>null</code> to cause the storage for such an object to be potentially reclaimable sooner. A <i>finalizer-reachable</i> object can be reached from some finalizable object through some chain of references, but not from any live thread. An <i>unreachable</i> object cannot be reached by either means.<p>
<a name="44763"></a>
An <i>unfinalized</i> object has never had its finalizer automatically invoked; a <i>finalized</i> object has had its finalizer automatically invoked. A <i>finalizable</i> object has never had its finalizer automatically invoked, but the Java Virtual Machine may eventually automatically invoke its finalizer.<p>
<a name="48746"></a>
The life cycle of an object obeys the following transition diagram, where we abbreviate "finalizer-reachable" as "f-reachable":<img src="12.doc.anc.gif"><p>
<a name="48817"></a>
<p>
<a name="48818"></a>
When an object is first created (A), it is reachable and unfinalized.<p>
<a name="48565"></a>
As references to an object are discarded during program execution, an object that was reachable may become finalizer-reachable (B, C, D) or unreachable (E, F). (Note that a finalizer-reachable object never becomes unreachable directly; it becomes reachable when the finalizer from which it can be reached is invoked, as explained below.)<p>
<a name="44823"></a>
If the Java Virtual Machine detects that an unfinalized object has become finalizer-reachable or unreachable, it may label the object finalizable (G, H); moreover, if the object was unreachable, it becomes finalizer-reachable (H).<p>
<a name="44824"></a>
If the Java Virtual Machine detects that a finalized object has become unreachable, it may reclaim the storage occupied by the object because the object will never again become reachable (I).<p>
<a name="44825"></a>
At any time, a Java Virtual Machine may take any finalizable object, label it finalized, and then invoke its <code>finalize</code> method in some thread. This causes the object to become finalized and reachable (J, K), and it also may cause other objects that were finalizer-reachable to become reachable again (L, M, N).<p>
<a name="44826"></a>
A finalizable object cannot also be unreachable; it can be reached because its finalizer may eventually be invoked, whereupon the thread running the finalizer will have access to the object, as <code>this</code> <a href="15.doc.html#31980">(&#167;15.7.2)</a>. Thus, there are actually only eight possible states for an object.<p>
<a name="44830"></a>
After an object has been finalized, no further action is taken until the automatic storage management determines that it is unreachable. Because of the way that an object progresses from the <i>unfinalized</i> state through the <i>finalizable</i> state to the <i>finalized</i> state, the <code>finalize</code> method is never automatically invoked more than once by a Java Virtual Machine for each object, even if the object is again made reachable after it has been finalized.<p>
<a name="44831"></a>
Explicit invocation of a finalizer ignores the current state of the object and does not change the state of the object from unfinalized or finalizable to finalized.<p>
<a name="44832"></a>
If a class does not override method <code>finalize</code> of class <code>Object</code> (or overrides it in only a trivial way, as described above), then if instances of such as class become unreachable, they may be discarded immediately rather than made to await a second determination that they have become unreachable. This strategy is indicated by the dashed arrow (O) in the transition diagram.<p>
<a name="44833"></a>
Java programmers should also be aware that a finalizer can be automatically invoked, even though it is reachable, during finalization-on-exit <a href="12.doc.html#44857">(&#167;12.9)</a>; moreover, a finalizer can also be invoked explicitly as an ordinary method. Therefore, we recommend that the design of <code>finalize</code> methods be kept simple and that they be programmed defensively, so that they will work in all cases.<p>
<a name="44837"></a>
<h3>12.6.2    Finalizer Invocations are Not Ordered</h3>
<a name="44838"></a>
Java imposes no ordering on finalize method calls. Finalizers may be called in any 
order, or even concurrently.
<p><a name="44839"></a>
As an example, if a circularly linked group of unfinalized objects becomes unreachable (or finalizer-reachable), then all the objects may become finalizable together. Eventually, the finalizers for these objects may be invoked, in any order, or even concurrently using multiple threads. If the automatic storage manager later finds that the objects are unreachable, then their storage can be reclaimed.<p>
<a name="48740"></a>
It is straightforward to implement a Java class that will cause a set of finalizer-like methods to be invoked in a specified order for a set of objects when all the objects become unreachable. Defining such a class is left as an exercise for the reader.<p>
<a name="48744"></a>
<h2>12.7    Finalization of Classes</h2>
<a name="44843"></a>
If a class declares a class method <code>classFinalize</code> that takes no arguments and 
returns no result:
<p><pre><a name="44844"></a>static void classFinalize() throws Throwable { . . . }
</pre><a name="44848"></a>
then this method will be invoked before the class is unloaded <a href="12.doc.html#44850">(&#167;12.8)</a>. Like the 
<code>finalize</code> method for objects, this method will be automatically invoked only 
once. This method may optionally be declared <code>private</code>, <code>protected</code>, or <code>public</code>.
<p><a name="44850"></a>
<h2>12.8    Unloading of Classes and Interfaces</h2>
<a name="44851"></a>
A Java Virtual Machine may provide mechanisms whereby classes are <i>unloaded</i>. 
The details of such mechanisms are not specified in this version of the Java Language
Specification. In general, groups of related class and interface types will be 
unloaded together. This can be used, for example, to unload a group of related 
types that have been loaded using a particular class loader. Such a group might 
consist of all the classes implementing a single applet in a Java-based browser 
such as HotJava, for example.
<p><a name="48002"></a>
A class may not be unloaded while any instance of it is still reachable <a href="12.doc.html#44748">(&#167;12.6)</a>. A class or interface may not be unloaded while the <code>Class</code> object that represents it is still reachable.<p>
<a name="44855"></a>
Classes that declare class finalizers <a href="12.doc.html#48744">(&#167;12.7)</a> will have these finalizers run before they are unloaded.<p>
<a name="44857"></a>
<h2>12.9    Virtual Machine Exit</h2>
<a name="44858"></a>
A Java Virtual Machine terminates all its activity and <i>exits</i> when one of two things 
happens:
<p><ul><a name="44862"></a>
<li>All the threads that are not daemon threads <a href="javalang.doc18.html#2860">(&#167;20.20.24)</a> terminate.
<a name="44866"></a>
<li>Some thread invokes the <code>exit</code> method <a href="javalang.doc15.html#34351">(&#167;20.16.2)</a> of class <code>Runtime</code> or class <code>System</code> and the exit operation is not forbidden by the security manager <a href="javalang.doc16.html#14111">(&#167;20.17.13)</a>.
</ul><a name="57365"></a>
A Java program can specify that the finalizers of all objects that have finalizers, 
and all classes that have class finalizers, that have not yet been automatically 
invoked are to be run before the virtual machine exits. This is done by invoking 
the method <code>runFinalizersOnExit</code> of class <code>System</code> with the argument <code>true</code>. The 
default is to not run finalizers on exit, and this behavior may be restored by invoking
<code>runFinalizersOnExit</code> with the argument <code>false</code>. An invocation of the <code>runFinalizersOnExit
</code> method is permitted only if the caller is allowed to <code>exit</code>, and 
is otherwise rejected by the <code>SecurityManager</code> <a href="javalang.doc16.html#46274">(&#167;20.17)</a>.
<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="11.doc.html">Prev</a> | <a href="13.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>