<html>
<head>
<title>The Java Language Specification
 The Package java.io </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="javautil.doc12.html">Prev</a> | <a href="javaio.doc1.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="46185"></a>
<p><strong>
CHAPTER
 22 </strong></p>
<a name="46187"></a>
<h1>The Package java.io </h1>
<hr><p>
<a name="27524"></a>
Input and output in Java is organized around the concept of streams. A stream 
is a sequence of items, usually 8-bit bytes, read or written over the course of time.
<p><a name="27530"></a>
In the <code>java.io</code> package, all input is done through subclasses of the abstract class <code>InputStream</code>, and all output is done through subclasses of the abstract class <code>OutputStream</code>. The one exception to this rule is the class <code>RandomAccessFile</code>, which handles files that allow random access and perhaps intermixed reading and writing of the file.<p>
<a name="27534"></a>
For an input stream, the source of data might be a file, a <code>String</code>, an array of bytes, or bytes written to an output stream (typically by another thread). There are also "filter input streams" that take data from another input stream and transform or augment the data before delivering it as input. For example, a <code>LineNumberInputStream</code> &#32;passes bytes through verbatim but counts line terminators as they are read.<p>
<a name="27537"></a>
For an output stream, the sink of data might be a file, an array of bytes, or a buffer to be read as an input stream (typically by another thread). There are also "filter output streams" that transform or augment data before writing it to some other output stream.<p>
<a name="27564"></a>
An instance of class <code>File</code> represents a path name (a string) that might identify a particular file within a file system. Certain operations on the file system, such as renaming and deleting files, are done by this class rather than through streams.<p>
<a name="27687"></a>
An instance of class <code>FileDescriptor</code> represents an abstract indication of a particular file within a file system; such file descriptors are created internally by the Java I/O system.<p>
<a name="27586"></a>
There are two interfaces, <code>DataInput</code> and <code>DataOutput</code>, that support the transfer of data other than bytes or characters, such as long integers, floating-point numbers and strings. The class <code>DataInputStream</code> implements <code>DataInput</code>; the class <code>DataOutputStream</code> implements <code>DataOutput</code>; and <code>RandomAccessFile</code> implements both <code>DataInput</code> and <code>DataOutput</code>.<p>
<a name="27588"></a>
The class <code>StreamTokenizer</code> provides some simple support for parsing bytes or characters from an input stream into tokens such as identifiers, numbers, and strings, optionally ignoring comments and optionally recognizing or ignoring line terminators.<p>
<a name="27733"></a>
The hierarchy of classes defined in package <code>java.io</code> is as follows. (Classes whose names are shown here in <code><b>boldface</b></code> are in package <code>java.io</code>; the others are in package <code>java.lang</code> and are shown here to clarify subclass relationships.)<p>
<pre><a name="27572"></a>Object												<code><a href="javalang.doc1.html#46442">&#167;20.1</a></code>				
<a name="32844"></a>	interface<code><b> DataInput												<a href="javaio.doc.html#28762">&#167;22.1</a>
</b></code><a name="32849"></a>	interface<code><b> DataOutput												<a href="javaio.doc.html#42209">&#167;22.2</a>
</b></code><a name="32854"></a>	<code><b>InputStream												<a href="javaio.doc1.html#28126">&#167;22.3</a>
</b></code><a name="27604"></a>		<code><b>FileInputStream												<a href="javaio.doc2.html#28230">&#167;22.4</a>
</b></code><a name="27615"></a>		<code><b>PipedInputStream												<a href="javaio.doc3.html#28307">&#167;22.5</a>
</b></code><a name="27577"></a>		<code><b>ByteArrayInputStream												<a href="javaio.doc4.html#28355">&#167;22.6</a>
</b></code><a name="27578"></a>		<code><b>StringBufferInputStream												<a href="javaio.doc5.html#28427">&#167;22.7</a>
</b></code><a name="27580"></a>		<code><b>SequenceInputStream												<a href="javaio.doc6.html#28491">&#167;22.8</a>
</b></code><a name="27582"></a>		<code><b>FilterInputStream												<a href="javaio.doc7.html#28534">&#167;22.9</a>
</b></code><a name="27630"></a>			<code><b>BufferedInputStream												<a href="javaio.doc8.html#28120">&#167;22.10</a>
</b></code><a name="27599"></a>		<code><b>	DataInputStream												<a href="javaio.doc9.html#28623">&#167;22.11</a>
</b></code><a name="27535"></a>		<code><b>	LineNumberInputStream												<a href="javaio.doc10.html#32925">&#167;22.12</a>
</b></code><a name="27681"></a>			<code><b>PushBackInputStream												<a href="javaio.doc21.html#27769">&#167;22.13</a>
</b></code><a name="30359"></a>	<code><b>StreamTokenizer												<a href="javaio.doc12.html#29287">&#167;22.14</a>
</b></code><a name="30360"></a>	<code><b>OutputStream												<a href="javaio.doc13.html#29399">&#167;22.15</a>
</b></code><a name="30361"></a>		<code><b>FileOutputStream												<a href="javaio.doc14.html#29496">&#167;22.16</a>
</b></code><a name="27663"></a>		<code><b>PipedOutputStream												<a href="javaio.doc15.html#29449">&#167;22.17</a>
</b></code><a name="27664"></a>		<code><b>ByteArrayOutputStream												<a href="javaio.doc16.html#29558">&#167;22.18</a>
</b></code><a name="27667"></a>		<code><b>FilterOutputStream												<a href="javaio.doc21.html#27982">&#167;22.19</a>
</b></code><a name="27668"></a>			<code><b>BufferedOutputStream												<a href="javaio.doc18.html#9059">&#167;22.20</a>
</b></code><a name="27669"></a>			<code><b>DataOutputStream												<a href="javaio.doc19.html#9231">&#167;22.21</a>
</b></code><a name="27670"></a>			<code><b>PrintStream												<a href="javaio.doc20.html#29906">&#167;22.22</a>
</b></code><a name="27646"></a>	<code><b>RandomAccessFile												<a href="javaio.doc21.html#27738">&#167;22.23</a>
</b></code><a name="27652"></a><code><b>	File												<a href="javaio.doc22.html#29705">&#167;22.24</a>
</b></code><a name="32863"></a>	interface<code><b> FileNameFilter												<a href="javaio.doc22.html#30147">&#167;22.25</a>
</b></code><a name="32868"></a>	<code><b>FileDescriptor												<a href="javaio.doc23.html#29890">&#167;22.26</a>
</b></code><a name="30355"></a>	Throwable												<a href="javalang.doc20.html#46198">&#167;20.22</a>
<a name="30356"></a>		Exception												<a href="javalang.doc20.html#46198">&#167;20.22</a>
<a name="27598"></a>			<code><b>IOException												<a href="javaio.doc24.html#30171">&#167;22.27</a>
</b></code><a name="30143"></a>				<code><b>EOFException												<a href="javaio.doc25.html#32995">&#167;22.28</a>
</b></code><a name="27658"></a>				<code><b>FileNotFoundException												<a href="javaio.doc26.html#30115">&#167;22.29</a>
</b></code><a name="27656"></a>				<code><b>InterruptedIOException												<a href="javaio.doc27.html#30205">&#167;22.30</a>
</b></code><a name="28119"></a>				<code><b>UTFDataFormatException												<a href="javaio.doc28.html#10137">&#167;22.31</a>
</b></code></pre><a name="28762"></a>
<h1>22.1  The Interface  <code>java.io.DataInput</code></h1>
<a name="28763"></a>
The <code>DataInput</code> interface provides for reading bytes from a binary stream and 
reconstructing from them data in any of the Java primitive types. There is also a 
facility for reconstructing a <code>String</code> from data in Java modified UTF-8 format.
<p><a name="28767"></a>
The <code>DataOutput</code> interface <a href="javaio.doc.html#42209">(&#167;22.2)</a> supports the creation of binary output data suitable for reading back in through the <code>DataInput</code> interface.<p>
<a name="28768"></a>
The <code>DataInput</code> interface is implemented by classes <code>DataInputStream</code> <a href="javaio.doc9.html#28623">(&#167;22.11)</a> and <code>RandomAccessFile</code> <a href="javaio.doc21.html#27738">(&#167;22.23)</a>.<p>
<pre><a name="28775"></a>public interface <code><b>DataInput</b></code> {
<a name="28776"></a>	public void <code><b>readFully</b></code>(byte[] b)
<a name="32257"></a>		throws IOException, NullPointerException;
<a name="28777"></a>	public void <code><b>readFully</b></code>(byte[] b, int off, int len)
<a name="28778"></a>		throws IOException, NullPointerException,
<a name="32260"></a>			IndexOutOfBoundsException;
<a name="28779"></a>	public int <code><b>skipBytes</b></code>(int n) throws IOException;
<a name="28780"></a>	public boolean <code><b>readBoolean</b></code>() throws IOException;
<a name="28781"></a>	public byte <code><b>readByte</b></code>() throws IOException;
<a name="28782"></a>	public int <code><b>readUnsignedByte</b></code>() throws IOException;
<a name="28783"></a>	public short <code><b>readShort</b></code>() throws IOException;
<a name="28784"></a>	public int <code><b>readUnsignedShort</b></code>() throws IOException;
<a name="28785"></a>	public char <code><b>readChar</b></code>() throws IOException;
<a name="28786"></a>	public int <code><b>readInt</b></code>() throws IOException;
<a name="28787"></a>	public long <code><b>readLong</b></code>() throws IOException;
<a name="28788"></a>	public float <code><b>readFloat</b></code>() throws IOException;
<a name="28789"></a>	public double <code><b>readDouble</b></code>() throws IOException;
<a name="28790"></a>	public String <code><b>readLine</b></code>() throws IOException;
<a name="28791"></a>	public String <code><b>readUTF</b></code>() throws IOException;
<a name="28794"></a>}
</pre><a name="30226"></a>
It is generally true of all the reading routines in this interface that if end of file is reached before the desired number of bytes has been read, an <code>EOFException</code> (which is a kind of <code>IOException</code>) is thrown. If any byte cannot be read for any reason other than end of file, an <code>IOException</code> other than <code>EOFException</code> is thrown. In particular, an <code>IOException</code> may be thrown if the input stream has been closed <a href="javaio.doc1.html#28187">(&#167;22.3.6)</a>.<p>
<a name="28801"></a>
<p><font size=+1><strong>22.1.1   </strong> <code>public void <code><b>readFully</b></code>(byte[] b)<br>throws IOException, <code>NullPointerException</code>;</code></font>
<p>
<a name="28802"></a>
The general contract of <code>readFully(b)</code> is that it reads some bytes from an input 
stream and stores them into the buffer array <code>b</code>. The number of bytes read is equal 
to the length of <code>b</code>.
<p><a name="31275"></a>
This method blocks until one of the following conditions occurs:<p>
<ul><a name="31276"></a>
<li><code>b.length</code> bytes of input data are available, in which case a normal return is made.
<a name="31277"></a>
<li>End of file is detected, in which case an <code>EOFException</code> is thrown.
<a name="31278"></a>
<li>An I/O error occurs, in which case an <code>IOException</code> other than <code>EOFException</code> is thrown.
</ul><a name="28804"></a>
If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="28805"></a>
If <code>b.length</code> is zero, then no bytes are read. Otherwise, the first byte read is stored into element <code>b[0]</code>, the next one into <code>b[1]</code>, and so on.<p>
<a name="31283"></a>
If an exception is thrown from this method, then it may be that some but not all bytes of <code>b</code> have been updated with data from the input stream.<p>
<a name="28807"></a>
<p><font size=+1><strong>22.1.2   </strong> <code>public void <code><b>readFully</b></code>(byte[] b, int off, int len)<br>throws IOException, <code>NullPointerException</code>,<br> &#32; &#32; &#32;IndexOutOfBoundsException</code></font>
<p>
<a name="28808"></a>
The general contract of <code>readFully(b, off, len)</code> is that it reads <code>len</code> bytes from 
an input stream.
<p><a name="28809"></a>
This method blocks until one of the following conditions occurs:<p>
<ul><a name="31270"></a>
<li><code>len</code> bytes of input data are available, in which case a normal return is made.
<a name="31271"></a>
<li>End of file is detected, in which case an <code>EOFException</code> is thrown.
<a name="31273"></a>
<li>An I/O error occurs, in which case an <code>IOException</code> other than <code>EOFException</code> is thrown.
</ul><a name="28810"></a>
If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="28811"></a>
If <code>off</code> is negative, or <code>len</code> is negative, or <code>off+len</code> is greater than the length of the array <code>b</code>, then an <code>IndexOutOfBoundsException</code> is thrown.<p>
<a name="28812"></a>
If <code>len</code> is zero, then no bytes are read. Otherwise, the first byte read is stored into element <code>b[off]</code>, the next one into <code>b[off+1]</code>, and so on. The number of bytes read is, at most, equal to <code>len</code>.<p>
<a name="31291"></a>
If an exception is thrown from this method, then it may be that some but not all bytes of <code>b</code> in positions <code>off</code> through <code>off+len-1</code> have been updated with data from the input stream.<p>
<a name="28814"></a>
<p><font size=+1><strong>22.1.3   </strong> <code>public int <code><b>skipBytes</b></code>(int n) throws IOException</code></font>
<p>
<a name="28815"></a>
The general contract of <code>skipBytes</code> is that it makes an attempt to skip over <code>n</code> bytes 
of data from the input stream, discarding the skipped bytes. However, it may skip 
over some smaller number of bytes, possibly zero. This may result from any of a 
number of conditions; reaching end of file before <code>n</code> bytes have been skipped is 
only one possibility. This method never throws an <code>EOFException</code>. The actual 
number of bytes skipped is returned.
<p><a name="28817"></a>
<p><font size=+1><strong>22.1.4   </strong> <code>public boolean <code><b>readBoolean</b></code>() throws IOException;</code></font>
<p>
<a name="28818"></a>
The general contract of <code>readBoolean</code> is that it reads one input byte and returns 
<code>true</code> if that byte is nonzero, <code>false</code> if that byte is zero.
<p><a name="28819"></a>
This method is suitable for reading the byte written by the <code>writeBoolean</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#28974">(&#167;22.2.4)</a>.<p>
<a name="28824"></a>
<p><font size=+1><strong>22.1.5   </strong> <code>public byte <code><b>readByte</b></code>() throws IOException</code></font>
<p>
<a name="28825"></a>
The general contract of <code>readByte</code> is that it reads and returns one input byte. The 
byte is treated as a signed value in the range <code>-128</code> through <code>127</code>, inclusive.
<p><a name="28826"></a>
This method is suitable for reading the byte written by the <code>writeByte</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#28981">(&#167;22.2.5)</a>.<p>
<a name="28831"></a>
<p><font size=+1><strong>22.1.6   </strong> <code>public int <code><b>readUnsignedByte</b></code>() throws IOException</code></font>
<p>
<a name="28832"></a>
The general contract of <code>readUnsignedByte</code> is that it reads one input byte, zero-
extends it to type <code>int</code>, and returns the result, which is therefore in the range <code>0</code> 
through <code>255</code>.
<p><a name="28833"></a>
This method is suitable for reading the byte written by the <code>writeByte</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#28981">(&#167;22.2.5)</a> if the argument to <code>writeByte</code> was intended to be a value in the range <code>0</code> through <code>255</code>.<p>
<a name="28838"></a>
<p><font size=+1><strong>22.1.7   </strong> <code>public short <code><b>readShort</b></code>() throws IOException</code></font>
<p>
<a name="28839"></a>
The general contract of <code>readShort</code> is that it reads two input bytes and returns a 
<code>short</code> value. Let <code>a</code> be the first byte read and <code>b</code> be the second byte. The value 
returned is:
<p><pre><a name="31301"></a><code>(short)((a &lt;&lt; 8) | (b &amp; 0xff))
</code></pre><a name="28840"></a>
This method is suitable for reading the bytes written by the <code>writeShort</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#28988">(&#167;22.2.6)</a>.<p>
<a name="28845"></a>
<p><font size=+1><strong>22.1.8   </strong> <code>public int <code><b>readUnsignedShort</b></code>() throws IOException</code></font>
<p>
<a name="28846"></a>
The general contract of <code>readUnsignedShort</code> is that it reads two input bytes and 
returns an <code>int</code> value in the range <code>0</code> through <code>65535</code>. Let <code>a</code> be the first byte read and 
<code>b</code> be the second byte. The value returned is:
<p><pre><a name="28847"></a><code>(((a &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
</code></pre><a name="28848"></a>
This method is suitable for reading the bytes written by the <code>writeShort</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#28988">(&#167;22.2.6)</a> if the argument to <code>writeShort</code> was intended to be a value in the range <code>0</code> through <code>65535</code>.<p>
<a name="28853"></a>
<p><font size=+1><strong>22.1.9   </strong> <code>public char <code><b>readChar</b></code>() throws IOException</code></font>
<p>
<a name="28854"></a>
The general contract of <code>readChar</code> is that it reads two input bytes and returns a 
<code>char</code> value. Let <code>a</code> be the first byte read and <code>b</code> be the second byte. The value 
returned is:
<p><pre><a name="31302"></a><code>(char)((a &lt;&lt; 8) | (b &amp; 0xff))
</code></pre><a name="28855"></a>
This method is suitable for reading bytes written by the <code>writeChar</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#28997">(&#167;22.2.7)</a>.<p>
<a name="28860"></a>
<p><font size=+1><strong>22.1.10   </strong> <code>public int <code><b>readInt</b></code>() throws IOException</code></font>
<p>
<a name="28861"></a>
The general contract of <code>readInt</code> is that it reads four input bytes and returns an 
<code>int</code> value. Let <code>a</code> be the first byte read, <code>b</code> be the second byte, <code>c</code> be the third byte, 
and <code>d</code> be the fourth byte. The value returned is:
<p><pre><a name="28862"></a>
<code>(((a &amp; 0xff) &lt;&lt; 24) | ((b &amp; 0xff) &lt;&lt; 16) |
</code><a name="28864"></a><code> &#32;((c &amp; 0xff) &lt;&lt; &#32; &#32;8) | (d &amp; 0xff))
</code></pre><a name="28866"></a>
This method is suitable for reading bytes written by the <code>writeInt</code> method of interface <code>DataOutput</code> <a href="javaio.doc16.html#29567">(&#167;22.2.8)</a>.<p>
<a name="28871"></a>
<p><font size=+1><strong>22.1.11   </strong> <code>public long <code><b>readLong</b></code>() throws IOException</code></font>
<p>
<a name="28872"></a>
The general contract of <code>readLong</code> is that it reads eight input bytes and returns a 
<code>long</code> value. Let <code>a</code> be the first byte read, <code>b</code> be the second byte, <code>c</code> be the third byte, <code>d</code> 
be the fourth byte, <code>e</code> be the fifth byte, <code>f</code> be the sixth byte, <code>g</code> be the seventh byte, 
and <code>h</code> be the eighth byte. The value returned is:
<p><pre><a name="28873"></a>
<code>(((long)(a &amp; 0xff) &lt;&lt; 56) |
</code><a name="28874"></a><code> &#32;((long)(b &amp; 0xff) &lt;&lt; 48) |
</code><a name="28875"></a><code> &#32;((long)(c &amp; 0xff) &lt;&lt; &#32;40) |
</code><a name="28876"></a><code> &#32;((long)(d &amp; 0xff) &lt;&lt; 32) |
</code><a name="28877"></a><code> &#32;((long)(e &amp; 0xff) &lt;&lt; &#32;24) |
</code><a name="28878"></a><code> &#32;((long)(f &amp; 0xff) &lt;&lt; 16) |
</code><a name="28879"></a><code> &#32;((long)(g &amp; 0xff) &lt;&lt; &#32; &#32;8) |
</code><a name="28880"></a><code> &#32;((long)(h &amp; 0xff)))
</code></pre><a name="28881"></a>
This method is suitable for reading bytes written by the <code>writeLong</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#29017">(&#167;22.2.9)</a>.<p>
<a name="28886"></a>
<p><font size=+1><strong>22.1.12   </strong> <code>public float <code><b>readFloat</b></code>() throws IOException</code></font>
<p>
<a name="28887"></a>
The general contract of <code>readFloat</code> is that it reads four input bytes and returns a 
<code>float</code> value. It does this by first constructing an <code>int</code> value in exactly the manner 
of the <code>readInt</code> method <a href="javaio.doc.html#28860">(&#167;22.1.10)</a>, then converting this <code>int</code> value to a <code>float</code> in 
exactly the manner of the method <code>Float.intBitsToFloat</code> <a href="javalang.doc8.html#5683">(&#167;20.9.23)</a>.
<p><a name="28894"></a>
This method is suitable for reading bytes written by the <code>writeFloat</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#29032">(&#167;22.2.10)</a>.<p>
<a name="28899"></a>
<p><font size=+1><strong>22.1.13   </strong> <code>public double <code><b>readDouble</b></code>() throws IOException</code></font>
<p>
<a name="28900"></a>
The general contract of <code>readDouble</code> is that it reads eight input bytes and returns a 
<code>double</code> value. It does this by first constructing a <code>long</code> value in exactly the manner 
of the <code>readlong</code> method <a href="javaio.doc.html#28871">(&#167;22.1.11)</a>, then converting this <code>long</code> value to a <code>double</code> 
in exactly the manner of the method <code>Double.longBitsToDouble</code> <a href="javalang.doc9.html#13864">(&#167;20.10.22)</a>.
<p><a name="28907"></a>
This method is suitable for reading bytes written by the <code>writeDouble</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#29045">(&#167;22.2.11)</a>.<p>
<a name="28912"></a>
<p><font size=+1><strong>22.1.14   </strong> <code>public String <code><b>readLine</b></code>() throws IOException</code></font>
<p>
<a name="28913"></a>
The general contract of <code>readLine</code> is that it reads successive bytes, converting 
each byte separately into a character, until it encounters a line terminator or end of 
file; the characters read are then returned as a <code>String</code>. Note that because this 
method processes bytes, it does not support input of the full Unicode character set.
<p><a name="28914"></a>
If end of file is encountered before even one byte can be read, then <code>null</code> is returned. Otherwise, each byte that is read is converted to type <code>char</code> by zero-extension. If the character <code>'\n'</code> is encountered, it is discarded and reading ceases. If the character <code>'\r'</code> is encountered, it is discarded and, if the following byte converts &#32;to the character <code>'\n'</code>, then that is discarded also; reading then ceases. If end of file is encountered before either of the characters <code>'\n'</code> and <code>'\r'</code> is encountered, reading ceases. Once reading has ceased, a <code>String</code> is returned that contains all the characters read and not discarded, taken in order. Note that every character in this string will have a value less than <code>\u0100</code>, that is, <code>(char)256</code>.<p>
<a name="28916"></a>
<p><font size=+1><strong>22.1.15   </strong> <code>public String <code><b>readUTF</b></code>() throws IOException</code></font>
<p>
<a name="28917"></a>
The general contract of <code>readUTF</code> is that it reads a representation of a Unicode 
character string encoded in Java modified UTF-8 format; this string of characters 
is then returned as a <code>String</code>.
<p><a name="28918"></a>
First, two bytes are read and used to construct an unsigned 16-bit integer in exactly the manner of the <code>readUnsignedShort</code> method <a href="javaio.doc20.html#29998">(&#167;22.1.8)</a>. This integer value is called the <i>UTF length</i> and specifies the number of additional bytes to be read. These bytes are then converted to characters by considering them in groups. The length of each group is computed from the value of the first byte of the group. The byte following a group, if any, is the first byte of the next group.<p>
<a name="28922"></a>
If the first byte of a group matches the bit pattern <code>0xxxxxxx</code> (where <code>x</code> means "may be <code>0</code> or <code>1</code>"), then the group consists of just that byte. The byte is zero-extended to form a character.<p>
<a name="28923"></a>
If the first byte of a group matches the bit pattern <code>110xxxxx</code>, then the group consists of that byte <code>a</code> and a second byte <code>b</code>. If there is no byte <code>b</code> (because byte <code>a</code> was the last of the bytes to be read), or if byte <code>b</code> does not match the bit pattern <code>10xxxxxx</code>, then a <code>UTFDataFormatException</code> is thrown. Otherwise, the group is converted to the character:<p>
<pre><a name="28924"></a><code>(char)(((a &amp; 0x1F) &lt;&lt; 6) | (b &amp; 0x3F))
</code></pre><a name="28925"></a>
If the first byte of a group matches the bit pattern <code>1110xxxx</code>, then the group consists of that byte <code>a</code> and two more bytes <code>b</code> and <code>c</code>. If there is no byte <code>c</code> (because byte <code>a</code> was one of the last two of the bytes to be read), or either byte <code>b</code> or byte <code>c</code> does not match the bit pattern <code>10xxxxxx</code>, then a <code>UTFDataFormatException</code> is thrown. Otherwise, the group is converted to the character:<p>
<pre><a name="28926"></a><code>(char)(((a &amp; 0x0F) &lt;&lt; 12) | ((b &amp; 0x3F) &lt;&lt; 6) | (c &amp; 0x3F))
</code></pre><a name="28927"></a>
If the first byte of a group matches the pattern <code>1111xxxx</code> or the pattern <code>10xxxxxx</code>, then a <code>UTFDataFormatException</code> is thrown.<p>
<a name="31354"></a>
If end of file is encountered at any time during this entire process, then an <code>EOFException</code> is thrown.<p>
<a name="28928"></a>
After every group has been converted to a character by this process, the characters are gathered, in the same order in which their corresponding groups were read from the input stream, to form a <code>String</code>, which is returned.<p>
<a name="42207"></a>
The <code>writeUTF</code> method of interface <code>DataOutput</code> <a href="javaio.doc.html#29074">(&#167;22.2.14)</a> may be used to write data that is suitable for reading by this method.<p>
<a name="42209"></a>
<h1>22.2  The Interface  <code>java.io.DataOutput</code></h1>
<a name="42210"></a>
The <code>DataOutput</code> interface provides for converting data from any of the Java primitive
types to a series of bytes and writing these bytes to a binary stream. There is 
also a facility for converting a <code>String</code> into Java modified UTF-8 format and writing
the resulting series of bytes.
<p><a name="28936"></a>
The <code>DataInput</code> interface <a href="javaio.doc.html#28762">(&#167;22.1)</a> can be used to read in and reconstruct Java data from the binary output data produced by the <code>DataOutput</code> interface.<p>
<a name="28937"></a>
The <code>DataOutput</code> interface is implemented by classes <code>DataOutputStream</code> <a href="javaio.doc19.html#9231">(&#167;22.21)</a> and <code>RandomAccessFile</code> <a href="javaio.doc21.html#27738">(&#167;22.23)</a>.<p>
<pre><a name="28944"></a>public interface <code><b>DataOutput</b></code> {
<a name="28945"></a>	public void <code><b>write</b></code>(int b) throws IOException;
<a name="32269"></a>	public void <code><b>write</b></code>(byte[] b)
<a name="32275"></a>		throws IOException, NullPointerException;
<a name="28947"></a>	public void <code><b>write</b></code>(byte[] b, int off, int len)
<a name="32266"></a>		throws IOException, NullPointerException,
<a name="28948"></a>			IndexOutOfBoundsException;
<a name="28949"></a>	public void <code><b>writeBoolean</b></code>(boolean v) throws IOException;
<a name="28950"></a>	public void <code><b>writeByte</b></code>(int v) throws IOException;
<a name="28951"></a>	public void <code><b>writeShort</b></code>(int v) throws IOException;
<a name="28952"></a>	public void <code><b>writeChar</b></code>(int v) throws IOException;
<a name="28953"></a>	public void <code><b>writeInt</b></code>(int v) throws IOException;
<a name="28954"></a>	public void <code><b>writeLong</b></code>(long v) throws IOException;
<a name="28955"></a>	public void <code><b>writeFloat</b></code>(float v) throws IOException;
<a name="28956"></a>	public void <code><b>writeDouble</b></code>(double v) throws IOException;
<a name="32277"></a>	public void <code><b>writeBytes</b></code>(String s)
<a name="28957"></a>		throws IOException, NullPointerException;
<a name="32280"></a>	public void <code><b>writeChars</b></code>(String s)
<a name="28958"></a>		throws IOException, NullPointerException;
<a name="32283"></a>	public void <code><b>writeUTF</b></code>(String s)
<a name="28959"></a>		throws IOException, NullPointerException;
<a name="28960"></a>}
</pre><a name="28961"></a>
For all the methods in this interface that write bytes, it is generally true that if a byte cannot be written for any reason, an <code>IOException</code> is thrown.<p>
<a name="28962"></a>
<p><font size=+1><strong>22.2.1   </strong> <code>public void <code><b>write</b></code>(int b) throws IOException</code></font>
<p>
<a name="28963"></a>
The general contract for <code>write</code> is that one byte is written to the output stream. The 
byte to be written is the eight low-order bits of the argument <code>b</code>. The 24 high-order 
bits of <code>b</code> are ignored.
<p><a name="28964"></a>
<p><font size=+1><strong>22.2.2   </strong> <code>public void <code><b>write</b></code>(byte[] b)<br>throws IOException, NullPointerException</code></font>
<p>
<a name="28965"></a>
The general contract for <code>write</code> is that all the bytes in array <code>b</code> are written, in order, 
to the output stream.
<p><a name="28966"></a>
If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="28967"></a>
If <code>b.length</code> is zero, then no bytes are written. Otherwise, the byte <code>b[0]</code> is written first, then <code>b[1]</code>, and so on; the last byte written is <code>b[b.length-1]</code>.<p>
<a name="28968"></a>
<p><font size=+1><strong>22.2.3   </strong> <code>public void <code><b>write</b></code>(byte[] b, int off, int len)<br>throws IOException, NullPointerException,  &#32; &#32; &#32;IndexOutOfBoundsException</code></font>
<p>
<a name="28969"></a>
The general contract for <code>write</code> is that <code>len</code> bytes from array <code>b</code> are written, in order, 
to the output stream.
<p><a name="28970"></a>
If <code>b</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="28971"></a>
If <code>off</code> is negative, or <code>len</code> is negative, or <code>off+len</code> is greater than the length of the array <code>b</code>, then an <code>IndexOutOfBoundsException</code> is thrown.<p>
<a name="28972"></a>
If <code>len</code> is zero, then no bytes are written. Otherwise, the byte <code>b[off]</code> is written first, then <code>b[off+1]</code>, and so on; the last byte written is <code>b[off+len-1]</code>.<p>
<a name="28974"></a>
<p><font size=+1><strong>22.2.4   </strong> <code>public void <code><b>writeBoolean</b></code>(boolean v) throws IOException</code></font>
<p>
<a name="28975"></a>
The general contract for <code>writeBoolean</code> is that one byte is written to the output 
stream. If the argument <code>v</code> is <code>true</code>, the value <code>(byte)1</code> is written; if <code>v</code> is <code>false</code>, the 
value <code>(byte)0</code> is written.
<p><a name="28976"></a>
The byte written by this method may be read by the <code>readBoolean</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28817">(&#167;22.1.4)</a>, which will then return a <code>boolean</code> equal to <code>v</code>.<p>
<a name="28981"></a>
<p><font size=+1><strong>22.2.5   </strong> <code>public void <code><b>writeByte</b></code>(int v) throws IOException</code></font>
<p>
<a name="28982"></a>
The general contract for <code>writeByte</code> is that one byte is written to the output stream 
to represent the value of the argument. The byte to be written is the eight low-
order bits of the argument <code>b</code>. The 24 high-order bits of <code>b</code> are ignored. (This means 
that <code>writeByte</code> does exactly the same thing as <code>write</code> for an integer argument.)
<p><a name="28983"></a>
The byte written by this method may be read by the <code>readByte</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28824">(&#167;22.1.5)</a>, which will then return a <code>byte</code> equal to <code>(byte)v</code>.<p>
<a name="28988"></a>
<p><font size=+1><strong>22.2.6   </strong> <code>public void <code><b>writeShort</b></code>(int v) throws IOException</code></font>
<p>
<a name="28989"></a>
The general contract for <code>writeShort</code> is that two bytes are written to the output 
stream to represent the value of the argument. The byte values to be written, in the 
order shown, are:
<p><pre><a name="28990"></a>
(byte)(0xff &amp; (v &gt;&gt; 8))
<a name="28991"></a>(byte)(0xff &amp; v)
</pre><a name="28992"></a>
The bytes written by this method may be read by the <code>readShort</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28838">(&#167;22.1.7)</a>, which will then return a <code>short</code> equal to <code>(short)v</code>.<p>
<a name="28997"></a>
<p><font size=+1><strong>22.2.7   </strong> <code>public void <code><b>writeChar</b></code>(int v) throws IOException</code></font>
<p>
<a name="28998"></a>
The general contract for <code>writeChar</code> is that two bytes are written to the output 
stream to represent the value of the argument. The byte values to be written, in the 
order shown, are:
<p><pre><a name="28999"></a>
(byte)(0xff &amp; (v &gt;&gt; 8))
<a name="29000"></a>(byte)(0xff &amp; v)
</pre><a name="29001"></a>
The bytes written by this method may be read by the <code>readChar</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28853">(&#167;22.1.9)</a>, which will then return a <code>char</code> equal to <code>(char)v</code>.<p>
<a name="29006"></a>
<p><font size=+1><strong>22.2.8   </strong> <code>public void <code><b>writeInt</b></code>(int v) throws IOException</code></font>
<p>
<a name="29007"></a>
The general contract for <code>writeInt</code> is that four bytes are written to the output 
stream to represent the value of the argument. The byte values to be written, in the 
order shown, are:
<p><pre><a name="29008"></a>
(byte)(0xff &amp; (v &gt;&gt; 24))
<a name="29009"></a>(byte)(0xff &amp; (v &gt;&gt; 16))
<a name="29010"></a>(byte)(0xff &amp; (v &gt;&gt; &#32; &#32;8))
<a name="29011"></a>(byte)(0xff &amp; v)
</pre><a name="29012"></a>
The bytes written by this method may be read by the <code>readInt</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28860">(&#167;22.1.10)</a>, which will then return an <code>int</code> equal to <code>v</code>.<p>
<a name="29017"></a>
<p><font size=+1><strong>22.2.9   </strong> <code>public void <code><b>writeLong</b></code>(long v) throws IOException</code></font>
<p>
<a name="29018"></a>
The general contract for <code>writeLong</code> is that four bytes are written to the output 
stream to represent the value of the argument. The byte values to be written, in the 
order shown, are:
<p><pre><a name="29019"></a>
(byte)(0xff &amp; (v &gt;&gt; 56))
<a name="29020"></a>(byte)(0xff &amp; (v &gt;&gt; 48))
<a name="29021"></a>(byte)(0xff &amp; (v &gt;&gt; 40))
<a name="29022"></a>(byte)(0xff &amp; (v &gt;&gt; 32))
<a name="29023"></a>(byte)(0xff &amp; (v &gt;&gt; 24))
<a name="29024"></a>(byte)(0xff &amp; (v &gt;&gt; 16))
<a name="29025"></a>(byte)(0xff &amp; (v &gt;&gt; &#32; &#32;8))
<a name="29026"></a>(byte)(0xff &amp; v)
</pre><a name="29027"></a>
The bytes written by this method may be read by the <code>readLong</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28871">(&#167;22.1.11)</a>, which will then return a <code>long</code> equal to <code>v</code>.<p>
<a name="29032"></a>
<p><font size=+1><strong>22.2.10   </strong> <code>public void <code><b>writeFloat</b></code>(float v) throws IOException</code></font>
<p>
<a name="29033"></a>
The general contract for <code>writeFloat</code> is that four bytes are written to the output 
stream to represent the value of the argument. It does this as if it first converts this 
<code>float</code> value to an <code>int</code> in exactly the manner of the <code>Float.floatToIntBits</code> 
method <a href="javalang.doc8.html#14423">(&#167;20.9.22)</a> and then writes the <code>int</code> value in exactly the manner of the 
<code>writeInt</code> method <a href="javaio.doc16.html#29567">(&#167;22.2.8)</a>.
<p><a name="29040"></a>
The bytes written by this method may be read by the <code>readFloat</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28886">(&#167;22.1.12)</a>, which will then return a <code>float</code> equal to <code>v</code>.<p>
<a name="29045"></a>
<p><font size=+1><strong>22.2.11   </strong> <code>public void <code><b>writeDouble</b></code>(double v) throws IOException</code></font>
<p>
<a name="29046"></a>
The general contract for <code>writeDouble</code> is that eight bytes are written to the output 
stream to represent the value of the argument. It does this as if it first converts this 
<code>double</code> value to a <code>long</code> in exactly the manner of the <code>Double.doubleToLongBits</code> 
method <a href="javalang.doc9.html#13863">(&#167;20.10.21)</a> and then writes the <code>long</code> value in exactly the manner of the 
<code>writeLong</code> method <a href="javaio.doc.html#29017">(&#167;22.2.9)</a>.
<p><a name="29053"></a>
The bytes written by this method may be read by the <code>readDouble</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28899">(&#167;22.1.13)</a>, which will then return a <code>double</code> equal to <code>v</code>.<p>
<a name="29058"></a>
<p><font size=+1><strong>22.2.12   </strong> <code>public void <code><b>writeBytes</b></code>(String s)<br>throws IOException, NullPointerException</code></font>
<p>
<a name="29059"></a>
The general contract for <code>writeBytes</code> is that for every character in the string <code>s</code>, 
taken in order, one byte is written to the output stream.
<p><a name="29060"></a>
If <code>s</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="29061"></a>
If <code>s.length</code> is zero, then no bytes are written. Otherwise, the character <code>s[0]</code> is written first, then <code>s[1]</code>, and so on; the last character written is <code>s[s.length-1]</code>. For each character, one byte is written, the low-order byte, in exactly the manner of the <code>writeByte</code> method <a href="javaio.doc.html#28981">(&#167;22.2.5)</a>. The high-order eight bits of each character in the string are ignored.<p>
<a name="29066"></a>
<p><font size=+1><strong>22.2.13   </strong> <code>public void <code><b>writeChars</b></code>(String s)<br>throws IOException, NullPointerException</code></font>
<p>
<a name="29067"></a>
The general contract for <code>writeChars</code> is that every character in the string <code>s</code> is written,
in order, to the output stream, two bytes per character.
<p><a name="29068"></a>
If <code>s</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="29069"></a>
If <code>s.length</code> is zero, then no characters are written. Otherwise, the character <code>s[0]</code> is written first, then <code>s[1]</code>, and so on; the last character written is <code>s[s.length-1]</code>. For each character, two bytes are actually written, high-order byte first, in exactly the manner of the <code>writeChar</code> method <a href="javaio.doc.html#28997">(&#167;22.2.7)</a>.<p>
<a name="29074"></a>
<p><font size=+1><strong>22.2.14   </strong> <code>public void <code><b>writeUTF</b></code>(String s)<br>throws IOException, NullPointerException</code></font>
<p>
<a name="29075"></a>
The general contract for <code>writeUTF</code> is that two bytes of length information are 
written to the output stream, followed by the Java modified UTF representation of 
every character in the string <code>s</code>.
<p><a name="29076"></a>
If <code>s</code> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="29077"></a>
Each character in the string <code>s</code> is converted to a group of one, two, or three bytes, depending on the value of the character.<p>
<a name="29078"></a>
If a character <code>c</code> is in the range <code>'\u0001'</code> through <code>'\u007f'</code>, it is represented by one byte:<p>
<pre><a name="29079"></a>(byte)c
</pre><a name="29080"></a>
If a character <code>c</code> is <code>'\u0000'</code> or is in the range <code>'\u0080'</code> through <code>'\u07ff'</code>, then it is represented by two bytes, to be written in the order shown:<p>
<pre><a name="29081"></a>
(byte)(0xc0 | (0x1f &amp; (c &gt;&gt; 6)))
<a name="29082"></a>(byte)(0x80 | (0x3f &amp; c))
</pre><a name="29083"></a>
If a character <code>c</code> is in the range <code>'\u0800'</code> through <code>'\uffff'</code>, then it is represented by three bytes, to be written in the order shown:<p>
<pre><a name="29084"></a>
(byte)(0xc0 | (0x0f &amp; (c &gt;&gt; 12)))
<a name="29085"></a>(byte)(0x80 | (0x3f &amp; (c &gt;&gt; &#32; &#32;6)))
<a name="29086"></a>(byte)(0x80 | (0x3f &amp; c))
</pre><a name="29087"></a>
First, the total number of bytes needed to represent all the characters of <code>s</code> is calculated. If this number is larger than <code>65535</code>, then a <code>UTFDataFormatError</code> is thrown. Otherwise, this length is written to the output stream in exactly the manner &#32;of the <code>writeShort</code> method <a href="javaio.doc.html#28988">(&#167;22.2.6)</a>; after this, the one-, two-, or three-byte representation of each character in the string <code>s</code> is written.<p>
<a name="29091"></a>
The bytes written by this method may be read by the <code>readUTF</code> method of interface <code>DataInput</code> <a href="javaio.doc.html#28916">(&#167;22.1.15)</a>, which will then return a <code>String</code> equal to <code>s</code>.<p>


<hr> 
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="javautil.doc12.html">Prev</a> | <a href="javaio.doc1.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>