<html>
<head>
<title>The Java Language Specification
 Conversions and Promotions</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="4.doc.html">Prev</a> | <a href="6.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="44342"></a>
<p><strong>
CHAPTER
 5 </strong></p>
<a name="27529"></a>
<h1>Conversions and Promotions</h1>
<hr><p>
<a name="25009"></a>
Every Java expression has a type that can be deduced from the structure of the 
expression and the types of the literals, variables, and methods mentioned in the 
expression. It is possible, however, to write an expression in a context where the 
type of the expression is not appropriate. In some cases, this leads to an error at 
compile time; for example, if the expression in an <code>if</code> statement <a href="14.doc.html#5991">(&#167;14.8)</a> has any 
type other than <code>boolean</code>, a compile-time error occurs. In other cases, the context 
may be able to accept a type that is related to the type of the expression; as a convenience,
rather than requiring the programmer to indicate a type conversion 
explicitly, the Java language performs an implicit <i>conversion</i> from the type of the 
expression to a type acceptable for its surrounding context.
<p><a name="25037"></a>
A specific conversion from type <i>S</i> to type <i>T</i> allows an expression of type <i>S</i> to be treated at compile time as if it had type <i>T</i> instead. In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type <i>T</i>. For example:<p>
<ul><a name="25041"></a>
<li>A conversion from type <code>Object</code> <a href="javalang.doc1.html#46442">(&#167;20.1)</a> to type <code>Thread</code> <a href="javalang.doc18.html#2658">(&#167;20.20)</a> requires a run-time check to make sure that the run-time value is actually an instance of class <code>Thread</code> or one of its subclasses; if it is not, an exception is thrown.
<a name="25042"></a>
<li>A conversion from type <code>Thread</code> to type <code>Object</code> requires no run-time action; <code>Thread</code> is a subclass of <code>Object</code>, so any reference produced by an expression of type <code>Thread</code> is a valid reference value of type <code>Object</code>.
<a name="25043"></a>
<li>A conversion from type <code>int</code> to type <code>long</code> requires run-time sign-extension of a 32-bit integer value to the 64-bit <code>long</code> representation. No information is lost.
<a name="25044"></a>
<li>A conversion from type <code>double</code> to type <code>long</code> requires a nontrivial translation from a 64-bit floating-point value to the 64-bit integer representation. Depending on the actual run-time value, information may be lost.
</ul><a name="24996"></a>
In every conversion context, only certain specific conversions are permitted. The specific conversions that are possible in Java are grouped for convenience of description into several broad categories:<p>
<ul><a name="25070"></a>
<li>Identity conversions
<a name="25071"></a>
<li>Widening primitive conversions
<a name="25072"></a>
<li>Narrowing primitive conversions
<a name="25073"></a>
<li>Widening reference conversions
<a name="25086"></a>
<li>Narrowing reference conversions
<a name="25087"></a>
<li>String conversions
</ul><a name="24995"></a>
There are five <i>conversion contexts</i> in which conversion of Java expressions may occur. Each context allows conversions in some of the categories named above but not others. The term "conversion" is also used to describe the process of choosing a specific conversion for such a context. For example, we say that an expression that is an actual argument in a method invocation is subject to "method invocation conversion," meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the method invocation argument context.<p>
<a name="25089"></a>
One conversion context is the operand of a numeric operator such as <code>+</code> or <code>*</code>. The conversion process for such operands is called <i>numeric promotion</i>. Promotion is special in that, in the case of binary operators, the conversion chosen for one operand may depend in part on the type of the other operand expression.<p>
<a name="174138"></a>
This chapter first describes the six categories of conversions <a href="5.doc.html#170671">(&#167;5.1)</a>, including the special conversions to <code>String</code> allowed for the string concatenation operator <code>+</code>. Then the five conversion contexts are described:<p>
<ul><a name="25117"></a>
<li>Assignment conversion (<a href="5.doc.html#170768">&#167;5.2</a>, <a href="15.doc.html#5281">&#167;15.25</a>) converts the type of an expression to the type of a specified variable. The conversions permitted for assignment are limited in such a way that assignment conversion never causes an exception.
<a name="52883"></a>
<li>Method invocation conversion (<a href="5.doc.html#12687">&#167;5.3</a>, <a href="15.doc.html#41147">&#167;15.8</a>, <a href="15.doc.html#20448">&#167;15.11</a>) is applied to each argument in a method or constructor invocation and, except in one case, performs the same conversions that assignment conversion does. Method invocation conversion never causes an exception.
<a name="25151"></a>
<li>Casting conversion <a href="5.doc.html#176921">(&#167;5.4)</a> converts the type of an expression to a type explicitly specified by a cast operator <a href="15.doc.html#238146">(&#167;15.15)</a>. It is more inclusive than assignment or method invocation conversion, allowing any specific conversion other than a string conversion, but certain casts to a reference type may cause an exception at run time.
<a name="25179"></a>
<li>String conversion (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#39990">&#167;15.17.1</a>) allows any type to be converted to type <code>String</code>.
<a name="52885"></a>
<li>Numeric promotion <a href="5.doc.html#26917">(&#167;5.6)</a> brings the operands of a numeric operator to a common type so that an operation can be performed.
</ul><a name="27513"></a>
Here are some examples of the various contexts for conversion:<p>
<pre><a name="27514"></a>
class Test {			
<a name="174326"></a>
	public static void main(String[] args) {
<a name="26212"></a>
		// Casting conversion <a href="5.doc.html#176921">(&#167;5.4)</a> of a float literal to
<a name="26213"></a>		// type int. Without the cast operator, this would
<a name="26214"></a>		// be a compile-time error, because this is a
<a name="26218"></a>		// narrowing conversion <a href="5.doc.html#175672">(&#167;5.1.3)</a>:
<a name="26219"></a>		int i = (int)12.5f;
<br><a name="26266"></a>
		// String conversion <a href="5.doc.html#176921">(&#167;5.4)</a> of i's int value:
<a name="26220"></a>		System.out.println("(int)12.5f==" + i);
<br><a name="26225"></a>
		// Assignment conversion <a href="5.doc.html#170768">(&#167;5.2)</a> of i's value to type
<a name="26229"></a>		// float. This is a widening conversion <a href="5.doc.html#25222">(&#167;5.1.2)</a>:
<a name="26230"></a>		float f = i;
<br><a name="26272"></a>
		// String conversion of f's float value:
<a name="26231"></a>		System.out.println("after float widening: " + f);
<br><a name="26236"></a>
		// Numeric promotion <a href="5.doc.html#26917">(&#167;5.6)</a> of i's value to type
<a name="26237"></a>		// float. This is a binary numeric promotion.
<a name="26238"></a>		// After promotion, the operation is float*float:
<a name="26239"></a>		System.out.print(f);
<a name="26240"></a>		f = f * i;
<br><a name="26284"></a>
		// Two string conversions of i and f:
<a name="26241"></a>		System.out.println("*" + i + "==" + f);
<br><a name="26246"></a>
		// Method invocation conversion <a href="5.doc.html#12687">(&#167;5.3)</a> of f's value
<a name="26247"></a>		// to type double, needed because the method Math.sin
<a name="26248"></a>		// accepts only a double argument:
<a name="26249"></a>		double d = Math.sin(f);
<br><a name="26286"></a>
		// Two string conversions of f and d:
<a name="26250"></a>		System.out.println("Math.sin(" + f + ")==" + d);
<br><a name="26251"></a>	}
<br><a name="26252"></a>}
</pre><a name="26253"></a>
which produces the output:
<p><pre><a name="26254"></a>
(int)12.5f==12
<a name="26255"></a>after float widening: 12.0
<a name="26256"></a>12.0*12==144.0
<a name="26202"></a>Math.sin(144.0)==-0.49102159389846934
</pre><a name="170671"></a>
<h2>5.1    Kinds of Conversion</h2>
<a name="25201"></a>
Specific type conversions in Java are divided into six categories.
<p><a name="25209"></a>
<h3>5.1.1    Identity Conversions</h3>
<a name="25210"></a>
A conversion from a type to that same type is permitted for any type. This may 
seem trivial, but it has two practical consequences. First, it is always permitted for 
an expression to have the desired type to begin with, thus allowing the simply 
stated rule that every expression is subject to conversion, if only a trivial identity 
conversion. Second, it implies that it is permitted for a program to include redundant
cast operators for the sake of clarity.
<p><a name="25214"></a>
The only permitted conversion that involves the type <code>boolean</code> is the identity conversion from <code>boolean</code> to <code>boolean</code>.<p>
<a name="25222"></a>
<h3>5.1.2    Widening Primitive Conversions</h3>
<a name="25224"></a>
The following 19 specific conversions on primitive types are called the <i>widening 
primitive conversions</i>:
<p><ul><a name="25225"></a>
<li><code>byte</code> to <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25226"></a>
<li><code>short</code> to <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25227"></a>
<li><code>char</code> to <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25228"></a>
<li><code>int</code> to <code>long</code>, <code>float</code>, or <code>double</code>
<a name="25229"></a>
<li><code>long</code> to <code>float</code> or <code>double</code>
<a name="25230"></a>
<li><code>float</code> to <code>double</code>
</ul><a name="25231"></a>
Widening primitive conversions do not lose information about the overall magnitude of a numeric value. Indeed, conversions widening from an integral type to another integral type and from <code>float</code> to <code>double</code> do not lose any information at all; the numeric value is preserved exactly. Conversion of an <code>int</code> or a <code>long</code> value to <code>float</code>, or of a <code>long</code> value to <code>double</code>, may result in <i>loss of precision</i>-that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode <a href="4.doc.html#9249">(&#167;4.2.4)</a>.<p>
<a name="25237"></a>
A widening conversion of a signed integer value to an integral type <i>T</i><em></em> simply sign-extends the two's-complement representation of the integer value to fill the wider format. A widening conversion of a character to an integral type <i>T</i> zero-extends the representation of the character value to fill the wider format.<p>
<a name="25238"></a>
Despite the fact that loss of precision may occur, widening conversions among primitive types never result in a run-time exception <a href="11.doc.html#44043">(&#167;11)</a>.<p>
<a name="25242"></a>
Here is an example of a widening conversion that loses precision:<p>
<pre><a name="25243"></a>
class Test {
<a name="25244"></a>	public static void main(String[] args) {
<a name="25245"></a>		int big = 1234567890;
<a name="25246"></a>		float approx = big;
<a name="25247"></a>		System.out.println(big - (int)approx);
<a name="25248"></a>	}
<a name="25249"></a>}
</pre><a name="25250"></a>
which prints:
<p><pre><a name="25251"></a>-46
</pre><a name="175670"></a>
thus indicating that information was lost during the conversion from type <code>int</code> to 
type <code>float</code> because values of type <code>float</code> are not precise to nine significant digits.
<p><a name="175672"></a>
<h3>5.1.3    Narrowing Primitive Conversions</h3>
<a name="25363"></a>
The following 23 specific conversions on primitive types are called the <i>narrowing</i> 
<i>primitive conversions</i>:
<p><ul><a name="25257"></a>
<li><code>byte</code> to <code>char</code>
<a name="25258"></a>
<li><code>short</code> to <code>byte</code> or <code>char</code>
<a name="25259"></a>
<li><code>char</code> to <code>byte</code> or <code>short</code>
<a name="25260"></a>
<li><code>int</code> to <code>byte</code>, <code>short</code>, or <code>char</code>
<a name="25261"></a>
<li><code>long</code> to <code>byte</code>, <code>short</code>, <code>char</code>, or <code>int</code>
<a name="25262"></a>
<li><code>float</code> to <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, or <code>long</code>
<a name="25263"></a>
<li><code>double</code> to <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, or <code>float</code>
</ul><a name="25264"></a>
Narrowing conversions may lose information about the overall magnitude of a numeric value and may also lose precision.<p>
<a name="25265"></a>
A narrowing conversion of a signed integer to an integral type <i>T</i> simply discards all but the <i>n </i>lowest order bits, where <i>n </i>is the number of bits used to represent type <i>T</i>. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value.<p>
<a name="25266"></a>
A narrowing conversion of a character to an integral type <i>T</i> likewise simply discards all but the <i>n </i>lowest order bits, where <i>n </i>is the number of bits used to represent type <i>T</i>. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the resulting value to be a negative number, even though characters represent 16-bit unsigned integer values.<p>
<a name="25267"></a>
A narrowing conversion of a floating-point number to an integral type <i>T</i><em></em> takes two steps:<p>
<ol>
<a name="25268"></a>
<li>In the first step, the floating-point number is converted either to a <code>long</code>, if <i>T</i> is <code>long</code>, or to an <code>int</code>, if <i>T</i><em></em> is <code>byte</code>, <code>short</code>, <code>char</code>, or <code>int</code>, as follows:
<ul>
<a name="25272"></a>
<li>If the floating-point number is NaN <a href="4.doc.html#9208">(&#167;4.2.3)</a>, the result of the first step of the conversion is an <code>int</code> or <code>long</code> <code>0</code>.
<a name="174285"></a>
<li>Otherwise, if the floating-point number is not an infinity, the floating-point value is rounded to an integer value <i>V</i>, rounding toward zero using IEEE 754 round-toward-zero mode <a href="4.doc.html#9208">(&#167;4.2.3)</a>. Then there are two cases:
<ul>
<a name="25277"></a>
<li>If <i>T</i><em></em> is <code>long</code>, and this integer value can be represented as a <code>long</code>, then the result of the first step is the <code>long</code> value <i>V</i>.
<a name="25278"></a>
<li>Otherwise, if this integer value can be represented as an <code>int</code>, then the result of the first step is the <code>int</code> value <i>V</i>.
</ul>
<a name="25279"></a>
<li>Otherwise, one of the following two cases must be true:
<ul>
<a name="25280"></a>
<li>The value must be too small (a negative value of large magnitude or negative infinity), and the result of the first step is the smallest representable value of type <code>int</code> or <code>long</code>.
<a name="25281"></a>
<li>The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type <code>int</code> or <code>long</code>.
</ul>
</ul>
<a name="25282"></a>
<li>In the second step:
<ul>
<a name="25283"></a>
<li>If <i>T</i> is <code>int</code> or <code>long</code>, the result of the conversion is the result of the first step.
<a name="25284"></a>
<li>If <i>T</i> is <code>byte</code>, <code>char</code>, or <code>short</code>, the result of the conversion is the result of a narrowing conversion to type <i>T</i> <a href="5.doc.html#175672">(&#167;5.1.3)</a> of the result of the first step.
</ul>
</ol>
<a name="176319"></a>
The example:
<p><pre><a name="176320"></a>
class Test {
<a name="25290"></a>	public static void main(String[] args) {
<a name="25291"></a>		float fmin = Float.NEGATIVE_INFINITY;
<a name="25292"></a>		float fmax = Float.POSITIVE_INFINITY;
<a name="25293"></a>		System.out.println("long: " + (long)fmin +
<a name="25294"></a>								".." + (long)fmax);
<a name="25295"></a>		System.out.println("int: " + (int)fmin +
<a name="25296"></a>								".." + (int)fmax);
<a name="25297"></a>		System.out.println("short: " + (short)fmin +
<a name="25298"></a>								".." + (short)fmax);
<a name="25299"></a>		System.out.println("char: " + (int)(char)fmin +
<a name="25300"></a>								".." + (int)(char)fmax);
<a name="25301"></a>		System.out.println("byte: " + (byte)fmin +
<a name="25302"></a>								".." + (byte)fmax);
<a name="25303"></a>	}
<a name="25304"></a>}
</pre><a name="25305"></a>
produces the output:
<p><pre><a name="25306"></a>
long: -9223372036854775808..9223372036854775807
<a name="25307"></a>int: -2147483648..2147483647
<a name="25308"></a>short: 0..-1
<a name="25309"></a>char: 0..65535
<a name="25310"></a>byte: 0..-1
</pre><a name="25311"></a>
The results for <code>char</code>, <code>int</code>, and <code>long</code> are unsurprising, producing the minimum and maximum representable values of the type.<p>
<a name="25312"></a>
The results for <code>byte</code> and <code>short</code> lose information about the sign and magnitude of the numeric values and also lose precision. The results can be understood by examining the low order bits of the minimum and maximum <code>int.</code> The minimum <code>int</code> is, in hexadecimal, <code>0x80000000</code>, and the maximum <code>int</code> is <code>0x7fffffff</code>. This explains the <code>short</code> results, which are the low 16 bits of these values, namely, <code>0x0000</code> and <code>0xffff</code>; it explains the <code>char</code> results, which also are the low 16 bits of these values, namely, <code>'\u0000'</code> and <code>'\uffff'</code>; and it explains the <code>byte</code> results, which are the low 8 bits of these values, namely, <code>0x00</code> and <code>0xff</code>.<p>
<a name="25315"></a>
A narrowing conversion from <code>double</code> to <code>float</code> behaves in accordance with IEEE 754. The result is correctly rounded using IEEE 754 round-to-nearest mode. A value too small to be represented as a <code>float</code> is converted to positive or negative zero; a value too large to be represented as a <code>float</code> is converted to a (positive or negative) infinity. A <code>double</code> NaN is always converted to a <code>float</code> NaN.<p>
<a name="25316"></a>
Despite the fact that overflow, underflow, or other loss of information may occur, narrowing conversions among primitive types never result in a run-time exception <a href="11.doc.html#44043">(&#167;11)</a>.<p>
<a name="25321"></a>
Here is a small test program that demonstrates a number of narrowing conversions that lose information:<p>
<pre><a name="25322"></a>
class Test {
<a name="25323"></a>
	public static void main(String[] args) {
<a name="25324"></a>
		// A narrowing of int to short loses high bits:
<a name="25325"></a>		System.out.println("(short)0x12345678==0x" +
<a name="25326"></a>					Integer.toHexString((short)0x12345678));
<br><a name="25328"></a>
		// A int value not fitting in byte changes sign and magnitude:
<a name="25329"></a>		System.out.println("(byte)255==" + (byte)255);
<br><a name="25331"></a>
		// A float value too big to fit gives largest int value:
<a name="25332"></a>		System.out.println("(int)1e20f==" + (int)1e20f);
<br><a name="25334"></a>
		// A NaN converted to int yields zero:
<a name="25335"></a>		System.out.println("(int)NaN==" + (int)Float.NaN);
<br><a name="25337"></a>
		// A double value too large for float yields infinity:
<a name="25338"></a>		System.out.println("(float)-1e100==" + (float)-1e100);
<br><a name="25340"></a>
		// A double value too small for float underflows to zero:
<a name="25341"></a>		System.out.println("(float)1e-50==" + (float)1e-50);
<br><a name="25342"></a>	}
<br><a name="25346"></a>}
</pre><a name="25347"></a>
This test program produces the following output:
<p><pre><a name="25348"></a>
(short)0x12345678==0x5678
<a name="25349"></a>(byte)255==-1
<a name="25350"></a>(int)1e20f==2147483647
<a name="25351"></a>(int)NaN==0
<a name="25352"></a>(float)-1e100==-Infinity
<a name="25353"></a>(float)1e-50==0.0
</pre><a name="25215"></a>
<h3>5.1.4    Widening Reference Conversions</h3>
<a name="25460"></a>
The following conversions are called the <i>widening reference conversions</i>:
<p><ul><a name="25482"></a>
<li>From any class type <i>S</i> to any class type <i>T</i>, provided that <i>S</i> is a subclass of <i>T</i>. (An important special case is that there is a widening conversion to the class type <code>Object</code> from any other class type.)
<a name="25484"></a>
<li>From any class type <i>S</i> to any interface type <i>K</i>, provided that <i>S</i> implements <i>K</i>.
<a name="25483"></a>
<li>From the null type to any class type, interface type, or array type.
<a name="25502"></a>
<li>From any interface type <i>J</i> to any interface type <i>K</i>, provided that <i>J</i> is a subinterface of <i>K</i>.
<a name="25500"></a>
<li>From any interface type to type <code>Object</code>.
<a name="174846"></a>
<li>From any array type to type <code>Object</code>.
<a name="174848"></a>
<li>From any array type to type <code>Cloneable</code>.
<a name="25525"></a>
<li>From any array type <i>SC</i><code>[]</code> to any array type <i>TC</i><code>[]</code>, provided that <i>SC</i> and <i>TC</i> are reference types and there is a widening conversion from <i>SC</i> to <i>TC</i>.
</ul><a name="25616"></a>
Such conversions never require a special action at run time and therefore never 
throw an exception at run time. They consist simply in regarding a reference as 
having some other type in a manner that can be proved correct at compile time.
<p><a name="25457"></a>
See <a href="8.doc.html#3857">&#167;8</a> for the detailed specifications for classes, <a href="9.doc.html#238678">&#167;9</a> for interfaces, and <a href="10.doc.html#27803">&#167;10</a> for arrays.<p>
<a name="25379"></a>
<h3>5.1.5    Narrowing Reference Conversions</h3>
<a name="175454"></a>
The following conversions are called the <i>narrowing reference conversions</i>:
<p><ul><a name="175455"></a>
<li>From any class type <i>S</i> to any class type <i>T</i>, provided that <i>S</i> is a superclass of <i>T</i>. (An important special case is that there is a narrowing conversion from the class type <code>Object</code> to any other class type.)
<a name="25705"></a>
<li>From any class type <i>S</i> to any interface type <i>K</i>, provided that <i>S</i> is not final and does not implement <i>K.</i> (An important special case is that there is a narrowing conversion from the class type <code>Object</code> to any interface type.)
<a name="25766"></a>
<li>From type <code>Object</code> to any array type.
<a name="175692"></a>
<li>From type <code>Object</code> to any interface type.
<a name="25783"></a>
<li>From any interface type <i>J</i> to any class type <i>T</i> that is not <code>final</code>.
<a name="25787"></a>
<li>From any interface type <i>J</i> to any class type <i>T</i> that is <code>final</code>, provided that <i>T</i> implements <i>J</i>.
<a name="25774"></a>
<li>From any interface type <i>J</i> to any interface type <i>K</i>, provided that <i>J</i> is not a subinterface of <i>K</i> and there is no method name <i>m</i> such that <i>J</i> and <i>K</i> both declare a method named <i>m</i> with the same signature but different return types.
<a name="25710"></a>
<li>From any array type <i>SC</i><code>[]</code> to any array type <i>TC</i><code>[]</code>, provided that <i>SC</i> and <i>TC</i> are reference types and there is a narrowing conversion from <i>SC</i> to <i>TC</i>.
</ul><a name="176885"></a>
Such conversions require a test at run time to find out whether the actual reference 
value is a legitimate value of the new type. If not, then a <code>ClassCastException</code> is 
thrown.
<p><a name="176886"></a>
<h3>5.1.6    String Conversions</h3>
<a name="175033"></a>
There is a string conversion to type <code>String</code> from every other type, including the 
null type.
<p><a name="175034"></a>
<h3>5.1.7    Forbidden Conversions</h3>
<ul><a name="175035"></a>
<li>There is no permitted conversion from any reference type to any primitive type.
<a name="25844"></a>
<li>Except for the string conversions, there is no permitted conversion from any primitive type to any reference type.
<a name="25860"></a>
<li>There is no permitted conversion from the null type to any primitive type.
<a name="25835"></a>
<li>There is no permitted conversion to the null type other than the identity conversion.
<a name="25993"></a>
<li>There is no permitted conversion to the type <code>boolean</code> other than the identity conversion.
<a name="25997"></a>
<li>There is no permitted conversion from the type <code>boolean</code> other than the identity conversion and string conversion.
<a name="25357"></a>
<li>There is no permitted conversion other than string conversion from class type <i>S</i> to a different class type <i>T</i> if <i>S</i> is not a subclass of <i>T</i> and <i>T</i> is not a subclass of <i>S</i>.
<a name="25885"></a>
<li>There is no permitted conversion from class type <i>S</i> to interface type <i>K</i> if <i>S</i> is <code>final</code> and does not implement <i>K</i>.
<a name="25899"></a>
<li>There is no permitted conversion from class type <i>S</i> to any array type if <i>S</i> is not <code>Object</code>.
<a name="25902"></a>
<li>There is no permitted conversion other than string conversion from interface type <i>J</i> to class type <i>T</i> if <i>T</i> is <code>final</code> and does not implement <i>J</i>.
<a name="25924"></a>
<li>There is no permitted conversion from interface type <i>J</i> to interface type <i>K</i> if <i>J</i> and <i>K</i> declare methods with the same signature but different return types.
<a name="25954"></a>
<li>There is no permitted conversion from any array type to any class type other than <code>Object</code> or <code>String</code>.
<a name="25958"></a>
<li>There is no permitted conversion from any array type to any interface type, except to the interface type <code>Cloneable</code>, which is implemented by all arrays.
<a name="25966"></a>
<li>There is no permitted conversion from array type <i>SC</i><code>[]</code> to array type <i>TC</i><code>[]</code> if there is no permitted conversion other than a string conversion from <i>SC</i> to <i>TC.</i>
</ul><a name="170768"></a>
<h2>5.2    Assignment Conversion</h2>
<a name="170769"></a>
<i>Assignment conversion</i> occurs when the value of an expression is assigned 
<a href="15.doc.html#5281">(&#167;15.25)</a> to a variable: the type of the expression must be converted to the type of 
the variable. Assignment contexts allow the use of an identity conversion <a href="5.doc.html#25209">(&#167;5.1.1)</a>, 
a widening primitive conversion <a href="5.doc.html#25222">(&#167;5.1.2)</a>, or a widening reference conversion 
<a href="5.doc.html#25215">(&#167;5.1.4)</a>. In addition, a narrowing primitive conversion may be used if all of the 
following conditions are satisfied:
<p><ul><a name="26335"></a>
<li>The expression is a constant expression of type <code>int</code>.
<a name="26336"></a>
<li>The type of the variable is <code>byte</code>, <code>short</code>, or <code>char</code>.
<a name="26337"></a>
<li>The value of the expression (which is known at compile time, because it is a constant expression) is representable in the type of the variable.
</ul><a name="26341"></a>
If the type of the expression cannot be converted to the type of the variable by a 
conversion permitted in an assignment context, then a compile-time error occurs.
<p><a name="22422"></a>
If the type of an expression can be converted to the type a variable by assignment conversion, we say the expression (or its value) is <i>assignable to</i> the variable or, equivalently, that the type of the expression is <i>assignment compatible with</i> the type of the variable.<p>
<a name="11334"></a>
An assignment conversion never causes an exception. (Note, however, that an assignment may result in an exception in a special case involving array elements -see <a href="10.doc.html#11430">&#167;10.10</a> and <a href="15.doc.html#5295">&#167;15.25.1</a>.)<p>
<a name="28552"></a>
The compile-time narrowing of constants means that code such as:<p>
<pre><a name="12645"></a>byte theAnswer = 42;
</pre><a name="170786"></a>
is allowed. Without the narrowing, the fact that the integer literal <code>42</code> has type <code>int</code> 
would mean that a cast to <code>byte</code> would be required:
<p><pre><a name="26372"></a>byte theAnswer = (byte)42;									// cast is permitted but not required
</pre><a name="12681"></a>
A value of primitive type must not be assigned to a variable of reference type; an attempt to do so will result in a compile-time error. A value of type <code>boolean</code> can be assigned only to a variable of type <code>boolean</code>.<p>
<a name="12674"></a>
The following test program contains examples of assignment conversion of primitive values:<p>
<pre><a name="12675"></a>
class Test {
<a name="12977"></a>	public static void main(String[] args) {
<a name="12978"></a>		short s = 12;							// narrow 12 to short
<a name="12979"></a>		float f = s;							// widen short to float
<a name="12983"></a>		System.out.println("f=" + f);
<a name="12980"></a>
		char c = '\u0123';
<a name="12981"></a>		long l = c;							// widen char to long
<a name="12984"></a>		System.out.println("l=0x" + Long.toString(l,16));
<a name="12985"></a>
		f = 1.23f;
<a name="12986"></a>		double d = f;							// widen float to double
<a name="12996"></a>		System.out.println("d=" + d);
<a name="12987"></a>	}
<a name="12988"></a>}
</pre><a name="13013"></a>
It produces the following output:
<p><pre><a name="13020"></a>
f=12.0	
<a name="13021"></a>i=0x123
<a name="13022"></a>d=1.2300000190734863
</pre><a name="13041"></a>
The following test, however, produces compile-time errors:
<p><pre><a name="13042"></a>
class Test {
<a name="13043"></a>	public static void main(String[] args) {
<a name="13044"></a>		short s = 123;
<a name="27506"></a>		char c = s;							// error: would require cast
<a name="27507"></a>		s = c;							// error: would require cast
<a name="27508"></a>	}
<a name="13048"></a>}
</pre><a name="13049"></a>
because not all <code>short</code> values are <code>char</code> values, and neither are all <code>char</code> values 
<code>short</code> values.
<p><a name="26408"></a>
A value of reference type must not be assigned to a variable of primitive type; an attempt to do so will result in a compile-time error. <p>
<a name="26412"></a>
A value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type.<p>
<a name="26417"></a>
Here is a sample program illustrating assignments of references:<p>
<pre><a name="24498"></a>
public class Point { int x, y; }
<br><a name="24499"></a>public class Point3D extends Point { int z; }
<br><a name="24500"></a>
public interface Colorable {
<a name="24501"></a>	void setColor(int color);
<a name="24502"></a>}
<br><a name="24503"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="24504"></a>	int color;
<a name="24506"></a>	public void setColor(int color) { this.color = color; }
<a name="24507"></a>}
<br><a name="176339"></a>

<a name="176343"></a>
<a name="176346"></a>
<a name="176347"></a>
<a name="176348"></a>
<a name="176349"></a>class Test {
<a name="24509"></a>
	public static void main(String[] args) {
<a name="176333"></a>
		// Assignments to variables of class type:
<a name="24511"></a>		Point p = new Point();
<a name="24513"></a>		p = new Point3D();							// ok: because Point3d is a
<a name="24514"></a>									// subclass of Point
<a name="24515"></a>		
<a name="24516"></a>		Point3D p3d = p;							// error: will require a cast because a 
<a name="24517"></a>									// Point might not be a Point3D
<a name="24518"></a>									// (even though it is, dynamically,
<a name="175517"></a>									// in this example.)
<a name="175518"></a>
		// Assignments to variables of type Object:
<a name="175519"></a>		Object o = p;							// ok: any object to Object
<a name="24524"></a>		int[] a = new int[3];
<a name="24525"></a>		Object o2 = a;							// ok: an array to Object
<br><a name="24527"></a>
		// Assignments to variables of interface type:
<a name="24528"></a>		ColoredPoint cp = new ColoredPoint();
<a name="24529"></a>		Colorable c = cp;							// ok: ColoredPoint implements
<a name="24530"></a>									// Colorable
<br><a name="24532"></a>
		// Assignments to variables of array type:
<a name="24533"></a>		byte[] b = new byte[4];
<a name="24534"></a>		a = b;							// error: these are not arrays
<a name="24535"></a>									// of the same primitive type
<a name="24536"></a>		Point3D[] p3da = new Point3D[3];
<a name="24537"></a>		Point[] pa = p3da;							// ok: since we can assign a
<a name="24538"></a>									// Point3D to a Point
<a name="24539"></a>		p3da = pa;							// error: (cast needed) since a Point
<a name="24540"></a>									// can't be assigned to a Point3D
<br><a name="24542"></a>	}
<br><a name="24543"></a>}
</pre><a name="25628"></a>
Assignment of a value of compile-time reference type <i>S</i><i></i> (source) to a variable of compile-time reference type <i>T</i><em></em> (target) is checked as follows:<p>
<ul><a name="25632"></a>
<li>If <i>S</i><i></i> is a class type:
<ul>
<a name="25636"></a>
<li>If <i>T</i> is a class type, then <i>S</i><i></i> must either be the same class as <i>T</i>, or <i>S</i><i></i> must be a subclass of <i>T</i>, or a compile-time error occurs.
<a name="25643"></a>
<li>If <i>T</i> is an interface type, then <i>S</i><i></i> must implement interface <i>T</i>, or a compile-time error occurs.
<a name="25644"></a>
<li>If <i>T</i> is an array type, then a compile-time error occurs.
</ul>
</ul><ul><a name="176327"></a>
<li>If <i>S</i><i></i> is an interface type:
<ul>
<a name="25655"></a>
<li>If <i>T</i> is a class type, then <i>T</i> must be <code>Object</code>, or a compile-time error occurs.
<a name="25659"></a>
<li>If <i>T</i> is an interface type, then <i>T</i> must be either the same interface as <i>S</i> or a superinterface of <i>S</i>,<i></i> or a compile-time error occurs.
<a name="25663"></a>
<li>If <i>T</i> is an array type, then a compile-time error occurs.
</ul>
<a name="25667"></a>
<li>If <i>S</i> is an array type <i>SC</i><code>[]</code>, that is, an array of components of type <i>SC</i><em></em>:
<ul>
<a name="25677"></a>
<li>If <i>T</i> is a class type, then <i>T</i> must be <code>Object</code>, or a compile-time error occurs.
<a name="25678"></a>
<li>If <i>T</i> is an interface type, then a compile-time error occurs unless <i>T</i> is the interface type <code>Cloneable</code>, the only interface implemented by arrays.
<a name="25679"></a>
<li>If <i>T</i> is an array type <i>TC</i><code>[]</code>, that is, an array of components of type <i>TC</i><em>,</em> then a compile-time error occurs unless one of the following is true:
<ul>
<a name="25683"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are the same primitive type.
<a name="25684"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are both reference types and type <i>SC</i><em></em> is assignable to <i>TC</i><em>,</em> as determined by a recursive application of these compile-time rules for assignability.
</ul>
</ul>
</ul><a name="25695"></a>
See <a href="8.doc.html#3857">&#167;8</a> for the detailed specifications of classes, <a href="9.doc.html#238678">&#167;9</a> for interfaces, and <a href="10.doc.html#27803">&#167;10</a> for 
arrays.
<p><a name="56972"></a>
The following test program illustrates assignment conversions on reference values, but fails to compile because it violates the preceding rules, as described in its comments. This example should be compared to the preceding one.<p>
<pre><a name="29474"></a>
public class Point { int x, y; }
<br><a name="29475"></a>public interface Colorable { void setColor(int color); }
<br><a name="29476"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="29477"></a>	int color;
<a name="29479"></a>	public void setColor(int color) { this.color = color; }
<a name="29480"></a>}
<br><a name="12566"></a>
class Test {
<a name="12567"></a>
	public static void main(String[] args) {
<br><a name="12568"></a>		Point p = new Point();
<br><a name="12569"></a>		ColoredPoint cp = new ColoredPoint();
<a name="17235"></a>
		// Okay because ColoredPoint is a subclass of Point:
<a name="17230"></a>		p = cp;
<br><a name="29503"></a>
		// Okay because ColoredPoint implements Colorable:
<a name="29502"></a>		Colorable c = cp;
<br><a name="12576"></a>
		// The following cause compile-time errors because
<a name="12577"></a>		// we cannot be sure they will succeed, depending on
<a name="17240"></a>		// the run-time type of p; a run-time check will be
<a name="17245"></a>		// necessary for the needed narrowing conversion and
<a name="12579"></a>		// must be indicated by including a cast:
<a name="12580"></a>		cp = p;				// p might be neither a ColoredPoint
<a name="29523"></a>						// nor a subclass of ColoredPoint
<a name="12581"></a>		c = p;				// p might not implement Colorable
<br><a name="12593"></a>	}
<br><a name="12594"></a>}
</pre><a name="29746"></a>
Here is another example involving assignment of array objects:
<p><pre><a name="29747"></a>
class Point { int x, y; }
<br><a name="29748"></a>class ColoredPoint extends Point { int color; }
<br><a name="29749"></a>
class Test {
<a name="29750"></a>	public static void main(String[] args) {
<a name="29751"></a>		long[] veclong = new long[100];
<a name="29752"></a>		Object o = veclong;									// okay
<a name="29753"></a>		Long l = veclong;									// compile-time error
<a name="29754"></a>		short[] vecshort = veclong;									// compile-time error
<a name="29755"></a>		Point[] pvec = new Point[100];
<a name="29756"></a>		ColoredPoint[] cpvec = new ColoredPoint[100];
<a name="29757"></a>		pvec = cpvec;									// okay
<a name="50093"></a>		pvec[0] = new Point();									// okay at compile time,
<a name="174449"></a>											// but would throw an
<a name="174450"></a>											// exception at run time
<a name="29758"></a>		cpvec = pvec;									// compile-time error
<a name="29759"></a>	}
<a name="29760"></a>}
</pre><a name="29761"></a>
In this example:
<p><ul><a name="12615"></a>
<li>The value of <code>veclong</code> cannot be assigned to a <code>Long</code> variable, because <code>Long</code> is a class type <a href="javalang.doc7.html#46750">(&#167;20.8)</a> other than <code>Object</code>. An array can be assigned only to a variable of a compatible array type, or to a variable of type <code>Object</code>.
<a name="12616"></a>
<li>The value of <code>veclong</code> cannot be assigned to <code>vecshort</code>, because they are arrays of primitive type, and <code>short</code> and <code>long</code> are not the same primitive type.
<a name="12617"></a>
<li>The value of <code>cpvec</code> can be assigned to <code>pvec</code>,<code></code> because any reference that could be the value of an expression of type <code>ColoredPoint</code> can be the value of a variable of type <code>Point</code>. The subsequent assignment of the new <code>Point</code> to a component of <code>pvec</code> then would throw an <code>ArrayStoreException</code> (if the program were otherwise corrected so that it could be compiled), because a <code>ColoredPoint</code> &#32;array can't have an instance of <code>Point</code> as the value of a component.
<a name="29743"></a>
<li>The value of <code>pvec</code> cannot be assigned to <code>cpvec</code>,<code></code> because not every reference that could be the value of an expression of type <code>ColoredPoint</code> can correctly be the value of a variable of type <code>Point</code>. If the value of <code>pvec</code> at run time were a reference to an instance of <code>Point[]</code>, and the assignment to <code>cpvec</code> were allowed, a simple reference to a component of <code>cpvec</code>, say, <code>cpvec[0]</code>, could return a <code>Point</code>, and a <code>Point</code> is not a <code>ColoredPoint</code>. Thus to allow such an assignment would allow a violation of the type system. A cast may be used (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>) to ensure that <code>pvec</code> references a <code>ColoredPoint[]</code>:
</ul><pre><a name="174507"></a>
		cpvec = (ColoredPoint[])pvec;										// okay, but may throw an
<a name="174508"></a>												// exception at run time
</pre><a name="12687"></a>
<h2>5.3    Method Invocation Conversion</h2>
<a name="53171"></a>
<i>Method invocation conversion</i> is applied to each argument value in a method or 
constructor invocation (<a href="15.doc.html#41147">&#167;15.8</a>, <a href="15.doc.html#20448">&#167;15.11</a>): the type of the argument expression must 
be converted to the type of the corresponding parameter. Method invocation contexts
allow the use of an identity conversion <a href="5.doc.html#25209">(&#167;5.1.1)</a>, a widening primitive conversion
<a href="5.doc.html#25222">(&#167;5.1.2)</a>, or a widening reference conversion <a href="5.doc.html#25215">(&#167;5.1.4)</a>.
<p><a name="26526"></a>
Method invocation conversions specifically do not include the implicit narrowing of integer constants which is part of assignment conversion <a href="5.doc.html#170768">(&#167;5.2)</a>. The Java designers felt that including these implicit narrowing conversions would add additional complexity to the overloaded method matching resolution process <a href="15.doc.html#21693">(&#167;15.11.2)</a>. Thus, the example:<p>
<pre><a name="12738"></a>
class Test {
<br><a name="13070"></a>	static int m(byte a, int b) { return a+b; }
<br><br><a name="20310"></a>	static int m(short a, short b) { return a-b; }
<br><a name="13071"></a>	public static void main(String[] args) {
<a name="13072"></a>		System.out.println(m(12, 2));										// compile-time error
<a name="20350"></a>	}
<br><a name="13077"></a>}
</pre><a name="20230"></a>
causes a compile-time error because the integer literals <code>12</code> and <code>2</code> have type <code>int</code>, so 
neither method <code>m</code> matches under the rules of <a href="15.doc.html#21693">(&#167;15.11.2)</a>. A language that included 
implicit narrowing of integer constants would need additional rules to resolve 
cases like this example.
<p><a name="176921"></a>
<h2>5.4    String Conversion</h2>
<a name="176922"></a>
String conversion applies only to the operands of the binary <code>+</code> operator when one 
of the arguments is a <code>String</code>. In this single special case, the other argument to the 
<code>+</code> is converted to a <code>String</code>, and a new <code>String</code> which is the concatenation of the 
two strings is the result of the <code>+</code>. String conversion is specified in detail within the 
description of the string concatenation <code>+</code> operator <a href="15.doc.html#39990">(&#167;15.17.1)</a>.
<p><a name="20232"></a>
<h2>5.5    Casting Conversion</h2>
<a name="20233"></a>
<i>Casting conversion</i> is applied to the operand of a cast operator <a href="15.doc.html#238146">(&#167;15.15)</a>: the type 
of the operand expression must be converted to the type explicitly named by the 
cast operator. Casting contexts allow the use of an identity conversion <a href="5.doc.html#25209">(&#167;5.1.1)</a>, a 
widening primitive conversion <a href="5.doc.html#25222">(&#167;5.1.2)</a>, a narrowing primitive conversion 
<a href="5.doc.html#175672">(&#167;5.1.3)</a>, a widening reference conversion <a href="5.doc.html#25215">(&#167;5.1.4)</a>, or a narrowing reference conversion
<a href="5.doc.html#25379">(&#167;5.1.5)</a>. Thus casting conversions are more inclusive than assignment or 
method invocation conversions: a cast can do any permitted conversion other than 
a string conversion.
<p><a name="175729"></a>
Some casts can be proven incorrect at compile time; such casts result in a compile-time error.<p>
<a name="175719"></a>
A value of a primitive type can be cast to another primitive type by identity conversion, if the types are the same, or by a widening primitive conversion or a narrowing primitive conversion.<p>
<a name="175724"></a>
A value of a primitive type cannot be cast to a reference type by casting conversion, nor can a value of a reference type be cast to a primitive type.<p>
<a name="175725"></a>
The remaining cases involve conversion between reference types. The detailed rules for compile-time correctness checking of a casting conversion of a value of compile-time reference type <i>S</i><i></i> (source) to a compile-time reference type <i>T</i><em></em> (target) are as follows:<p>
<ul><a name="27459"></a>
<li>If <i>S</i><i></i> is a class type:
<ul>
<a name="27460"></a>
<li>If <i>T</i><em></em> is a class type, then <i>S</i><i></i> and <i>T</i><em></em> must be related classes-that is, <i>S</i><em></em> and <i>T</i><em></em> must be the same class, or <i>S</i><i></i> a subclass of <i>T</i><em>,</em> or <i>T</i><em></em> a subclass of <i>S</i><em></em>; otherwise a compile-time error occurs.
<a name="27461"></a>
<li>If <i>T</i><em></em> is an interface type:
<ul>
<a name="26664"></a>
<li>If <i>S</i><i></i> is not a <code>final</code> class <a href="8.doc.html#21613">(&#167;8.1.2)</a>, then the cast is always correct at compile time (because even if <i>S</i><i></i> does not implement <i>T</i>, a subclass of <i>S</i><i></i> might).
<a name="26668"></a>
<li>If <i>S</i><i></i> is a <code>final</code> class <a href="8.doc.html#21613">(&#167;8.1.2)</a>, then <i>S</i><i></i> must implement <i>T</i>,<em></em> or a compile-time error occurs.
</ul>
<a name="27505"></a>
<li>If <i>T</i><em></em> is an array type, then <i>S</i><i></i> must be the class <code>Object</code>, or a compile-time error occurs.
</ul>
<a name="27506"></a>
<li>If <i>S</i><i></i> is an interface type:
<ul>
<a name="27507"></a>
<li>If <i>T</i><em></em> is a class type that is not <code>final</code> <a href="8.doc.html#21613">(&#167;8.1.2)</a>, then the cast is always correct at compile time (because even if <i>T</i><em></em> does not implement <i>S</i>, a subclass of <i>T</i><em></em> might).
<a name="27508"></a>
<li>If <i>T</i><em></em> is a class type that is <code>final</code> <a href="8.doc.html#21613">(&#167;8.1.2)</a>, then <i>T</i><em></em> must implement <i>S</i>,<i></i> or a compile-time error occurs.
<a name="45656"></a>
<li>If <i>T</i><em></em> is an interface type and if <i>T</i><em></em> and <i>S</i><i></i> contain methods with the same signature <a href="8.doc.html#38649">(&#167;8.4.2)</a> but different return types, then a compile-time error occurs.
</ul>
<a name="53974"></a>
<li>If <i>S</i><em></em> is an array type <i>SC</i><code>[]</code>, that is, an array of components of type <i>SC</i><em></em>:
<ul>
<a name="53981"></a>
<li>If <i>T</i><em></em> is a class type, then if <i>T</i><em></em> is not <code>Object</code>, then a compile-time error occurs (because <code>Object</code> is the only class type to which arrays can be assigned).
<a name="28948"></a>
<li>If <i>T</i><em></em> is an interface type, then a compile-time error occurs unless <i>T</i> is the interface type <code>Cloneable</code>, the only interface implemented by arrays.
<a name="28949"></a>
<li>If <i>T</i><em></em> is an array type <i>TC</i><code>[]</code>, that is, an array of components of type <i>TC</i>, then a compile-time error occurs unless one of the following is true:
<ul>
<a name="176094"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are the same primitive type.
<a name="176095"></a>
<li><i>TC</i><em></em> and <i>SC</i><em></em> are reference types and type <i>SC</i><em></em> can be cast to <i>TC</i><em></em> by a recursive application of these compile-time rules for casting.
</ul>
</ul>
</ul><a name="174613"></a>
See <a href="8.doc.html#3857">&#167;8</a> for the detailed specifications of classes, <a href="9.doc.html#238678">&#167;9</a> for interfaces, and <a href="10.doc.html#27803">&#167;10</a> for 
arrays.
<p><a name="27456"></a>
If a cast to a reference type is not a compile-time error, there are two cases:<p>
<ul><a name="26702"></a>
<li>The cast can be determined to be correct at compile time. A cast from the compile-time type <i>S</i><i></i> to compile-time type <i>T</i><em></em> is correct at compile time if and only if <i>S</i><i></i> can be converted to <i>T</i><em></em> by assignment conversion <a href="5.doc.html#170768">(&#167;5.2)</a>.
<a name="26706"></a>
<li>The cast requires a run-time validity check. If the value at run time is <code>null</code>, then the cast is allowed. Otherwise, let <i>R</i> be the class of the object referred to by the run-time reference value, and let <i>T</i><em></em> be the type named in the cast operator. A cast conversion must check, at run time, that the class <i>R</i> is assignment compatible with the type <i>T</i>, using the algorithm specified in <a href="5.doc.html#170768">&#167;5.2</a> but using the class <i>R</i> instead of the compile-time type <i>S</i><em></em> as specified there. (Note that <i>R</i> cannot be an interface when these rules are first applied for any given cast, but <i>R</i> may be an interface if the rules are applied recursively because the run-time reference value refers to an array whose element type is an interface type.) This modified algorithm is shown here:
<ul>
<a name="29070"></a>
<li>If <i>R</i> is an ordinary class (not an array class):
<ul>
<a name="29074"></a>
<li>If <i>T</i><em></em> is a class type, then <i>R</i><em></em> must be either the same class <a href="4.doc.html#52197">(&#167;4.3.4)</a> as <i>T</i><em></em> or a subclass of <i>T</i>, or a run-time exception is thrown.
<a name="29084"></a>
<li>If <i>T</i><em></em> is an interface type, then <i>R</i> must implement <a href="8.doc.html#34031">(&#167;8.1.4)</a> interface <i>T</i>, or a run-time exception is thrown.
<a name="29085"></a>
<li>If <i>T</i><em></em> is an array type, then a run-time exception is thrown.
</ul>
<a name="174679"></a>
<li>If <i>R</i><i></i> is an interface:
<ul>
<a name="174686"></a>
<li>If <i>T</i> is a class type, then <i>T</i> must be <code>Object</code> (<a href="4.doc.html#11055">&#167;4.3.2</a>, <a href="javalang.doc1.html#46442">&#167;20.1</a>), or a run-time exception is thrown.
<a name="174687"></a>
<li>If <i>T</i> is an interface type, then <i>R</i> must be either the same interface as <i>T</i> or a subinterface of <i>T</i>,<i></i> or a run-time exception is thrown.
<a name="174682"></a>
<li>If <i>T</i> is an array type, then a run-time exception is thrown.
</ul>
<a name="29102"></a>
<li>If <i>R</i> is a class representing an array type <i>RC</i><code>[]</code>-that is, an array of components of type <i>RC</i><em>:</em>
<ul>
<a name="29109"></a>
<li>If <i>T</i><em></em> is a class type, then <i>T</i><em></em> must be <code>Object</code> (<a href="4.doc.html#11055">&#167;4.3.2</a>, <a href="javalang.doc1.html#46442">&#167;20.1</a>), or a run-time exception is thrown.
<a name="29110"></a>
<li>If <i>T</i><em></em> is an interface type, then a run-time exception is thrown unless <i>T</i> is the interface type <code>Cloneable</code>, the only interface implemented by arrays (this case could slip past the compile-time checking if, for example, a reference to an array were stored in a variable of type <code>Object</code>).
<a name="29114"></a>
<li>If <i>T</i><em></em> is an array type <i>TC</i><em></em><code>[]</code>, that is, an array of components of type <i>TC</i><em>,</em> then a run-time exception is thrown unless one of the following is true:
<ul>
<a name="29118"></a>
<li><i>TC</i><em></em> and <i>RC</i><em></em> are the same primitive type.
<a name="29119"></a>
<li><i>TC</i><em></em> and <i>RC</i><em></em> are reference types and type <i>RC</i><em></em> can be cast to <i>TC</i><em></em> by a recursive application of these run-time rules for casting.
</ul>
</ul>
</ul>
</ul><a name="13146"></a>
If a run-time exception is thrown, it is a <code>ClassCastException</code> (<a href="11.doc.html#44287">&#167;11.5.1.1</a>, 
<a href="javalang.doc20.html#46198">&#167;20.22</a>).
<p><a name="176364"></a>
Here are some examples of casting conversions of reference types, similar to the example in <a href="5.doc.html#170768">&#167;5.2</a>:<p>
<pre><a name="29290"></a>
public class Point { int x, y; }
<br><a name="29434"></a>public interface Colorable { void setColor(int color); }
<br><a name="29291"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="29348"></a>	int color;
<a name="26861"></a>	public void setColor(int color) { this.color = color; }
<a name="29293"></a>}
<br><br><a name="29294"></a>final class EndPoint extends Point { }
<br><a name="29295"></a>
class Test {
<a name="29296"></a>
	public static void main(String[] args) {
<a name="29297"></a>		Point p = new Point();
<a name="29298"></a>		ColoredPoint cp = new ColoredPoint();
<a name="29299"></a>		Colorable c;
<br><a name="29301"></a>
		// The following may cause errors at run time because
<a name="29302"></a>		// we cannot be sure they will succeed; this possibility
<a name="29303"></a>		// is suggested by the casts:
<a name="29304"></a>		cp = (ColoredPoint)p;							// p might not reference an
<a name="29380"></a>									// object which is a ColoredPoint
<a name="29381"></a>									// or a subclass of ColoredPoint
<a name="29307"></a>		c = (Colorable)p;							// p might not be Colorable
<br><a name="29309"></a>
		// The following are incorrect at compile time because
<a name="29310"></a>		// they can never succeed as explained in the text:
<a name="29311"></a>		Long l = (Long)p;							// compile-time error #1
<a name="50095"></a>		EndPoint e = new EndPoint();
<a name="29316"></a>		c = (Colorable)e;							// compile-time error #2
<br><a name="29313"></a>	}
<br><a name="29314"></a>}
</pre><a name="29315"></a>
Here the first compile-time error occurs because the class types <code>Long</code> and <code>Point</code> 
are unrelated (that is, they are not the same, and neither is a subclass of the other), 
so a cast between them will always fail.
<p><a name="176389"></a>
The second compile-time error occurs because a variable of type <code>EndPoint</code> can never reference a value that implements the interface <code>Colorable</code>. This is because <code>EndPoint</code> is a <code>final</code> type, and a variable of a <code>final</code> type always holds a value of the same run-time type as its compile-time type. Therefore, the run-time type of variable <code>e</code> must be exactly the type <code>EndPoint</code>, and type <code>EndPoint</code> does not implement <code>Colorable</code>.<p>
<a name="176390"></a>
Here is an example involving arrays <a href="10.doc.html#27803">(&#167;10)</a>: <p>
<pre><a name="176391"></a>
class Point {
<a name="53226"></a>
	int x, y;
<br><a name="53241"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<br><a name="53227"></a>	public String toString() { return "("+x+","+y+")"; }<br>
}
<br><a name="30080"></a>public interface Colorable { void setColor(int color); }
<br><a name="30081"></a>
public class ColoredPoint extends Point implements Colorable 
{
<a name="53235"></a>
	int color;
<a name="26864"></a>
	ColoredPoint(int x, int y, int color) {
<a name="53230"></a>		super(x, y); setColor(color);
<a name="53231"></a>	}
<br><br><a name="30084"></a>	public void setColor(int color) { this.color = color; }
<br><a name="53225"></a>	public String toString() {
<a name="53228"></a>		return super.toString() + "@" + color;
<a name="53229"></a>	}
<br><a name="30085"></a>}
<br><a name="30086"></a>
class Test {
<a name="30128"></a>
	public static void main(String[] args) {
<a name="30129"></a>		Point[] pa = new ColoredPoint[4];
<a name="30135"></a>		pa[0] = new ColoredPoint(2, 2, 12);
<a name="50097"></a>		pa[1] = new ColoredPoint(4, 5, 24);
<a name="30130"></a>		ColoredPoint[] cpa = (ColoredPoint[])pa;
<a name="30143"></a>		System.out.print("cpa: {");
<a name="30140"></a>		for (int i = 0; i &lt; cpa.length; i++)
<a name="30108"></a>			System.out.print((i == 0 ? " " : ", ") + cpa[i]);
<a name="53256"></a>		System.out.println(" }");
<a name="30099"></a>	}
<br><a name="30100"></a>}
</pre><a name="53223"></a>
This example compiles without errors and produces the output:
<p><pre><a name="53243"></a>cpa: { (2,2)@12, (4,5)@24, null, null }
</pre><a name="176370"></a>
The following example uses casts to compile, but it throws exceptions at run time, because the types are incompatible:<p>
<pre><a name="175285"></a>
public class Point { int x, y; }
<br><a name="29436"></a>public interface Colorable { void setColor(int color); }
<br><a name="29438"></a>
public class ColoredPoint extends Point implements Colorable 
{
<br><a name="29439"></a>	int color;
<br><br><a name="29441"></a>	public void setColor(int color) { this.color = color; }
<br><a name="29442"></a>}
<br><a name="176415"></a>
class Test {
<a name="13438"></a>
	public static void main(String[] args) {
<br><a name="29551"></a>		Point[] pa = new Point[100];
<br><a name="29560"></a>
		// The following line will throw a ClassCastException:
<a name="29460"></a>		ColoredPoint[] cpa = (ColoredPoint[])pa;
<br><br><a name="30037"></a>		System.out.println(cpa[0]);
<br><br><a name="13452"></a>		int[] shortvec = new int[2];
<br><br><a name="13453"></a>		Object o = shortvec;
<br><a name="29468"></a>
		// The following line will throw a ClassCastException:
<a name="13454"></a>		Colorable c = (Colorable)o;
<br><br><a name="30034"></a>		c.setColor(0);
<br><a name="13456"></a>	}
<br><a name="13457"></a>}
</pre><a name="26917"></a>
<h2>5.6    Numeric Promotions</h2>
<a name="26918"></a>
<i>Numeric promotion</i> is applied to the operands of an arithmetic operator. Numeric 
promotion contexts allow the use of an identity conversion <a href="5.doc.html#25209">(&#167;5.1.1)</a> or a widening 
primitive conversion <a href="5.doc.html#25222">(&#167;5.1.2)</a>.
<p><a name="53304"></a>
Numeric promotions are used to convert the operands of a numeric operator to a common type so that an operation can be performed. The two kinds of numeric promotion are unary numeric promotion <a href="5.doc.html#170952">(&#167;5.6.1)</a> and binary numeric promotion<i> </i><a href="5.doc.html#170983">(&#167;5.6.2)</a>. The analogous conversions in C are called "the usual unary conversions" and "the usual binary conversions."<p>
<a name="170949"></a>
Numeric promotion is not a general feature of Java, but rather a property of the specific definitions of the built-in operations.<p>
<a name="170952"></a>
<h3>5.6.1    Unary Numeric Promotion</h3>
<a name="170954"></a>
Some operators apply <i>unary numeric promotion</i> to a single operand, which must 
produce a value of a numeric type:
<p><ul><a name="20278"></a>
<li>If the operand is of compile-time type <code>byte</code>, <code>short</code>, or <code>char</code>, unary numeric promotion promotes it to a value of type <code>int</code> by a widening conversion <a href="5.doc.html#25222">(&#167;5.1.2)</a>.
<a name="20279"></a>
<li>Otherwise, a unary numeric operand remains as is and is not converted.
</ul><a name="23183"></a>
Unary numeric promotion is performed on expressions in the following situations:
<p><ul><a name="175745"></a>
<li>The dimension expression in array creations <a href="15.doc.html#46168">(&#167;15.9)</a>
<a name="23187"></a>
<li>The index expression in array access expressions <a href="15.doc.html#239587">(&#167;15.12)</a>
<a name="170969"></a>
<li>Operands of the unary operators plus <code>+</code> <a href="15.doc.html#24924">(&#167;15.14.3)</a> and minus <code>-</code> <a href="15.doc.html#236345">(&#167;15.14.4)</a>
<a name="170977"></a>
<li>The operand of the bitwise complement operator <code>~</code> <a href="15.doc.html#5017">(&#167;15.14.5)</a>
<a name="170981"></a>
<li>Each operand, separately, of the shift operators <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, and <code>&lt;&lt;</code> <a href="15.doc.html#5121">(&#167;15.18)</a>, so that a <code>long</code> shift distance (right operand) does not promote the value being shifted (left operand) to <code>long</code>
</ul><a name="53322"></a>
Here is a test program that includes examples of unary numeric promotion:
<p><pre><a name="7300"></a>
class Test {
<a name="13473"></a>	public static void main(String[] args) {
<a name="13474"></a>		byte b = 2;
<a name="47059"></a>		int a[] = new int[b];							// dimension expression promotion
<a name="47060"></a>		char c = '\u0001';
<a name="47061"></a>		a[c] = 1;							// index expression promotion
<a name="13490"></a>		a[0] = -c;							// unary - promotion
<a name="17404"></a>		System.out.println("a: " + a[0] + "," + a[1]);
<a name="13522"></a>
		b = -1;
<a name="39072"></a>		int i = ~b;							// bitwise complement promotion
<a name="17405"></a>		System.out.println("~0x" + Integer.toHexString(b)
<a name="174297"></a>							+ "==0x" + Integer.toHexString(i));
<a name="13523"></a>
		i = b &lt;&lt; 4L;							// shift promotion (left operand)
<a name="17411"></a>		System.out.println("0x" + Integer.toHexString(b)
<a name="174298"></a>					 + "&lt;&lt;4L==0x" + Integer.toHexString(i));
<a name="13525"></a>	}
<a name="13526"></a>}
</pre><a name="30172"></a>
This test program produces the output:
<p><pre><a name="39118"></a>
a: -1,1
<a name="39119"></a>~0xffffffff==0x0
<a name="30173"></a>0xffffffff&lt;&lt;4L==0xfffffff0
</pre><a name="170983"></a>
<h3>5.6.2    Binary Numeric Promotion</h3>
<a name="170985"></a>
When an operator applies <i>binary numeric promotion</i> to a pair of operands, each of 
which must denote a value of a numeric type, the following rules apply, in order, 
using widening conversion <a href="5.doc.html#25222">(&#167;5.1.2)</a> to convert operands as necessary:
<p><ul><a name="170986"></a>
<li>If either operand is of type <code>double</code>, the other is converted to <code>double</code>.
<a name="170987"></a>
<li>Otherwise, if either operand is of type <code>float</code>, the other is converted to <code>float</code>.
<a name="170988"></a>
<li>Otherwise, if either operand is of type <code>long</code>, the other is converted to <code>long</code>.
<a name="170989"></a>
<li>Otherwise, both operands are converted to type <code>int</code>.
</ul><a name="170990"></a>
Binary numeric promotion is performed on the operands of certain operators:
<p><ul><a name="170994"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code> and <code>%</code> <a href="15.doc.html#239829">(&#167;15.16)</a>
<a name="170998"></a>
<li>The addition and subtraction operators for numeric types <code>+</code> and <code>- </code><a href="15.doc.html#13510">(&#167;15.17.2)</a>
<a name="171002"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="15.doc.html#153654">(&#167;15.19.1)</a>
<a name="171006"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="15.doc.html#5198">(&#167;15.20.1)</a>
<a name="171010"></a>
<li>The integer bitwise operators <code>&amp;</code>, <code>^</code>, and <code>|</code> <a href="15.doc.html#5233">(&#167;15.21.1)</a>
<a name="171014"></a>
<li>In certain cases, the conditional operator <code>?&#32;:</code> <a href="15.doc.html#5257">(&#167;15.24)</a>
</ul><a name="7306"></a>
An example of binary numeric promotion appears above in <a href="5.doc.html#170671">&#167;5.1</a>. Here is another:
<p><pre><a name="13528"></a>
class Test {
<a name="13529"></a>	public static void main(String[] args) {
<a name="13538"></a>		int i = 0;
<a name="13550"></a>		float f = 1.0f;
<a name="13551"></a>		double d = 2.0;
<br><a name="13552"></a>
		// First i*f promoted to float*float, then
<a name="13558"></a>		// float==double is promoted to double==double:
<a name="13553"></a>		if (i * f == d)
<a name="13554"></a>			System.out.println("oops");
<br><a name="13561"></a>
		// A char&amp;byte is promoted to int&amp;int:
<a name="13569"></a>		byte b = 0x1f;
<a name="174808"></a>		char c = 'G';
<a name="174809"></a>		int control = c &amp; b;
<a name="174810"></a>		System.out.println(Integer.toHexString(control));
<br><a name="174811"></a>
		// A int:float promoted to float:float:
<a name="13575"></a>		f = (b==0) ? f : 4.0f;
<a name="17464"></a>		System.out.println(1.0/f);
<br><a name="17463"></a>	}
<br><a name="13539"></a>}
</pre><a name="17465"></a>
which produces the output:
<p><pre><a name="29583"></a>
7
<a name="7307"></a>0.25
</pre><a name="174310"></a>
The example converts the ASCII character <code>G</code> to the ASCII control-G (BEL), by 
masking off all but the low 5 bits of the character. The <code>7</code> is the numeric value of 
this control character.
<p><a name="183330"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="4.doc.html">Prev</a> | <a href="6.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>