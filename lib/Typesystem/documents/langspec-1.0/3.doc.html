<html>
<head>
<title>The Java Language Specification
 Lexical Structure</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="2.doc.html">Prev</a> | <a href="4.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="48198"></a>
<p><strong>
CHAPTER
 3 </strong></p>
<a name="44591"></a>
<h1>Lexical Structure</h1>
<hr><p>
<a name="230314"></a>
This chapter specifies the lexical structure of Java.
<p><a name="230426"></a>
Java programs are written in Unicode <a href="3.doc.html#95413">(&#167;3.1)</a>, but lexical translations are provided <a href="3.doc.html#95504">(&#167;3.2)</a> so that Unicode escapes <a href="3.doc.html#100850">(&#167;3.3)</a> can be used to include any Unicode character using only ASCII characters. Line terminators are defined <a href="3.doc.html#231571">(&#167;3.4)</a> to support the different conventions of existing host systems while maintaining consistent line numbers.<p>
<a name="229936"></a>
The Unicode characters resulting from the lexical translations are reduced to a sequence of input elements <a href="3.doc.html#25687">(&#167;3.5)</a>, which are white space <a href="3.doc.html#95710">(&#167;3.6)</a>, comments <a href="3.doc.html#48125">(&#167;3.7)</a>, and tokens. The tokens are the identifiers <a href="3.doc.html#40625">(&#167;3.8)</a>, keywords <a href="3.doc.html#229308">(&#167;3.9)</a>, literals <a href="3.doc.html#48272">(&#167;3.10)</a>, separators <a href="3.doc.html#230752">(&#167;3.11)</a>, and operators <a href="3.doc.html#230663">(&#167;3.12)</a> of the Java syntactic grammar.<p>
<a name="95413"></a>
<h2>3.1    Unicode</h2>
<a name="230444"></a>
Java programs are written using the<i> </i>Unicode character set, version 2.0. Information
about this encoding may be found at:
<p><pre><a name="230446"></a><code>http://www.unicode.org </code>and<code> ftp://unicode.org
</code></pre><a name="230450"></a>
Versions of Java prior to 1.1 used Unicode version 1.1.5 (see <em>The Unicode Standard:
Worldwide Character Encoding </em><a href="1.doc.html#11506">(&#167;1.2)</a> and updates). See <a href="javalang.doc4.html#14345">&#167;20.5</a> for a discussion
of the differences between Unicode version 1.1.5 and Unicode version 2.0.
<p><a name="99446"></a>
Except for comments <a href="3.doc.html#48125">(&#167;3.7)</a>, identifiers, and the contents of character and string literals (<a href="3.doc.html#100960">&#167;3.10.4</a>, <a href="3.doc.html#101083">&#167;3.10.5</a>), all input elements <a href="3.doc.html#25687">(&#167;3.5)</a> in a Java program are formed only from ASCII characters (or Unicode escapes <a href="3.doc.html#100850">(&#167;3.3)</a> which result in ASCII characters). ASCII (ANSI X3.4) is the American Standard Code for Information Interchange. The first 128 characters of the Unicode character encoding are the ASCII characters.<p>
<a name="95504"></a>
<h2>3.2    Lexical Translations</h2>
<a name="48080"></a>
A raw Unicode character stream is translated into a sequence of Java tokens, using 
the following three lexical translation steps, which are applied in turn:
<p><ol>
<a name="48081"></a>
<li>A translation of Unicode escapes <a href="3.doc.html#100850">(&#167;3.3)</a> in the raw stream of Unicode characters to the corresponding Unicode character. A Unicode escape of the form <code>\u</code><i>xxxx</i>, where <i>xxxx</i> is a hexadecimal value, represents the Unicode character whose encoding is <i>xxxx</i>. This translation step allows any Java program to be expressed using only ASCII characters.
<a name="48082"></a>
<li>A translation of the Unicode stream resulting from step 1 into a stream of input characters and line terminators <a href="3.doc.html#231571">(&#167;3.4)</a>.
<a name="95812"></a>
<li>A translation of the stream of input characters and line terminators resulting from step 2 into a sequence of Java input elements <a href="3.doc.html#25687">(&#167;3.5)</a> which, after white space <a href="3.doc.html#95710">(&#167;3.6)</a> and comments <a href="3.doc.html#48125">(&#167;3.7)</a> are discarded, comprise the tokens <a href="3.doc.html#25687">(&#167;3.5)</a> that are the terminal symbols of the syntactic grammar <a href="2.doc.html#140845">(&#167;2.3)</a> for Java.
</ol>
<a name="100835"></a>
Java always uses the longest possible translation at each step, even if the result does not ultimately make a correct Java program, while another lexical translation would. Thus the input characters <code>a--b</code> are tokenized <a href="3.doc.html#25687">(&#167;3.5)</a> as <code>a</code>, <code>--</code>, <code>b</code>, which is not part of any grammatically correct Java program, even though the tokenization <code>a</code>, <code>-</code>, <code>-</code>,<code>&#32;b</code> could be part of a grammatically correct Java program.<p>
<a name="100850"></a>
<h2>3.3    Unicode Escapes</h2>
<a name="48089"></a>
Java implementations first recognize <i>Unicode escapes</i> in their input, translating 
the ASCII characters <code>\u</code> followed by four hexadecimal digits to the Unicode character
with the indicated hexadecimal value, and passing all other characters 
unchanged. This translation step results in a sequence of Unicode input characters:

<p><ul><pre>
<i>UnicodeInputCharacter:<br>
</i>	<i>UnicodeEscape<br>
</i>	<i>RawInputCharacter
</i>
<i>UnicodeEscape:<br>
</i><code>	\ </code><i>UnicodeMarker</i><code> </code><i>HexDigit</i><code> </code><i>HexDigit</i><code> </code><i>HexDigit</i><code> </code><i>HexDigit
</i>
<i>UnicodeMarker:<br>
</i>	<code>u<br>
</code>	<i>UnicodeMarker</i><code> u
</code>
<i>RawInputCharacter:<br>
</i>	any Unicode character

<i>HexDigit:</i> <i>one</i> <i>of<br>
</i><code>	0&#32;1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7&#32;8&#32;9&#32;a&#32;b&#32;c&#32;d&#32;e&#32;f&#32;A&#32;B&#32;C&#32;D&#32;E&#32;F
</code></pre></ul><a name="229834"></a>
The <code>\</code>, <code>u</code>, and hexadecimal digits here are all ASCII characters.<p>
<a name="231557"></a>
In addition to the processing implied by the grammar, for each raw input character that is a backslash <code>\</code>, input processing must consider how many other <code>\</code> characters contiguously precede it, separating it from a non-<code>\</code> character or the start of the input stream. If this number is even, then the <code>\</code> is eligible to begin a Unicode escape; if the number is odd, then the <code>\</code> is not eligible to begin a Unicode escape. For example, the raw input <code>"\\u2297=\u2297"</code> results in the eleven characters <code>"</code> &#32;<code>\</code> <code>\</code> <code>u</code> <code>2</code> <code>2</code> <code>9</code> <code>7</code> <code>=</code> <img src="chars/circmult.gif"> <code>"</code> (<code>\u2297</code> is the Unicode encoding of the character "<img src="chars/circmult.gif">")<code>.</code><p>
<a name="229835"></a>
If an eligible <code>\</code> is not followed by <code>u</code>, then it is treated as a <i>RawInputCharacter</i> and remains part of the escaped Unicode stream. If an eligible <code>\</code> is followed by <code>u</code>, or more than one <code>u</code>, and the last <code>u</code> is not followed by four hexadecimal digits, then a compile-time error occurs.<p>
<a name="48098"></a>
The character produced by a Unicode escape does not participate in further Unicode escapes. For example, the raw input <code>\u005cu005a</code> results in the six characters <code>\</code> <code>u</code> <code>0</code> <code>0</code> <code>5</code> <code>a</code>, because <code>005c</code> is the Unicode value for <code>\</code>.<code> </code>It does not result in the character <code>Z</code>, which is Unicode character <code>005a</code>, because the <code>\</code> that resulted from the <code>\u005c</code> is not interpreted as the start of a further Unicode escape.<p>
<a name="228824"></a>
Java specifies a standard way of transforming a Unicode Java program into ASCII that changes a Java program into a form that can be processed by ASCII-based tools. The transformation involves converting any Unicode escapes in the source text of the program to ASCII by adding an extra <code>u</code>-for example, <code>\u</code><i>xxxx</i> becomes <code>\uu</code><i>xxxx</i>-while simultaneously converting non-ASCII characters in the source text to a <code>\u</code><i>xxxx</i> escape containing a single <code>u</code>. This transformed version is equally acceptable to a Java compiler and represents the exact same program. The exact Unicode source can later be restored from this ASCII form by converting each escape sequence where multiple <code>u</code>'s are present to a sequence of Unicode characters with one fewer <code>u</code>, while simultaneously converting each escape sequence with a single <code>u</code> to the corresponding single Unicode character.<p>
<a name="231569"></a>
Java systems should use the <code>\u</code><i>xxxx</i> notation as an output format to display Unicode characters when a suitable font is not available.<p>
<a name="231571"></a>
<h2>3.4    Line Terminators</h2>
<a name="22634"></a>
Java implementations next divide the sequence of Unicode input characters into 
lines by recognizing <i>line terminators</i>. This definition of lines determines the line 
numbers produced by a Java compiler or other Java system component. It also 
specifies the termination of the <code>//</code> form of a comment <a href="3.doc.html#48125">(&#167;3.7)</a>.
<p><ul><pre>
<i>LineTerminator:<br>
</i><code>	</code>the ASCII LF character, also known as "newline"<br>
	the ASCII CR character, also known as "return"<br>
<code>	</code>the ASCII CR character followed by the ASCII LF character

<i>InputCharacter:<br>
</i>	<i>UnicodeInputCharacter</i> but not CR or LF
</pre></ul><a name="48107"></a>
Lines are terminated by the ASCII characters CR, or LF, or CR LF. The two characters CR immediately followed by LF are counted as one line terminator, not two. The result is a sequence of line terminators and input characters, which are the terminal symbols for the third step in the tokenization process.<p>
<a name="25687"></a>
<h2>3.5    Input Elements and Tokens</h2>
<a name="25688"></a>
The input characters and line terminators that result from escape processing <a href="3.doc.html#100850">(&#167;3.3)</a> 
and then input line recognition <a href="3.doc.html#231571">(&#167;3.4)</a> are reduced to a sequence of <i>input elements</i>. 
Those input elements that are not white space <a href="3.doc.html#95710">(&#167;3.6)</a> or comments <a href="3.doc.html#48125">(&#167;3.7)</a> are 
<i>tokens</i>. The tokens are the terminal symbols of the Java syntactic grammar <a href="2.doc.html#140845">(&#167;2.3)</a>.
<p><a name="95675"></a>
This process is specified by the following productions:<p>
<ul><pre>
<i>Input:<br>
</i>	<i>InputElements</i><sub><i>opt</i></sub><code> </code><i>Sub</i><sub><i>opt
</i></sub>
<i>InputElements:<br>
</i>	<i>InputElement<br>
</i>	<i>InputElements</i><code> </code><i>InputElement
</i>
<i>InputElement:<br>
</i>	<i>WhiteSpace<br>
</i>	<i>Comment<br>
</i>	<i>Token
</i>
<i>Token:<br>
</i>	<i>Identifier<br>
</i>	<i>Keyword<br>
</i>	<i>Literal<br>
</i>	<i>Separator<br>
</i>	<i>Operator
</i>
<i>Sub:<br>
</i>	the ASCII SUB character, also known as "control-Z"
</pre></ul><a name="95707"></a>
White space <a href="3.doc.html#95710">(&#167;3.6)</a> and comments <a href="3.doc.html#48125">(&#167;3.7)</a> can serve to separate tokens that, if adjacent, might be tokenized in another manner. For example, the ASCII characters <code>-</code> and <code>=</code> in the input can form the operator token <code>-=</code> <a href="3.doc.html#230663">(&#167;3.12)</a> only if there is no intervening white space or comment.<p>
<a name="25733"></a>
As a special concession for compatibility with certain operating systems, the ASCII SUB character (<code>\u001a</code>, or control-Z) is ignored if it is the last character in the escaped input stream.<p>
<a name="230834"></a>
Consider two tokens <i>x</i> and <i>y</i> in the resulting input stream. If <i>x</i> precedes <i>y</i>, then we say that <i>x</i> is <i>to the left of</i> <i>y</i> and that <i>y</i> is <i>to the right of</i> <i>x</i>. For example, in this simple piece of Java code:<p>
<pre><a name="230839"></a>
class Empty {
<a name="230840"></a>}
</pre><a name="230846"></a>
we say that the <code>}</code> token is to the right of the <code>{</code> token, even though it appears, in this 
two-dimensional representation on paper, downward and to the left of the <code>{</code> token. 
This convention about the use of the words left and right allows us to speak, for 
example, of the right-hand operand of a binary operator or of the left-hand side of 
an assignment.
<p><a name="95710"></a>
<h2>3.6    White Space</h2>
<a name="48121"></a>
<i>White space</i> is defined as the ASCII space, horizontal tab, and form feed characters,
as well as line terminators <a href="3.doc.html#231571">(&#167;3.4)</a>.
<p><ul><pre>
<i>WhiteSpace:<br>
</i>	the ASCII SP character, also known as "space"<br>
<code>	</code>the ASCII HT character, also known as "horizontal tab"<br>
<code>	</code>the ASCII FF character, also known as "form feed"<br>
	<i>LineTerminator
</i></pre></ul><a name="48125"></a>
<h2>3.7    Comments</h2>
<a name="9724"></a>
Java defines three kinds of <i>comments</i>:
<p><a name="9727"></a>
 <code>/* </code><i>text</i><code> */		</code>A <i>traditional comment</i>: all the text from the ASCII characters <code>/*</code> to the ASCII characters <code>*/</code> is ignored (as in C and C++).<p>
<a name="9730"></a>
 <code>// </code><i>text		</i>A <i>single-line comment</i>: all the text from the ASCII characters <code>//</code> to the end of the line is ignored (as in C++).<p>
<a name="228965"></a>
 <code>/** </code><i>documentation</i><code> */</code>		A <i>documentation comment</i>: the text enclosed by the ASCII characters <code>/**</code> and <code>*/</code> can be processed by a separate tool to prepare automatically generated documentation of the following class, interface, constructor, or member (method or field) declaration. See <a href="18.doc.html#25978">&#167;18</a> for a full description of how the supplied <i>documentation</i> is processed.<p>
<a name="228969"></a>
These comments are formally specified by the following productions:
<p><ul><pre>
<i>Comment:<br>
</i>	<i>TraditionalComment<br>
</i>	<i>EndOfLineComment<br>
</i>	<i>DocumentationComment
</i>
<i>TraditionalComment</i>:<br>
	<code>/ * </code><i>NotStar</i><code> </code><i>CommentTail
</i>
<i>EndOfLineComment:<br>
</i>	<code>/ / </code><i>CharactersInLine</i><sub><i>opt</i></sub><code> </code><i>LineTerminator
</i>
<i>DocumentationComment:<br>
</i>	<code>/ * * </code><i>CommentTailStar
</i>
<i>CommentTail:<br>
</i>	<code>* </code><i>CommentTailStar<br>
</i>	<i>NotStar</i><code> </code><i>CommentTail
</i>
<i>CommentTailStar:<br>
</i>	<code>/<br>
	* </code><i>CommentTailStar<br>
</i>	<i>NotStarNotSlash</i><code> </code><i>CommentTail
</i>
<i>NotStar:<br>
</i>	<i>InputCharacter</i> but not <code>*<br>
</code>	<i>LineTerminator
</i>
<i>NotStarNotSlash:<br>
</i>	<i>InputCharacter</i> but not <code>*</code> or <code>/<br>
</code>	<i>LineTerminator
</i>
<i>CharactersInLine:<br>
</i>	<i>InputCharacter<br>
</i>	<i>CharactersInLine</i><code> </code><i>InputCharacter
</i></pre></ul><a name="230630"></a>
These productions imply all of the following properties:
<p><ul><a name="48132"></a>
<li>Comments do not nest.
<a name="48134"></a>
<li><code>/*</code> and <code>*/</code> have no special meaning in comments that begin with <code>//</code>.
<a name="48135"></a>
<li><code>//</code> has no special meaning in comments that begin with <code>/*</code> or <code>/**</code>.
</ul><a name="48136"></a>
As a result, the text:
<p><pre><a name="48137"></a>/*<code> </code>this comment /* // /** ends here: */
</pre><a name="230885"></a>
is a single complete comment.
<p><a name="230886"></a>
The lexical grammar implies that comments do not occur within character literals <a href="3.doc.html#100960">(&#167;3.10.4)</a> or string literals <a href="3.doc.html#101083">(&#167;3.10.5)</a>.<p>
<a name="229276"></a>
Note that <code>/**/</code> is considered to be a documentation comment, while <code>/* */ </code>(with a space between the asterisks) is a traditional comment.<p>
<a name="40625"></a>
<h2>3.8    Identifiers</h2>
<a name="229286"></a>
An <i>identifier</i> is an unlimited-length sequence of <i>Java letters</i> and <i>Java digits</i>, the 
first of which must be a Java letter. An identifier cannot have the same spelling 
(Unicode character sequence) as a keyword <a href="3.doc.html#229308">(&#167;3.9)</a>, Boolean literal <a href="3.doc.html#49652">(&#167;3.10.3)</a>, or 
the null literal <a href="3.doc.html#230717">(&#167;3.10.7)</a>.
<p><ul><pre>
<i>Identifier:<br>
</i>	<i>IdentifierChars</i> but not a <i>Keyword</i> or <i>BooleanLiteral</i> or <i>NullLiteral
</i>
<i>IdentifierChars:<br>
</i>	<i>JavaLetter<br>
</i>	<i>IdentifierChars</i><code> </code><i>JavaLetterOrDigit
</i>
<i>JavaLetter:<br>
</i>	any Unicode character that is a Java letter (see below)

<i>JavaLetterOrDigit:<br>
</i>	any Unicode character that is a Java letter-or-digit (see below)
</pre></ul><a name="23674"></a>
Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean. This allows Java programmers to use identifiers in their programs that are written in their native languages.<p>
<a name="19216"></a>
A Java letter is a character for which the method <code>Character.isJavaLetter</code> <a href="javalang.doc4.html#9516">(&#167;20.5.17)</a> returns <code>true</code>. A Java letter-or-digit is a character for which the method <code>Character.isJavaLetterOrDigit</code> <a href="javalang.doc4.html#9166">(&#167;20.5.18)</a> returns <code>true</code>.<p>
<a name="230343"></a>
The Java letters include uppercase and lowercase ASCII Latin letters <code>A</code>-<code>Z</code> (<code>\u0041</code>-<code>\u005a</code>), and <code>a</code>-<code>z</code> <code>(\u0061</code>-<code>\u007a</code>), and, for historical reasons, the ASCII underscore (<code>_</code>, or <code>\u005f</code>) and dollar sign (<code>$</code>, or <code>\u0024</code>). The <code>$</code> character should be used only in mechanically generated Java code or, rarely, to access preexisting names on legacy systems.<p>
<a name="230344"></a>
The Java digits include the ASCII digits <code>0-9</code> (<code>\u0030</code>-<code>\u0039)</code>.<p>
<a name="230345"></a>
Two identifiers are the same only if they are identical, that is, have the same Unicode character for each letter or digit<em>.</em><p>
<a name="21262"></a>
Identifiers that have the same external appearance may yet be different. For example, the identifiers consisting of the single letters LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041</code>), LATIN SMALL LETTER A (<code>a</code>, <code>\u0061</code>), GREEK CAPITAL LETTER ALPHA (<code>A</code>, <code>\u0391</code>), and CYRILLIC SMALL LETTER A (<code>a</code>, <code>\u0430</code>) are all different.<p>
<a name="48270"></a>
Unicode composite characters are different from the decomposed characters. For example, a LATIN CAPITAL LETTER A ACUTE (<code>&Aacute;,</code> <code>\u00c1)</code> could be considered to be the same as a LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041)</code> immediately followed by a NON-SPACING ACUTE (&#180;, <code>\u0301</code>) when sorting, but these are different in Java identifiers. See <i>The Unicode Standard</i>, Volume 1, pages 412ff for details about decomposition, and see pages 626-627 of that work for details about sorting.<p>
<a name="31160"></a>
Examples of identifiers are:<p>
<pre><a name="31161"></a>	String			i3		<img src="chars/alpha.gif"><img src="chars/rho.gif"><img src="chars/epsilon.gif"><img src="chars/tau.gif"><img src="chars/eta.gif">			MAX_VALUE				isLetterOrDigit
</pre><a name="229308"></a>
<h2>3.9    Keywords</h2>
<a name="229309"></a>
The following character sequences, formed from ASCII letters, are reserved for 
use as <i>keywords</i> and cannot be used as identifiers <a href="3.doc.html#40625">(&#167;3.8)</a>:
<p><ul><pre>
<i>Keyword: one of<br>
</i><code>	abstract	default	if	private	throw<br>
	boolean	do	implements	protected	throws<br>
	break	double	import	public	transient<br>
	byte	else	instanceof	return	try<br>
	case	extends	int	short	void<br>
	catch	final	interface	static	volatile<br>
	char	finally	long	super	while<br>
	class	float	native	switch<br>
	const	for	new	synchronized<br>
	continue	goto	package	this
</code></pre></ul><a name="229316"></a>
The keywords <code>const</code> and <code>goto</code> are reserved by Java, even though they are not currently used in Java. This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in Java programs.<p>
<a name="229317"></a>
While <code>true</code> and <code>false</code> might appear to be keywords, they are technically Boolean literals <a href="3.doc.html#49652">(&#167;3.10.3)</a>. Similarly, while <code>null</code> might appear to be a keyword, it is technically the null literal <a href="3.doc.html#230717">(&#167;3.10.7)</a>.<p>
<a name="48272"></a>
<h2>3.10    Literals</h2>
<a name="228794"></a>
A <i>literal</i> is the source code representation of a value of a primitive type <a href="4.doc.html#85587">(&#167;4.2)</a>, the 
<code>String</code> type (<a href="4.doc.html#26992">&#167;4.3.3</a>, <a href="javalang.doc11.html#14460">&#167;20.12</a>), or the null type <a href="4.doc.html#11128">(&#167;4.1)</a>:
<p><ul><pre>
<i>Literal:<br>
	IntegerLiteral<br>
	FloatingPointLiteral<br>
	BooleanLiteral<br>
	CharacterLiteral<br>
	StringLiteral<br>
	NullLiteral
</i></pre></ul><a name="48282"></a>
<h3>3.10.1    Integer Literals</h3>
<a name="46750"></a>
See <a href="4.doc.html#9151">&#167;4.2.1</a> for a general discussion of the integer types and values.
<p><a name="7117"></a>
An <i>integer literal</i> may be expressed in decimal (base 10), hexadecimal (base &#32;16), or octal (base 8):<p>
<ul><pre>
<i>IntegerLiteral:<br>
	DecimalIntegerLiteral<br>
	HexIntegerLiteral	<br>
	OctalIntegerLiteral
</i>
<i>DecimalIntegerLiteral:<br>
	DecimalNumeral</i><code> </code><i>IntegerTypeSuffix</i><sub><i>opt
</i></sub>
<i>HexIntegerLiteral:<br>
	HexNumeral</i><code> </code><i>IntegerTypeSuffix</i><sub><i>opt
</i></sub>
<i>OctalIntegerLiteral:	<br>
	OctalNumeral</i><code> </code><i>IntegerTypeSuffix</i><sub><i>opt
</i></sub>
<i>IntegerTypeSuffix:</i> <i>one</i> <i>of<br>
</i>	<code>l&#32;L
</code></pre></ul><a name="19247"></a>
An integer literal is of type <code>long</code> if it is suffixed with an ASCII letter <code>L</code> or <code>l</code> (ell); otherwise it is of type <code>int</code> <a href="4.doc.html#9151">(&#167;4.2.1)</a>. The suffix <code>L</code> is preferred, because the letter <code>l</code> (ell) is often hard to distinguish from the digit <code>1</code> (one).<p>
<a name="48345"></a>
A decimal numeral is either the single ASCII character <code>0</code>, representing the integer zero, or consists of an ASCII digit from <code>1</code> to <code>9</code>, optionally followed by one or more ASCII digits from <code>0</code> to <code>9</code>, representing a positive integer:<p>
<ul><pre>
<i>DecimalNumeral:<br>
	</i><code>0<br>
</code>	<i>NonZeroDigit</i><code> </code><i>Digits</i><sub><i>opt
</i></sub>
<i>Digits:<br>
	Digit<br>
	Digits</i><code> </code><i>Digit
</i>
<i>Digit:<br>
</i><code>	0<br>
</code><i>	NonZeroDigit
</i>
<i>NonZeroDigit: one of<br>
</i><code>	1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7&#32;8&#32;9
</code></pre></ul><a name="44312"></a>
A hexadecimal numeral consists of the leading ASCII characters <code>0x</code> or <code>0X</code> followed by one or more ASCII hexadecimal digits and can represent a positive, zero, or negative integer. Hexadecimal digits with values 10 through 15 are represented by the ASCII letters <code>a</code> through <code>f</code> or <code>A</code> through <code>F</code>, respectively; each letter used as a hexadecimal digit may be uppercase or lowercase.<p>
<ul><pre>
<i>HexNumeral:<br>
</i><code>	0 x </code><i>HexDigit<br>
</i>	<code>0 X </code><i>HexDigit<br>
</i><code>	</code>HexNumeral<code> </code>HexDigit
</pre></ul><a name="229443"></a>
The following production from <a href="3.doc.html#100850">&#167;3.3</a> is repeated here for clarity:
<p><ul><pre>
<i>HexDigit:</i> <i>one</i> <i>of<br>
</i><code>	0&#32;1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7&#32;8&#32;9&#32;a&#32;b&#32;c&#32;d&#32;e&#32;f&#32;A&#32;B&#32;C&#32;D&#32;E&#32;F
</code></pre></ul><a name="48298"></a>
An octal numeral consists of an ASCII digit <code>0</code> followed by one or more of the ASCII digits <code>0</code> through <code>7</code> and can represent a positive, zero, or negative integer.<p>
<ul><pre>
<i>OctalNumeral:<br>
</i><code>	0 </code><i>OctalDigit<br>
	OctalNumeral</i><code> </code><i>OctalDigit
</i>
<i>OctalDigit:</i> <i>one</i> <i>of<br>
</i><code>	0&#32;1&#32;2&#32;3&#32;4&#32;5&#32;6&#32;7
</code><a name="231741"></a>
 <p>
</pre></ul><a name="231738"></a>
Note that octal numerals are always consist of two or more digits; <code>0</code> is always considered to be a decimal numeral-not that it matters much in practice, for the numerals <code>0</code>, <code>00</code>, and <code>0x0</code> all represent exactly the same integer value.<p>
<a name="231836"></a>
The largest decimal literal of type <code>int</code> is <code>2147483648</code> (<img src="3.doc.anc.gif">). All decimal literals from <code>0</code> to <code>2147483647</code> may appear anywhere an <code>int</code> literal may appear, but the literal <code>2147483648</code> may appear only as the operand of the unary negation operator <code>-</code>.<p>
<a name="229493"></a>
The largest positive hexadecimal and octal literals of type <code>int</code> are <code>0x7fffffff</code> and <code>017777777777</code>, respectively, which equal <code>2147483647</code> (<img src="3.doc.anc1.gif">). The most negative hexadecimal and octal literals of type <code>int</code> are <code>0x80000000</code> and <code>020000000000</code>, respectively, each of which represents the decimal value <code>-2147483648</code> (<img src="3.doc.anc2.gif">). The hexadecimal and octal literals <code>0xffffffff</code> and <code>037777777777</code>, respectively, represent the decimal value <code>-1</code>.<p>
<a name="229508"></a>
See also <code>Integer.MIN_VALUE</code> <a href="javalang.doc6.html#2390">(&#167;20.7.1)</a> and <code>Integer.MAX_VALUE</code> <a href="javalang.doc6.html#2391">(&#167;20.7.2)</a>.<p>
<a name="48314"></a>
A compile-time error occurs if a decimal literal of type <code>int</code> is larger than <code>2147483648</code> (<img src="3.doc.anc3.gif">), or if the literal <code>2147483648</code> appears anywhere other than as the operand of the unary <code>-</code> operator, or if a hexadecimal or octal <code>int</code> literal does not fit in 32 bits.<p>
<a name="48319"></a>
Examples of <code>int</code> literals:<p>
<pre><a name="48320"></a>	0		2		0372			0xDadaCafe					1996		0x00FF00FF
</pre><a name="21371"></a>
The largest decimal literal of type <code>long</code> is <code>9223372036854775808L</code> (<img src="3.doc.anc4.gif">). All decimal literals from <code>0L</code> to <code>9223372036854775807L</code> may appear anywhere a <code>long</code> literal may appear, but the literal <code>9223372036854775808L</code> may appear only as the operand of the unary negation operator <code>-</code>.<p>
<a name="21372"></a>
The largest positive hexadecimal and octal literals of type <code>long</code> are <code>0x7fffffffffffffffL</code> and <code>0777777777777777777777L</code>, respectively, which equal <code>9223372036854775807L</code> (<img src="3.doc.anc5.gif">). The literals <code>0x8000000000000000L</code> and <code>01000000000000000000000L</code> are the most negative <code>long</code> hexadecimal and octal literals, respectively. Each has the decimal value<code> -9223372036854775808L</code> (<img src="3.doc.anc6.gif">). The hexadecimal and octal literals <code>0xffffffffffffffffL</code> and <code>01777777777777777777777L</code>, respectively, represent the decimal value <code>-1L</code>.<p>
<a name="229516"></a>
See also <code>Long.MIN_VALUE</code> <a href="javalang.doc7.html#2397">(&#167;20.8.1)</a> and <code>Long.MAX_VALUE</code> <a href="javalang.doc7.html#14434">(&#167;20.8.2)</a>.<p>
<a name="76695"></a>
A compile-time error occurs if a decimal literal of type <code>long</code> is larger than <code>9223372036854775808L</code> (<img src="3.doc.anc7.gif">), or if the literal <code>9223372036854775808L</code> appears anywhere other than as the operand of the unary <code>-</code> operator, or if a hexadecimal or octal <code>long</code> literal does not fit in 64 bits.<p>
<a name="46763"></a>
Examples of <code>long</code> literals:<p>
<pre><a name="46765"></a>	0l		0777L			0x100000000L					2147483648L				  &#32;0xC0B0L
</pre><a name="230798"></a>
<h3>3.10.2    Floating-Point Literals</h3>
<a name="232095"></a>
See <a href="4.doc.html#9208">&#167;4.2.3</a> for a general discussion of the floating-point types and values.
<p><a name="232096"></a>
A <i>floating-point literal</i> has the following parts: a whole-number part, a decimal point (represented by an ASCII period character), a fractional part, an exponent, and a type suffix. The exponent, if present, is indicated by the ASCII letter <code>e</code> or <code>E</code> followed by an optionally signed integer.<p>
<a name="48344"></a>
At least one digit, in either the whole number or the fraction part, and either a decimal point, an exponent, or a float type suffix are required. All other parts are optional.<p>
<a name="76707"></a>
A floating-point literal is of type <code>float</code> if it is suffixed with an ASCII letter <code>F</code> or <code>f</code>; otherwise its type is <code>double</code> and it can optionally be suffixed with an ASCII letter <code>D</code> or <code>d</code>.<p>
<ul><pre>
<i>FloatingPointLiteral:<br>
	Digits</i><code> . </code><i>Digits</i><sub><i>opt</i></sub><code> </code><i>ExponentPart</i><sub><i>opt</i></sub><code> </code><i>FloatTypeSuffix</i><sub><i>opt<br>
</i></sub>	<code>. </code><i>Digits</i><code> </code><i>ExponentPart</i><sub><i>opt</i></sub><code> </code><i>FloatTypeSuffix</i><sub><i>opt<br>
</i></sub>	<i>Digits</i><code> </code><i>ExponentPart</i><code> </code><i>FloatTypeSuffix</i><sub><i>opt<br>
	</i></sub><i>Digits</i><code> </code><i>ExponentPart</i><sub><i>opt</i></sub><code> </code><i>FloatTypeSuffix
</i>
<i>ExponentPart:<br>
</i>	<i>ExponentIndicator</i><code> </code><i>SignedInteger
</i>
<i>ExponentIndicator:</i> <i>one</i> <i>of<br>
</i>	<code>e E
</code>
<i>SignedInteger:<br>
</i>	<i>Sign</i><sub><i>opt</i></sub><code> </code><i>Digits
</i>
<i>Sign:</i> <i>one</i> <i>of<br>
</i>	<code>+ -
</code>
<i>FloatTypeSuffix:</i> <i>one</i> <i>of<br>
</i>	<code>f F d D
</code></pre></ul><a name="230642"></a>
The Java types <code>float</code> and <code>double</code> are IEEE 754 32-bit single-precision and 64-bit double-precision binary floating-point values, respectively.<p>
<a name="230643"></a>
The details of proper input conversion from a Unicode string representation of a floating-point number to the internal IEEE 754 binary floating-point representation are described for the methods <code>valueOf</code> of class <code>Float</code> <a href="javalang.doc8.html#7256">(&#167;20.9.17)</a> and class <code>Double</code> <a href="javalang.doc9.html#1541">(&#167;20.10.16)</a> of the package <code>java.lang</code>.<p>
<a name="76740"></a>
The largest positive finite <code>float</code> literal is <code>3.40282347e+38f</code>. The smallest positive finite nonzero literal of type <code>float</code> is <code>1.40239846e-45f</code>. The largest positive finite <code>double</code> literal is <code>1.79769313486231570e+308</code>. The smallest positive finite nonzero literal of type <code>double</code> is <code>4.94065645841246544e-324</code>.<p>
<a name="229595"></a>
See <code>Float.MIN_VALUE</code> <a href="javalang.doc8.html#14404">(&#167;20.9.1)</a> and <code>Float.MAX_VALUE </code><a href="javalang.doc8.html#2303">(&#167;20.9.2)</a>; see also <code>Double.MIN_VALUE</code> <a href="javalang.doc9.html#3571">(&#167;20.10.1)</a> and <code>Double.MAX_VALUE </code><a href="javalang.doc9.html#3573">(&#167;20.10.2)</a>.<p>
<a name="50569"></a>
A compile-time error occurs if a nonzero floating-point literal is too large, so that on rounded conversion to its internal representation it becomes an IEEE 754 infinity. A Java program can represent infinities without producing a compile-time error by using constant expressions such as <code>1f/0f</code> or <code>-1d/0d</code> or by using the predefined constants <code>POSITIVE_INFINITY</code> and <code>NEGATIVE_INFINITY</code> of the classes <code>Float</code> <a href="javalang.doc8.html#14394">(&#167;20.9)</a> and <code>Double</code> <a href="javalang.doc9.html#14390">(&#167;20.10)</a>.<p>
<a name="229608"></a>
A compile-time error occurs if a nonzero floating-point literal is too small, so that, on rounded conversion to its internal representation, it becomes a zero. A compile-time error does not occur if a nonzero floating-point literal has a small value that, on rounded conversion to its internal representation, becomes a nonzero denormalized number.<p>
<a name="26899"></a>
Predefined constants representing Not-a-Number values are defined in the classes <code>Float</code> and <code>Double</code> as <code>Float.NaN</code> <a href="javalang.doc8.html#1411">(&#167;20.9.5)</a> and <code>Double.NaN</code> <a href="javalang.doc9.html#13844">(&#167;20.10.5)</a>.<p>
<a name="26906"></a>
Examples of <code>float</code> literals:<p>
<pre><a name="51298"></a>	1e1f			2.f			.3f		0f		3.14f			6.022137e+23f
</pre><a name="48365"></a>
Examples of <code>double</code> literals:<p>
<pre><a name="48366"></a>	1e1			2.			.3		0.0		3.14			1e-9d		1e137
</pre><a name="23781"></a>
There is no provision for expressing floating-point literals in other than decimal radix. However, method <code>intBitsToFloat</code> <a href="javalang.doc8.html#5683">(&#167;20.9.23)</a> of class <code>Float</code> and method <code>longBitsToDouble</code> <a href="javalang.doc9.html#13864">(&#167;20.10.22)</a> of class <code>Double</code> provide a way to express floating-point values in terms of hexadecimal or octal integer literals. For example, the value of:<p>
<pre><a name="23788"></a>Double.longBitsToDouble(0x400921FB54442D18L)
</pre><a name="231039"></a>
is equal to the value of <code>Math.PI</code> <a href="javalang.doc10.html#36322">(&#167;20.11.2)</a>.
<p><a name="49652"></a>
<h3>3.10.3    Boolean Literals</h3>
<a name="49657"></a>
The <code>boolean</code> type has two values, represented by the literals <code>true</code> and <code>false</code>, 
formed from ASCII letters.
<p><a name="229664"></a>
A <i>boolean literal</i> is always of type <code>boolean</code>.<p>
<ul><pre>
<i>BooleanLiteral:</i> <i>one</i> <i>of<br>
</i><code>	true false
</code></pre></ul><a name="100960"></a>
<h3>3.10.4    Character Literals</h3>
<a name="100964"></a>
A <i>character literal</i> is expressed as a character or an escape sequence, enclosed in 
ASCII single quotes. (The single-quote, or apostrophe, character is <code>\u0027</code>.)
<p><a name="229640"></a>
A character literal is always of type <code>char</code>.<p>
<ul><pre>
<i>CharacterLiteral:<br>
</i>	<code>' </code><i>SingleCharacter</i><code> '<br>
	' </code><i>EscapeSequence</i><code> '
</code>
<i>SingleCharacter:<br>
</i>	<i>InputCharacter</i> but not <code>'</code> or <code>\
</code></pre></ul><a name="100967"></a>
The escape sequences are described in <a href="3.doc.html#101089">&#167;3.10.6</a>.
<p><a name="229112"></a>
As specified in <a href="3.doc.html#231571">&#167;3.4</a>, the characters CR and LF are never an <i>InputCharacter</i>; they are recognized as constituting a <i>LineTerminator</i>.<p>
<a name="100968"></a>
It is a compile-time error for the character following the <i>SingleCharacter</i> or <i>EscapeSequence</i> to be other than a <code>'</code>.<p>
<a name="229137"></a>
It is a compile-time error for a line terminator to appear after the opening <code>'</code> and before the closing <code>'</code>.<p>
<a name="229739"></a>
The following are examples of <code>char</code> literals:<p>
<pre><a name="231014"></a>
'a'
<a name="231016"></a>'%'
<a name="230975"></a>'\t'
<a name="231018"></a>'\\'
<a name="231020"></a>'\''
<a name="231024"></a>'\u03a9'
<a name="231026"></a>'\uFFFF'
<a name="230984"></a>'\177'
<a name="231030"></a>'<img src="chars/capomega.gif">'
<a name="231032"></a>'<img src="chars/circmult.gif">'
</pre><a name="230985"></a>
Because Unicode escapes are processed very early, it is not correct to write <code>'\u000a'</code> for a character literal whose value is linefeed (LF); the Unicode escape <code>\u000a</code> is transformed into an actual linefeed in translation step 1 <a href="3.doc.html#100850">(&#167;3.3)</a> and the linefeed becomes a <i>LineTerminator</i> in step 2 <a href="3.doc.html#231571">(&#167;3.4)</a>, and so the character literal is not valid in step 3. Instead, one should use the escape sequence <code>'\n'</code> <a href="3.doc.html#101089">(&#167;3.10.6)</a>. Similarly, it is not correct to write <code>'\u000d'</code> for a character literal whose value is carriage return (CR). Instead, use <code>'\r'</code>.<p>
<a name="229744"></a>
In C and C++, a character literal may contain representations of more than one character, but the value of such a character literal is implementation-defined. In Java, a character literal always represents exactly one character.<p>
<a name="101083"></a>
<h3>3.10.5    String Literals</h3>
<a name="101084"></a>
A <i>string literal</i> consists of zero or more characters enclosed in double quotes. 
Each character may be represented by an escape sequence.
<p><a name="229653"></a>
A string literal is always of type <code>String</code> (<a href="4.doc.html#26992">&#167;4.3.3</a>, <a href="javalang.doc11.html#14460">&#167;20.12</a>). A string literal always refers to the same instance <a href="4.doc.html#12028">(&#167;4.3.1)</a> of class <code>String</code>.<p>
<ul><pre>
<i>StringLiteral:<br>
</i>	<code>" </code><i>StringCharacters</i><sub><i>opt</i></sub><code> "
</code>
<i>StringCharacters:<br>
</i>	<i>StringCharacter<br>
</i>	<i>StringCharacters</i><code> </code><i>StringCharacter
</i>
<i>StringCharacter:<br>
</i><code>	</code><i>InputCharacter</i> but not <code>"</code> or <code>\<br>
	</code><i>EscapeSequence
</i></pre></ul><a name="22983"></a>
The escape sequences are described in <a href="3.doc.html#101089">&#167;3.10.6</a>.
<p><a name="19350"></a>
As specified in <a href="3.doc.html#231571">&#167;3.4</a>, neither of the characters CR and LF is ever considered to be an <i>InputCharacter</i>; each is recognized as constituting a <i>LineTerminator</i>.<p>
<a name="21405"></a>
It is a compile-time error for a line terminator to appear after the opening <code>"</code> and before the closing matching <code>"</code>. A long string literal can always be broken up into shorter pieces and written as a (possibly parenthesized) expression using the string concatenation operator <code>+</code> <a href="15.doc.html#39990">(&#167;15.17.1)</a>.<p>
<a name="229156"></a>
The following are examples of string literals:<p>
<pre><a name="229157"></a>
"" 							// the empty string
<a name="229158"></a>"\""							// a string containing " alone
<a name="229159"></a>"This is a string"							// a string containing 16 characters
<br><a name="229160"></a>"This is a " +							// actually a string-valued constant expression,
<a name="229161"></a>	"two-line string"						//		formed from two string literals
</pre><a name="25884"></a>
Because Unicode escapes are processed very early, it is not correct to write <code>"\u000a"</code> for a string literal containing a single linefeed (LF); the Unicode escape <code>\u000a</code> is transformed into an actual linefeed in translation step 1 <a href="3.doc.html#100850">(&#167;3.3)</a> and the linefeed becomes a <i>LineTerminator</i> in step 2 <a href="3.doc.html#231571">(&#167;3.4)</a>, and so the string literal is not valid in step 3. Instead, one should write <code>"\n"</code> <a href="3.doc.html#101089">(&#167;3.10.6)</a>. Similarly, it is not correct to write <code>"\u000d"</code> for a string literal containing a single carriage return (CR). Instead use <code>"\r"</code>.<p>
<a name="19369"></a>
Each string literal is a reference <a href="4.doc.html#9317">(&#167;4.3)</a> to an instance (<a href="4.doc.html#12028">&#167;4.3.1</a>, <a href="12.doc.html#44670">&#167;12.5</a>) of class <code>String</code> (<a href="4.doc.html#26992">&#167;4.3.3</a>, <a href="javalang.doc11.html#14460">&#167;20.12</a>). <code>String</code> objects have a constant value. String literals-or, more generally, strings that are the values of constant expressions <a href="15.doc.html#5313">(&#167;15.27)</a>-are "interned" so as to share unique instances, using the method <code>String.intern</code> <a href="javalang.doc11.html#14026">(&#167;20.12.47)</a>.<p>
<a name="231331"></a>
Thus, the test program consisting of the compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a>:<p>
<pre><br><a name="23253"></a>package testPackage;
<br></pre><pre><a name="229782"></a>
class Test {
<a name="23254"></a>	public static void main(String[] args) {
<a name="23255"></a>		String hello = "Hello", lo = "lo";
<a name="229801"></a>		System.out.print((hello == "Hello") + " ");
<a name="229787"></a>		System.out.print((Other.hello == hello) + " ");
<a name="229789"></a>		System.out.print((other.Other.hello == hello) + " ");
<a name="23837"></a>		System.out.print((hello == ("Hel"+"lo")) + " ");
<a name="23845"></a>		System.out.print((hello == ("Hel"+lo)) + " ");
<a name="23275"></a>		System.out.println(hello == ("Hel"+lo).intern());
<a name="23276"></a>	}
<a name="23260"></a>}
<br><a name="229785"></a>class Other { static String hello = "Hello"; }
</pre><a name="229778"></a>
and the compilation unit:
<p><pre><br><a name="229779"></a>package other;
<br><a name="229773"></a>public class Other { static String hello = "Hello"; }
<br></pre><a name="23261"></a>
produces the output:
<p><pre><a name="50713"></a>true true true true false true
</pre><a name="50715"></a>
This example illustrates six points:
<p><ul><a name="229805"></a>
<li>Literal strings within the same class <a href="8.doc.html#3857">(&#167;8)</a> in the same package <a href="7.doc.html#34412">(&#167;7)</a> represent references to the same <code>String</code> object <a href="4.doc.html#12028">(&#167;4.3.1)</a>.
<a name="229807"></a>
<li>Literal strings within different classes in the same package represent references to the same <code>String</code> object.
<a name="229797"></a>
<li>Literal strings within different classes in different packages likewise represent references to the same <code>String</code> object.
<a name="23858"></a>
<li>Strings computed by constant expressions <a href="15.doc.html#5313">(&#167;15.27)</a> are computed at compile time and then treated as if they were literals.
<a name="23859"></a>
<li>Strings computed at run time are newly created and therefore distinct.
<a name="23865"></a>
<li>The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.
</ul><a name="101089"></a>
<h3>3.10.6    Escape Sequences for Character and String Literals</h3>
<a name="230359"></a>
The character and string <i>escape sequences</i> allow for the representation of some 
nongraphic characters as well as the single quote, double quote, and backslash 
characters in character literals <a href="3.doc.html#100960">(&#167;3.10.4)</a> and string literals <a href="3.doc.html#101083">(&#167;3.10.5)</a>.
<p><ul><pre>
<i>EscapeSequence:<br>
</i><code>	\ b			/*&#32;\u0008:&#32;</code>backspace<code>&#32;</code>BS<code>						</code> <code>*/<br>
	\ t			/*&#32;\u0009:&#32;</code>horizontal tab<code>&#32;</code>HT <code>						*/<br>
	\ n			/*&#32;\u000a:&#32;</code>linefeed<code>&#32;</code>LF <code>						*/<br>
	\ f			/*&#32;\u000c:&#32;</code>form feed<code>&#32;</code>FF <code>						*/<br>
	\ r			/*&#32;\u000d:&#32;</code>carriage return<code>&#32;</code>CR <code>						*/<br>
	\ "			/*&#32;\u0022:&#32;</code>double quote				 <code>" 		*/<br>
	\ '			/*&#32;\u0027:&#32;</code>single quote <code>'						 */<br>
	\ \			/*&#32;\u005c:&#32;</code>backslash <code>\						 */<br>
	</code><i>OctalEscape</i><code>			/*&#32;\u0000</code> to <code>\u00ff:&#32;</code>from octal value<code> */
</code>
<i>OctalEscape:<br>
</i>	<code>\ </code><i>OctalDigit<br>
</i><code>	\ </code><i>OctalDigit</i><code> </code><i>OctalDigit<br>
</i><code>	\ </code><i>ZeroToThree</i><code> </code><i>OctalDigit</i><code> </code><i>OctalDigit
</i>
<i>OctalDigit:</i> <i>one</i> <i>of<br>
</i>	<code>0 1 2 3 4 5 6 7
</code>
<i>ZeroToThree:</i> <i>one</i> <i>of<br>
</i>	<code>0 1 2 3
</code></pre></ul><a name="230722"></a>
It is a compile-time error if the character following a backslash in an escape is not an ASCII <code>b</code>, <code>t</code>, <code>n</code>, <code>f</code>, <code>r</code>, <code>"</code>, <code>'</code>, <code>\</code>, <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, or <code>7</code>. The Unicode escape <code>\u</code> is processed earlier <a href="3.doc.html#100850">(&#167;3.3)</a>. (Octal escapes are provided for compatibility with C, but can express only Unicode values <code>\u0000</code> through <code>\u00FF</code>, so Unicode escapes are usually preferred.)<p>
<a name="230717"></a>
<h3>3.10.7    The Null Literal</h3>
<a name="24276"></a>
The null type has one value, the null reference, represented by the literal <code>null</code>, 
which is formed from ASCII characters. A <i>null literal</i> is always of the null type.
<p><ul><pre>
<i>NullLiteral:<br>
</i><code>	null
</code></pre></ul><a name="230752"></a>
<h2>3.11    Separators</h2>
<a name="230757"></a>
The following nine ASCII characters are the Java <i>separators </i>(punctuators):
<p><ul><pre>
<i>Separator:</i> <i>one</i> <i>of<br>
</i>	<code>(	)	{	}	[	]	;	,	.
</code></pre></ul><a name="230663"></a>
<h2>3.12    Operators</h2>
<a name="230669"></a>
The following 37 tokens are the Java <i>operators</i>,<i> </i>formed from ASCII characters:
<p><ul><pre>
<i>Operator:</i> <i>one</i> <i>of<br>
</i><code>	=	&gt;	&lt;	!	~	?	:<br>
	==	&lt;=	&gt;=	!=	&amp;&amp;	||	++	--<br>
	+	-	*	/	&amp;	|	^	%	&lt;&lt;	&gt;&gt;	&gt;&gt;&gt;<br>
	+=	-=	*=	/=	&amp;=	|=	^=	%=	&lt;&lt;=	&gt;&gt;=	&gt;&gt;&gt;=
</code></pre></ul><a name="29585"></a>

<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="2.doc.html">Prev</a> | <a href="4.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>