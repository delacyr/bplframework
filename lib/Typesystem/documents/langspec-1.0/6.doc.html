<html>
<head>
<title>The Java Language Specification
 Names</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="5.doc.html">Prev</a> | <a href="7.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="48086"></a>
<p><strong>
CHAPTER
 6 </strong></p>
<a name="44352"></a>
<h1>Names</h1>
<hr><p>
<a name="10551"></a>
Names are used to refer to entities declared in a Java program. A declared 
entity <a href="6.doc.html#33757">(&#167;6.1)</a> is a package, class type, interface type, member (field or method) of a 
reference type, parameter (to a method, constructor, or exception handler), or 
local variable.
<p><a name="56343"></a>
Names in Java programs are either simple, consisting of a single identifier, or qualified, &#32;consisting of a sequence of identifiers separated by "<code>.</code>" tokens <a href="6.doc.html#31692">(&#167;6.2)</a>.<p>
<a name="56234"></a>
Every name introduced by a declaration has a <i>scope</i> <a href="6.doc.html#33623">(&#167;6.3)</a>, which is the part of the Java program text within which the declared entity can be referred to by a simple name.<p>
<a name="56241"></a>
Packages and reference types (that is, class types, interface types, and array types) have members <a href="6.doc.html#31814">(&#167;6.4)</a>. A member can be referred to using a qualified name <i>N</i><code>.</code><i>x</i>, where <i>N</i> is a simple or qualified name and <i>x</i> is an identifier. If <i>N</i> names a package, then <i>x</i> is a member of that package, which is either a class or interface type or a subpackage. If <i>N</i> names a reference type or a variable of a reference type, then <i>x</i> names a member of that type, which is either a field or a method.<p>
<a name="34249"></a>
In determining the meaning of a name <a href="6.doc.html#20569">(&#167;6.5)</a>, Java uses the context of the occurrence to disambiguate among packages, types, variables, and methods with the same name.<p>
<a name="56266"></a>
Access control <a href="6.doc.html#33916">(&#167;6.6)</a> can be specified in a class, interface, method, or field declaration to control when <i>access</i> to a member is allowed. Access is a different concept from scope; access specifies the part of the Java program text within which the declared entity can be referred to by a qualified name, a field access expression <a href="15.doc.html#41267">(&#167;15.10)</a>, or a method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a> in which the method is not specified by a simple name. The default access is that a member can be accessed anywhere within the package that contains its declaration; other possibilities are <code>public</code>, <code>protected</code>, and <code>private</code>.<p>
<a name="27329"></a>
Fully qualified names <a href="6.doc.html#25430">(&#167;6.7)</a> and naming conventions <a href="6.doc.html#11186">(&#167;6.8)</a> are also discussed in this chapter.<p>
<a name="31249"></a>
The name of a field, parameter, or local variable may be used as an expression <a href="15.doc.html#4984">(&#167;15.13.1)</a>. The name of a method may appear in an expression only as part of a method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a>. The name of a class or interface type may appear in an expression only as part of a class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a>, an array creation expression <a href="15.doc.html#46168">(&#167;15.9)</a>, a cast expression <a href="15.doc.html#238146">(&#167;15.15)</a>, or an <code>instanceof</code> expression <a href="15.doc.html#80289">(&#167;15.19.2)</a>, or as part of a qualified name for a field or method. The name of a package may appear in an expression only as part of a qualified name for a class or interface type.<p>
<a name="33757"></a>
<h2>6.1    Declarations</h2>
<a name="33759"></a>
A <i>declaration</i> introduces an entity into a Java program and includes an identifier 
<a href="3.doc.html#40625">(&#167;3.8)</a> that can be used in a name to refer to this entity. A declared entity is one of 
the following:
<p><ul><a name="60314"></a>
<li>A package, declared in a <code>package</code> declaration <a href="7.doc.html#26619">(&#167;7.4)</a>
<a name="60319"></a>
<li>An imported type, declared in a single-type-import declaration <a href="7.doc.html#26699">(&#167;7.5.1)</a> or a type-import-on-demand declaration <a href="7.doc.html#26725">(&#167;7.5.2)</a>
<a name="27103"></a>
<li>A class, declared in a class type declaration <a href="8.doc.html#15372">(&#167;8.1)</a>
<a name="27107"></a>
<li>An interface, declared in an interface type declaration <a href="9.doc.html#35470">(&#167;9.1)</a>
<a name="27117"></a>
<li>A member of a reference type (<a href="8.doc.html#21831">&#167;8.2</a>, <a href="9.doc.html#32392">&#167;9.2</a>, <a href="10.doc.html#11364">&#167;10.7</a>), one of the following:
<ul>
<a name="20164"></a>
<li>A field, one of the following:
<ul>
<a name="20168"></a>
<li>A field declared in a class type <a href="8.doc.html#40898">(&#167;8.3)</a>
<a name="20172"></a>
<li>A constant field declared in an interface type <a href="9.doc.html#78642">(&#167;9.3)</a>
<a name="20173"></a>
<li>The field <code>length</code>, which is implicitly a member of every array type <a href="10.doc.html#11364">(&#167;10.7)</a>
</ul>
<a name="33764"></a>
<li>A method, one of the following:
<ul>
<a name="38090"></a>
<li>A method (<code>abstract</code> or otherwise) declared in a class type <a href="8.doc.html#40420">(&#167;8.4)</a>
<a name="33944"></a>
<li>A method (always <code>abstract</code>) declared in an interface type <a href="9.doc.html#78651">(&#167;9.4)</a>
</ul>
</ul>
</ul><ul><a name="31380"></a>
<li>A parameter, one of the following:
<ul>
<a name="33773"></a>
<li>A parameter of a method or constructor of a class (<a href="8.doc.html#38698">&#167;8.4.1</a>, <a href="8.doc.html#29488">&#167;8.6.1</a>)
<a name="33775"></a>
<li>A parameter of an <code>abstract</code> method of an interface <a href="9.doc.html#78651">(&#167;9.4)</a>
<a name="31398"></a>
<li>A parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement <a href="14.doc.html#79311">(&#167;14.18)</a>
</ul>
<a name="31392"></a>
<li>A local variable, one of the following:
<ul>
<a name="33776"></a>
<li>A local variable declared in a block <a href="14.doc.html#5920">(&#167;14.3)</a>
<a name="33777"></a>
<li>A local variable declared in a <code>for</code> statement <a href="14.doc.html#24588">(&#167;14.12)</a>
</ul>
</ul><a name="56358"></a>
Constructors <a href="8.doc.html#41652">(&#167;8.6)</a> are also introduced by declarations, but use the name of the 
class in which they are declared rather than introducing a new name.
<p><a name="31692"></a>
<h2>6.2    Names and Identifiers</h2>
<a name="61760"></a>
A <i>name</i> is used to refer to an entity declared in a Java program.
<p><a name="61763"></a>
There are two forms of names: simple names and qualified names. A <i>simple name</i> is a single identifier. A <i>qualified name</i> consists of a name, a "<code>.</code>" token, and an identifier.<p>
<a name="21637"></a>
In determining the meaning of a name <a href="6.doc.html#20569">(&#167;6.5)</a>, the Java language takes into account the context in which the name appears. It distinguishes among contexts where a name must denote (refer to) a package <a href="6.doc.html#22349">(&#167;6.5.3)</a>, a type <a href="6.doc.html#21721">(&#167;6.5.4)</a>, a variable or value in an expression <a href="6.doc.html#21650">(&#167;6.5.5)</a>, or a method <a href="6.doc.html#21652">(&#167;6.5.6)</a>.<p>
<a name="33483"></a>
Not all identifiers in Java programs are a part of a name. Identifiers are also used in the following situations:<p>
<ul><a name="33485"></a>
<li>In declarations <a href="6.doc.html#33757">(&#167;6.1)</a>, where an identifier may occur to specify the name by which the declared entity will be known
<a name="33490"></a>
<li>In field access expressions <a href="15.doc.html#41267">(&#167;15.10)</a>, where an identifier occurs after a "<code>.</code>" token to indicate a member of an object that is the value of an expression or the keyword <code>super</code> that appears before the "<code>.</code>" token
<a name="33491"></a>
<li>In some method invocation expressions <a href="15.doc.html#20448">(&#167;15.11)</a>, where an identifier may occur after a "<code>.</code>" token and before a "<code>(</code>" token to indicate a method to be invoked for an object that is the value of an expression or the keyword <code>super</code> that appears before the "<code>.</code>" token
<a name="33492"></a>
<li>As labels in labeled statements <a href="14.doc.html#78993">(&#167;14.6)</a> and in <code>break</code> <a href="14.doc.html#6842">(&#167;14.13)</a> and <code>continue</code> <a href="14.doc.html#6122">(&#167;14.14)</a> statements that refer to statement labels
</ul><a name="38317"></a>
In the example:
<p><pre><a name="38318"></a>
class Test {
<a name="38319"></a>	public static void main(String[] args) {
<a name="31441"></a>		Class c = System.out.getClass();
<a name="38320"></a>		System.out.println(c.toString().length() +
<a name="31466"></a>								args[0].length() + args.length);
<a name="38324"></a>	}
<a name="38325"></a>}
</pre><a name="61602"></a>
the identifiers <code>Test</code>, <code>main</code>, and the first occurrences of <code>args</code> and <code>c</code> are not names; 
rather, they are used in declarations to specify the names of the declared entities. 
The names <code>String</code>, <code>Class</code>, <code>System.out.getClass,</code> <code>System.out.println</code>, 
<code>c.toString</code>, <code>args</code>, and <code>args.length</code> appear in the example. The first occurrence
of <code>length</code> is not a name, but rather an identifier appearing in a method invocation
expression <a href="15.doc.html#20448">(&#167;15.11)</a>. The second occurrence of <code>length</code> is not a name, but 
rather an identifier appearing in a method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a>.
<p><a name="61609"></a>
The identifiers used in labeled statements and their associated <code>break</code> and <code>continue</code> statements are completely separate from those used in declarations. Thus, the following code is valid:<p>
<pre><a name="38178"></a>
class TestString {
<br><a name="38277"></a>	char[] value;
<br><br><a name="38278"></a>	int offset, count;
<br><a name="38262"></a>	int indexOf(TestString str, int fromIndex) {
<a name="38179"></a>		char[] v1 = value, v2 = str.value;
<a name="38309"></a>		int max = offset + (count - str.count);
<a name="31499"></a>		int start = offset + ((fromIndex &lt; 0) ? 0 : fromIndex);
<a name="38310"></a>	i:
<a name="38312"></a>		for (int i = start; i &lt;= max; i++)<br>
		{
<a name="38184"></a>			int n = str.count, j = i, k = str.offset;
<a name="38187"></a>			while (n-- != 0) {
<a name="38188"></a>				if (v1[j++] != v2[k++])
<a name="38189"></a>					continue i;
<a name="38191"></a>			} 
<a name="38241"></a>			return i - offset;
<a name="38251"></a>		}
<a name="38194"></a>		return -1;
<a name="38266"></a>	}
<a name="38274"></a>}
</pre><a name="54045"></a>
This code was taken from a version of the class <code>String</code> and its method <code>indexOf</code> 
<a href="javalang.doc11.html#30903">(&#167;20.12.26)</a>, where the label was originally called <code>test</code>. Changing the label to 
have the same name as the local variable <code>i</code> does not hide the label in the scope of 
the declaration of <code>i</code>. The identifier <code>max</code> could also have been used as the statement 
label; the label would not hide the local variable <code>max</code> within the labeled statement.
<p><a name="33623"></a>
<h2>6.3    Scope of a Simple Name</h2>
<a name="34028"></a>
The <i>scope</i> of a declaration is the region of the program within which the entity 
declared by the declaration can be referred to using a simple name:
<p><ul><a name="56405"></a>
<li>The scope of a package, as introduced by a <code>package</code> declaration, is determined by the host system <a href="7.doc.html#13180">(&#167;7.4.3)</a>. All Java code is within the scope of the standard package named <code>java</code>, so the package <code>java</code> can always be referred to by Java code.
<a name="31532"></a>
<li>The scope of a type imported by a single-type-import declaration <a href="7.doc.html#26699">(&#167;7.5.1)</a> or type-import-on-demand declaration <a href="7.doc.html#26725">(&#167;7.5.2)</a> is all the class and interface type declarations <a href="7.doc.html#26783">(&#167;7.6)</a> in the compilation unit in which the import declaration appears.
<a name="56422"></a>
<li>The scope of a type introduced by a class type declaration <a href="8.doc.html#39196">(&#167;8.1.1)</a> or interface type declaration <a href="9.doc.html#39713">(&#167;9.1.1)</a> is the declarations of all class and interface types in all the compilation units <a href="7.doc.html#40031">(&#167;7.3)</a> of the package in which it is declared.
<a name="19824"></a>
<li>The scope of a member declared in or inherited by a class type <a href="8.doc.html#21831">(&#167;8.2)</a> or interface type <a href="9.doc.html#32392">(&#167;9.2)</a> is the entire declaration of the class or interface type. The declaration of a member needs to appear before it is used only when the use is in a field initialization expression (<a href="8.doc.html#24510">&#167;8.3.2</a>, <a href="12.doc.html#44630">&#167;12.4.2</a>, <a href="12.doc.html#44670">&#167;12.5</a>). This means that a compile-time error results from the test program:
</ul><pre><a name="19834"></a>
	class Test {
<a name="19835"></a>		int i = j;				// compile-time error: incorrect forward reference
<a name="19836"></a>		int j = 1;
<a name="19837"></a>	}
</pre><ul><a name="19838"></a>
<br><br>whereas the following example compiles without error:
</ul><pre><a name="19839"></a>
	class Test {
<a name="19840"></a>		Test() { k = 2; }
<a name="19841"></a>		int j = 1;
<a name="19842"></a>		int i = j;
<a name="19843"></a>		int k;
<a name="19844"></a>	}
</pre><ul><a name="19848"></a>
<br><br>even though the constructor <a href="8.doc.html#41652">(&#167;8.6)</a> for <code>Test</code> refers to the field <code>k</code> that is declared three lines later.
</ul><ul><a name="31556"></a>
<li>The scope of a parameter of a method <a href="8.doc.html#38698">(&#167;8.4.1)</a> is the entire body of the method.
</ul><ul><a name="31566"></a>
<li>The scope of a parameter of a constructor <a href="8.doc.html#29488">(&#167;8.6.1)</a> is the entire body of the constructor.
<a name="19941"></a>
<li>The scope of a local variable declaration in a block <a href="14.doc.html#32644">(&#167;14.3.2)</a> is the rest of the block in which the declaration appears, starting with its own initializer <a href="14.doc.html#5920">(&#167;14.3)</a> and including any further declarators to the right in the local variable declaration statement.
<a name="56450"></a>
<li>The scope of a local variable declared in the <i>ForInit</i> part of a <code>for</code> statement <a href="14.doc.html#24588">(&#167;14.12)</a> includes all of the following:
<ul>
<a name="23092"></a>
<li>Its own initializer
<a name="56451"></a>
<li>Any further declarators to the right in the <i>ForInit</i> part of the <code>for</code> statement
<a name="56452"></a>
<li>The <i>Expression</i> and <i>ForUpdate</i> parts of the <code>for</code> statement
<a name="56453"></a>
<li>The contained <i>Statement</i>
</ul>
<a name="56454"></a>
<li>The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement <a href="14.doc.html#79311">(&#167;14.18)</a> is the entire block associated with the <code>catch</code>.
</ul><a name="56458"></a>
These rules imply that declarations of class and interface types need not appear 
before uses of the types.
<p><a name="20278"></a>
In the example:<p>
<pre><a name="56459"></a>package points;
</pre><pre><a name="56460"></a>
class Point {
<a name="56461"></a>	int x, y;
<a name="56462"></a>	PointList list;
<a name="56463"></a>	Point next;
<a name="56464"></a>}
<a name="56465"></a>
class PointList {
<a name="56466"></a>	Point first;
<a name="56468"></a>}
</pre><a name="34047"></a>
the use of <code>PointList</code> in class <code>Point</code> is correct, because the scope of the class type 
name <code>PointList</code> includes both class <code>Point</code> and class <code>PointList</code>, as well as any 
other type declarations in other compilation units of package <code>points</code>.
<p><a name="34133"></a>
<h3>6.3.1    Hiding Names</h3>
<a name="34051"></a>
Some declarations may be hidden <a href="6.doc.html#34133">(&#167;6.3.1)</a> in part of their scope by another declaration
of the same name, in which case a simple name cannot be used to refer to 
the declared entity.
<p><a name="62323"></a>
The example:<p>
<pre><a name="34052"></a>
class Test {
<a name="34053"></a>	static int x = 1;
<a name="34054"></a>	public static void main(String[] args) {
<a name="34055"></a>		int x = 0;
<a name="34056"></a>		System.out.print("x=" + x);
<a name="34057"></a>		System.out.println(", Test.x=" + Test.x);
<a name="34058"></a>	}
<a name="34059"></a>}
</pre><a name="34060"></a>
produces the output:
<p><pre><a name="34061"></a>x=0, Test.x=1
</pre><a name="34062"></a>
This example declares:
<p><ul><a name="62327"></a>
<li>a class <code>Test</code>
<a name="62331"></a>
<li>a class (<code>static</code>) variable <code>x</code> that is a member of the class <code>Test</code>
<a name="62332"></a>
<li>a class method <code>main</code> that is a member of the class <code>Test</code>
<a name="62333"></a>
<li>a parameter <code>args</code> of the <code>main</code> method
<a name="62334"></a>
<li>a local variable <code>x</code> of the <code>main</code> method
</ul><a name="34066"></a>
Since the scope of a class variable includes the entire body of the class <a href="8.doc.html#21831">(&#167;8.2)</a> the class variable <code>x</code> would normally be available throughout the entire body of the method <code>main</code>. In this example, however, the class variable <code>x</code> is hidden within the body of the method <code>main</code> by the declaration of the local variable <code>x</code>.<p>
<a name="62312"></a>
A local variable has as its scope the rest of the block in which it is declared <a href="14.doc.html#32644">(&#167;14.3.2)</a>; in this case this is the rest of the body of the <code>main</code> method, namely its initializer "<code>0</code>" and the invocations of <code>print</code> and <code>println</code>.<p>
<a name="62314"></a>
This means that:<p>
<ul><a name="62313"></a>
<li>The expression "<code>x</code>" in the invocation of <code>print</code> refers to (denotes) the value of the local variable <code>x</code>.
<a name="62320"></a>
<li>The invocation of <code>println</code> uses a qualified name <a href="6.doc.html#33916">(&#167;6.6)</a> <code>Test.x</code>, which uses the class type name <code>Test</code> to access the class variable <code>x</code>, because the declaration of <code>Test.x</code> is hidden at this point and cannot be referred to by its simple name.
</ul><a name="62307"></a>
If the standard naming conventions <a href="6.doc.html#11186">(&#167;6.8)</a> are followed, then hiding that would make the identification of separate naming contexts matter should be rare. The following contrived example involves hiding because it does not follow the standard naming conventions:<p>
<pre><a name="34080"></a>
class Point { int x, y; }
<a name="34083"></a>
class Test {
<a name="34084"></a>
	static Point Point(int x, int y) {
<a name="34085"></a>		Point p = new Point();
<a name="34086"></a>		p.x = x; p.y = y;
<a name="34087"></a>		return p;
<a name="34088"></a>	}
<br><a name="34089"></a>
	public static void main(String[] args) {
<a name="34090"></a>		int Point;
<a name="34091"></a>		Point[] pa = new Point[2];
<a name="34092"></a>		for (Point = 0; Point &lt; 2; Point++) {
<a name="34093"></a>			pa[Point] = new Point();
<a name="34094"></a>			pa[Point].x = Point;
<a name="34095"></a>			pa[Point].y = Point;
<a name="34096"></a>		}
<a name="34097"></a>		System.out.println(pa[0].x + "," + pa[0].y);
<a name="34098"></a>		System.out.println(pa[1].x + "," + pa[1].y);
<a name="34099"></a>		Point p = Point(3, 4);
<a name="34100"></a>		System.out.println(p.x + "," + p.y);
<a name="34101"></a>	}
<br><a name="34102"></a>}
</pre><a name="34103"></a>
This compiles without error and executes to produce the output:
<p><pre><a name="34104"></a>
0,0
<a name="34105"></a>1,1<br>
3,4
</pre><a name="34106"></a>
Within the body of <code>main</code>, the lookups of <code>Point</code> find different declarations depending
on the context of the use:
<p><ul><a name="34107"></a>
<li>In the expression "<code>new</code> <code>Point[2]</code>", the two occurrences of the class instance creation expression "<code>new</code> <code>Point()</code>", and at the start of three different local variable declaration statements, the <code>Point</code> is a <i>TypeName</i> <a href="6.doc.html#21721">(&#167;6.5.4)</a> and denotes the class type <code>Point</code> in each case.
<a name="34268"></a>
<li>In the method invocation expression "<code>Point(3,</code> <code>4)</code>" the occurrence of <code>Point</code> is a <i>MethodName </i><a href="6.doc.html#21652">(&#167;6.5.6)</a> and denotes the class (<code>static</code>) method <code>Point</code>.
<a name="34114"></a>
<li>All other names are <i>ExpressionName</i>s <a href="6.doc.html#21650">(&#167;6.5.5)</a> and refer to the local variable <code>Point</code>.
</ul><a name="34119"></a>
The example:
<p><pre><a name="34120"></a>import java.util.*;
</pre><pre><a name="34121"></a>
class Vector {
<a name="34122"></a>	int val[] = { 1 , 2 };
<a name="34123"></a>}
<br><a name="34124"></a>
class Test {
<a name="34125"></a>	public static void main(String[] args) {
<a name="34126"></a>		Vector v = new Vector();
<a name="34127"></a>		System.out.println(v.val[0]);
<a name="34128"></a>	}
<a name="34129"></a>}
</pre><a name="34130"></a>
compiles and prints:
<p><pre><a name="34131"></a>1
</pre><a name="56469"></a>
using the class <code>Vector</code> declared here in preference to class <code>java.util.Vector</code> 
that might be imported on demand.
<p><a name="31814"></a>
<h2>6.4    Members and Inheritance</h2>
<a name="23209"></a>
Packages and reference types have <i>members</i>. The members of a package <a href="7.doc.html#34412">(&#167;7)</a> are 
subpackages <a href="7.doc.html#26535">(&#167;7.1)</a> and all the class <a href="8.doc.html#3857">(&#167;8)</a> and interface <a href="9.doc.html#238678">(&#167;9)</a> types declared in all 
the compilation units <a href="7.doc.html#40031">(&#167;7.3)</a> of the package. The members of a reference type 
<a href="4.doc.html#9317">(&#167;4.3)</a> are fields (<a href="8.doc.html#40898">&#167;8.3</a>, <a href="9.doc.html#78642">&#167;9.3</a>, <a href="10.doc.html#11364">&#167;10.7</a>) and methods (<a href="8.doc.html#40420">&#167;8.4</a>, <a href="9.doc.html#78651">&#167;9.4</a>). Members are either 
declared in the type, or <i>inherited </i>because they are accessible members of a superclass
or superinterface which are neither hidden nor overridden <a href="8.doc.html#228745">(&#167;8.4.6)</a>.
<p><a name="56531"></a>
This section provides an overview of the members of packages and reference types here, as background for the discussion of qualified names and the determination of the meaning of names. For a complete description of membership, see <a href="7.doc.html#26535">&#167;7.1</a>, <a href="8.doc.html#21831">&#167;8.2</a>, <a href="9.doc.html#32392">&#167;9.2</a>, and <a href="10.doc.html#11364">&#167;10.7</a>.<p>
<a name="34993"></a>
<h3>6.4.1    The Members of a Package</h3>
<a name="23133"></a>
A member of a package <a href="7.doc.html#34412">(&#167;7)</a> is a subpackage <a href="7.doc.html#26535">(&#167;7.1)</a>, or a class <a href="8.doc.html#3857">(&#167;8)</a> or interface 
<a href="9.doc.html#238678">(&#167;9)</a> type declared in a compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a> of the package.
<p><a name="56555"></a>
In general, the subpackages of a package are determined by the host system <a href="7.doc.html#37758">(&#167;7.2)</a>. However, the standard package <code>java</code> always includes the subpackages <code>lang</code>, <code>util</code>, <code>io</code>, and <code>net</code> and may include other subpackages. No two distinct members of the same package may have the same simple name <a href="7.doc.html#26535">(&#167;7.1)</a>, but members of different packages may have the same simple name. For example, it is possible to declare a package:<p>
<pre><a name="34982"></a>package vector;
<a name="34983"></a>public class Vector { Object[] vec; }
</pre><a name="34986"></a>
that has as a member a <code>public</code> class named <code>Vector</code>, even though the standard 
package <code>java.util</code> also declares a class named <code>Vector</code>. These two class types 
are different, reflected by the fact that they have different fully qualified names 
<a href="6.doc.html#25430">(&#167;6.7)</a>. The fully qualified name of this example <code>Vector</code> is <code>vector.Vector</code>, 
whereas <code>java.util.Vector</code> is the fully qualified name of the standard <code>Vector</code> 
class. Because the package <code>vector</code> contains a class named <code>Vector</code>, it cannot also 
have a subpackage named <code>Vector</code>.
<p><a name="34757"></a>
<h3>6.4.2    The Members of a Class Type</h3>
<a name="34765"></a>
The members of a class type <a href="8.doc.html#21831">(&#167;8.2)</a> are fields and methods. The members of a 
class type are all of the following:
<p><ul><a name="34768"></a>
<li>Members inherited from its direct superclass <a href="8.doc.html#21723">(&#167;8.1.3)</a>, if it has one (the class <code>Object</code> has no direct superclass)
<a name="34777"></a>
<li>Members inherited from any direct superinterfaces <a href="8.doc.html#34031">(&#167;8.1.4)</a>
<a name="34778"></a>
<li>Members declared in the body of the class <a href="8.doc.html#18988">(&#167;8.1.5)</a>
</ul><a name="62337"></a>
Constructors <a href="8.doc.html#41652">(&#167;8.6)</a> are not members.
<p><a name="31685"></a>
There is no restriction against a field and a method of a class type having the same simple name.<p>
<a name="56650"></a>
A class may have two or more fields with the same simple name if they are declared in different interfaces and inherited. An attempt to refer to any of the fields by its simple name results in a compile-time error (<a href="6.doc.html#54547">&#167;6.5.6.2</a>, <a href="8.doc.html#21831">&#167;8.2</a>).<p>
<a name="31689"></a>
In the example:<p>
<pre><a name="25284"></a>
interface Colors {
<a name="25285"></a>	int WHITE = 0, BLACK = 1;
<a name="25286"></a>}
<a name="31681"></a>
interface Separates {
<a name="25287"></a>	int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;
<a name="25288"></a>}
<a name="25289"></a>
class Test implements Colors, Separates {
<a name="25290"></a>	public static void main(String[] args) {
<a name="25291"></a>		System.out.println(BLACK); // compile-time error: ambiguous
<a name="25292"></a>	}
<a name="25293"></a>}
</pre><a name="25294"></a>
the name <code>BLACK</code> in the method <code>main</code> is ambiguous, because class <code>Test</code> has two 
members named <code>BLACK</code>, one inherited from <code>Colors</code> and one from <code>Separates</code>.
<p><a name="23306"></a>
A class type may have two or more methods with the same simple name if the methods have different signatures <a href="8.doc.html#38649">(&#167;8.4.2)</a>, that is, if they have different numbers of parameters or different parameter types in at least one parameter position. Such a method member name is said to be <i>overloaded</i>.<p>
<a name="31700"></a>
A class type may contain a declaration for a method with the same name and the same signature as a method that would otherwise be inherited from a superclass or superinterface. In this case, the method of the superclass or superinterface is not inherited. If the method not inherited is <code>abstract</code>, then the new declaration is said to <i>implement</i> it; if the method not inherited is not <code>abstract</code>, then the new declaration is said to <i>override</i> it.<p>
<a name="31699"></a>
In the example:<p>
<pre><a name="38566"></a>
class Point {
<a name="38567"></a>	float x, y;
<a name="38568"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<a name="31704"></a>	void move(float dx, float dy) { x += dx; y += dy; }
<a name="31705"></a>	public String toString() { return "("+x+","+y+")"; }
<a name="31706"></a>}
</pre><a name="31707"></a>
the class <code>Point</code> has two members that are methods with the same name, <code>move</code>. 
The overloaded <code>move</code> method of class <code>Point</code> chosen for any particular method 
invocation is determined at compile time by the overloading resolution procedure 
given in <a href="15.doc.html#20448">&#167;15.11</a>.
<p><a name="62345"></a>
In this example, the members of the class <code>Point</code> are the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>Point</code>, the two declared <code>move</code> methods, the declared <code>toString</code> method, and the members that <code>Point</code> inherits from its implicit direct superclass <code>Object</code> <a href="4.doc.html#11055">(&#167;4.3.2)</a>, such as the method <code>hashCode</code> <a href="javalang.doc1.html#13784">(&#167;20.1.4)</a>. Note that <code>Point</code> does not inherit the <code>toString</code> method <a href="javalang.doc1.html#1152">(&#167;20.1.2)</a> of class <code>Object</code> because that method is overridden by the declaration of the <code>toString</code> method in class <code>Point</code>.<p>
<a name="34849"></a>
<h3>6.4.3    The Members of an Interface Type</h3>
<a name="31765"></a>
The members of an interface type <a href="9.doc.html#32392">(&#167;9.2)</a> are fields and methods. The members of 
an interface are all of the following:
<p><ul><a name="31784"></a>
<li>Members inherited from any direct superinterfaces <a href="9.doc.html#78598">(&#167;9.1.3)</a>
<a name="31788"></a>
<li>Members declared in the body of the interface <a href="9.doc.html#236431">(&#167;9.1.4)</a>
</ul><a name="31831"></a>
An interface may have two or more fields with the same simple name if they are declared in different interfaces and inherited. An attempt to refer to any such field by its simple name results in a compile-time error (<a href="6.doc.html#22022">&#167;6.5.5.1</a>, <a href="9.doc.html#32392">&#167;9.2</a>).<p>
<a name="61795"></a>
In the example:<p>
<pre><a name="20498"></a>
interface Colors {
<a name="20499"></a>	int WHITE = 0, BLACK = 1;
<a name="20500"></a>}
<a name="31851"></a>
interface Separates {
<a name="20501"></a>	int CYAN = 0, MAGENTA = 1, YELLOW = 2, BLACK = 3;
<a name="20502"></a>}
<a name="35253"></a>interface ColorsAndSeparates extends Colors, Separates {<br>
	int DEFAULT = BLACK;								 	// compile-time error: ambiguous<br>
}
</pre><a name="35254"></a>
the members of the interface <code>ColorsAndSeparates</code> include those members 
inherited from <code>Colors</code> and those inherited from <code>Separates</code>, namely <code>WHITE</code>, 
<code>BLACK</code> (first of two), <code>CYAN</code>, <code>MAGENTA</code>, <code>YELLOW</code>, and <code>BLACK</code> (second of two). The 
member name <code>BLACK</code> is ambiguous in the interface <code>ColorsAndSeparates</code>.
<p><a name="27725"></a>
<h3>6.4.4    The Members of an Array Type</h3>
<a name="36005"></a>
The members of an array type <a href="10.doc.html#11364">(&#167;10.7)</a> are all of the following:
<p><ul><a name="23342"></a>
<li>Members inherited from its implicit superclass <code>Object</code> (<a href="4.doc.html#11055">&#167;4.3.2</a>, <a href="javalang.doc1.html#46442">&#167;20.1</a>)
<a name="23344"></a>
<li>The field <code>length</code>, which is a constant (<code>final</code>) field of every array; its type is <code>int</code> and it contains the number of components of the array
</ul><a name="27727"></a>
The example:
<p><pre><a name="27728"></a>
class Test {
<a name="27729"></a>	public static void main(String[] args) {
<a name="27730"></a>		int[] ia = new int[3];
<a name="27731"></a>		int[] ib = new int[6];
<a name="27733"></a>		System.out.println(ia.getClass() == ib.getClass());
<a name="31873"></a>		System.out.println("ia has length=" + ia.length);
<a name="27734"></a>	}
<a name="27735"></a>}
</pre><a name="27736"></a>
produces the output:
<p><pre><a name="31879"></a>
true
<a name="27737"></a>ia has length=3
</pre><a name="27739"></a>
This example uses the method <code>getClass</code> inherited from class <code>Object</code> and the 
field <code>length</code>. The result of the comparison of the <code>Class</code> objects in the second 
<code>println</code> demonstrates that all arrays whose components are of type <code>int</code> are 
instances of the same array type, which is <code>int[]</code>.
<p><a name="20569"></a>
<h2>6.5    Determining the Meaning of a Name</h2>
<a name="22344"></a>
The meaning of a name in Java depends on the context in which it is used. The 
determination of the meaning of a name requires three steps. First, context causes 
a name syntactically to fall into one of five categories: <i>PackageName</i>, <i>TypeName</i>, 
<i>ExpressionName</i>, <i>MethodName</i>, or <i>AmbiguousName</i>. Second, a name that is initially
classified by its context as an <i>AmbiguousName</i> is then reclassified by certain 
scoping rules to be a <i>PackageName</i>, <i>TypeName</i>, or <i>ExpressionName</i>. Third, the 
resulting category then dictates the final determination of the meaning of the name 
(or a compilation error if the name has no meaning).
<p><ul><pre>
<i>PackageName:<br>
</i>	<i>Identifier<br>
</i>	<i>PackageName</i><code> . </code><i>Identifier
</i>
<i>TypeName:<br>
</i>	<i>Identifier<br>
</i>	<i>PackageName</i><code> . </code><i>Identifier
</i>
<i>ExpressionName:<br>
</i>	<i>Identifier<br>
</i>	<i>AmbiguousName</i><code> . </code><i>Identifier
</i>
<i>MethodName:<br>
</i>	<i>Identifier<br>
</i>	<i>AmbiguousName</i><code> . </code><i>Identifier
</i>
<i>AmbiguousName:<br>
</i>	<i>Identifier<br>
</i>	<i>AmbiguousName</i><code> . </code><i>Identifier
</i></pre></ul><a name="32744"></a>
Java's use of context helps to minimize name conflicts between entities of different kinds. Such conflicts will be rare if the naming conventions described in <a href="6.doc.html#11186">&#167;6.8</a> are followed. Nevertheless, conflicts may arise unintentionally as types developed by different programmers or different organizations evolve. For example, types, methods, and fields may have the same name. Java never has trouble distinguishing between a method and a field with the same name, since the context of a use always tells whether a method or a field is intended.<p>
<a name="32740"></a>
<h3>6.5.1    Syntactic Classification of a Name According to Context</h3>
<a name="32741"></a>
A name is syntactically classified as a <i>PackageName</i> in these contexts:
<p><ul><a name="32159"></a>
<li>In a package declaration <a href="7.doc.html#26619">(&#167;7.4)</a>
<a name="32164"></a>
<li>In a type-import-on-demand declaration <a href="7.doc.html#26725">(&#167;7.5.2)</a>
<a name="32492"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>PackageName</i>
<a name="32494"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>TypeName</i>
</ul><a name="32149"></a>
A name is syntactically classified as a <i>TypeName</i> in these contexts:
<p><ul><a name="32174"></a>
<li>In a single-type-import declaration <a href="7.doc.html#26699">(&#167;7.5.1)</a>
<a name="32178"></a>
<li>In an <code>extends</code> clause in a class declaration <a href="8.doc.html#21723">(&#167;8.1.3)</a>
<a name="32182"></a>
<li>In an <code>implements</code> clause in a class declaration <a href="8.doc.html#34031">(&#167;8.1.4)</a>
<a name="34302"></a>
<li>In an <code>extends</code> clause in an interface declaration <a href="9.doc.html#78598">(&#167;9.1.3)</a>
<a name="32290"></a>
<li>As a <i>Type</i> (or the part of a <i>Type</i> that remains after all brackets are deleted) in any of the following contexts:
<ul>
<a name="32310"></a>
<li>In a field declaration (<a href="8.doc.html#40898">&#167;8.3</a>, <a href="9.doc.html#78642">&#167;9.3</a>)
<a name="32322"></a>
<li>As the result type of a method (<a href="8.doc.html#40420">&#167;8.4</a>, <a href="9.doc.html#78651">&#167;9.4</a>)
<a name="32355"></a>
<li>As the type of a formal parameter of a method or constructor (<a href="8.doc.html#38698">&#167;8.4.1</a>, <a href="8.doc.html#29488">&#167;8.6.1</a>, <a href="9.doc.html#78651">&#167;9.4</a>)
<a name="32266"></a>
<li>As the type of an exception that can be thrown by a method or constructor (<a href="8.doc.html#78323">&#167;8.4.4</a>, <a href="8.doc.html#244611">&#167;8.6.4</a>, <a href="9.doc.html#78651">&#167;9.4</a>)
<a name="32224"></a>
<li>As the type of a local variable <a href="14.doc.html#5920">(&#167;14.3)</a>
<a name="32225"></a>
<li>As the type of an exception parameter in a <code>catch</code> clause of a <code>try</code> statement <a href="14.doc.html#79311">(&#167;14.18)</a>
<a name="32233"></a>
<li>As the class type of an instance that is to be created in a class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a>
<a name="32240"></a>
<li>As the element type of an array to be created in an array creation expression <a href="15.doc.html#46168">(&#167;15.9)</a>
<a name="32244"></a>
<li>As the type mentioned in the cast operator of a cast expression <a href="15.doc.html#238146">(&#167;15.15)</a>
<a name="32248"></a>
<li>As the type that follows the <code>instanceof</code> relational operator <a href="15.doc.html#80289">(&#167;15.19.2)</a>
</ul>
</ul><a name="32435"></a>
A name is syntactically classified as an <i>ExpressionName</i> in these contexts:
<p><ul><a name="32464"></a>
<li>As the array reference expression in an array access expression <a href="15.doc.html#239587">(&#167;15.12)</a>
<a name="32459"></a>
<li>As a <i>PostfixExpression</i> <a href="15.doc.html#36254">(&#167;15.13)</a>
<a name="32477"></a>
<li>As the left-hand operand of an assignment operator <a href="15.doc.html#5281">(&#167;15.25)</a>
</ul><a name="32437"></a>
A name is syntactically classified as a <i>MethodName</i> in this context:
<p><ul><a name="32480"></a>
<li>Before the "<code>(</code>" in a method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a>
</ul><a name="32439"></a>
A name is syntactically classified as an <i>AmbiguousName</i> in these contexts:
<p><ul><a name="32496"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>ExpressionName</i>
<a name="32499"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>MethodName</i>
<a name="32501"></a>
<li>To the left of the "<code>.</code>" in a qualified <i>AmbiguousName</i>
</ul><a name="32725"></a>
<h3>6.5.2    Reclassification of Contextually Ambiguous Names</h3>
<a name="32133"></a>
An <i>AmbiguousName</i> is then reclassified as follows:
<p><ul><a name="32505"></a>
<li>If the <i>AmbiguousName</i> is a simple name, consisting of a single <i>Identifier</i>:
<ul>
<a name="32544"></a>
<li>If the <i>Identifier</i> appears within the scope <a href="6.doc.html#33623">(&#167;6.3)</a> of a local variable declaration <a href="14.doc.html#5920">(&#167;14.3)</a> or parameter declaration (<a href="8.doc.html#38698">&#167;8.4.1</a>, <a href="8.doc.html#29488">&#167;8.6.1</a>, <a href="14.doc.html#79311">&#167;14.18</a>) with that name, then the <i>AmbiguousName</i> is reclassified as an <i>ExpressionName</i>.
<a name="32569"></a>
<li>Otherwise, consider the class or interface <i>C</i> within whose declaration the <i>Identifier</i> occurs. If <i>C</i> has one or more fields with that name, which may be either declared within it or inherited, then the <i>AmbiguousName</i> is reclassified as an <i>ExpressionName</i>.
<a name="32843"></a>
<li>Otherwise, if a type of that name is declared in the compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a> containing the <i>Identifier</i>, either by a single-type-import declaration <a href="7.doc.html#26699">(&#167;7.5.1)</a> or by a class or interface type declaration <a href="7.doc.html#26783">(&#167;7.6)</a>, then the <i>AmbiguousName</i> is reclassified as a <i>TypeName</i>.
<a name="32853"></a>
<li>Otherwise, if a type of that name is declared in another compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a> of the package <a href="7.doc.html#26535">(&#167;7.1)</a> of the compilation unit containing the <i>Identifier</i>, &#32;then the <i>AmbiguousName</i> is reclassified as a <i>TypeName</i>.
<a name="32860"></a>
<li>Otherwise, if a type of that name is declared by exactly one type-import-on-demand declaration <a href="7.doc.html#26725">(&#167;7.5.2)</a> of the compilation unit containing the <i>Identifier</i>, &#32;then the <i>AmbiguousName</i> is reclassified as a <i>TypeName</i>.
<a name="32864"></a>
<li>Otherwise, if a type of that name is declared by more than one type-import-on-demand declaration of the compilation unit containing the <i>Identifier</i>, then a compile-time error results.
<a name="32535"></a>
<li>Otherwise, the <i>AmbiguousName</i> is reclassified as a <i>PackageName</i>. A later step determines whether or not a package of that name actually exists.
</ul>
<a name="32506"></a>
<li>If the <i>AmbiguousName</i> is a qualified name, consisting of a name, a "<code>.</code>", and an <i>Identifier</i>, then the name to the left of the "<code>.</code>" is first reclassified, for it is itself an <i>AmbiguousName</i>. There is then a choice:
<ul>
<a name="32509"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as a <i>PackageName</i>, then there is a further choice:
<ul>
<a name="32700"></a>
<li>If there is a package whose name is the name to the left of the "<code>.</code>" and that package contains a declaration of a type whose name is the same as the <i>Identifier</i>, then this <i>AmbiguousName</i> is reclassified as a <i>TypeName</i>.
<a name="32713"></a>
<li>Otherwise, this <i>AmbiguousName</i> is reclassified as a <i>PackageName</i>. A later step determines whether or not a package of that name actually exists.
</ul>
<a name="32511"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as a <i>TypeName</i>, then this <i>AmbiguousName</i> is reclassified as an <i>ExpressionName</i>.
<a name="32513"></a>
<li>If the name to the left of the "<code>.</code>" is reclassified as an <i>ExpressionName</i>, then this <i>AmbiguousName</i> is reclassified as an <i>ExpressionName</i>.
</ul>
</ul><a name="60456"></a>
As an example, consider the following contrived "library code":<p>
<pre><br><a name="60457"></a>package ORG.rpgpoet;
<br><br><a name="60459"></a>import java.util.Random;
<br><a name="60458"></a>interface Music { Random[] wizards = new Random[4]; }
</pre><a name="60464"></a>
and then consider this example code in another package:
<p><pre><br><a name="60521"></a>package bazola;
<br></pre><pre><a name="60467"></a>
class Gabriel {
<a name="60466"></a>	static int n = ORG.rpgpoet.Music.wizards.length;
<a name="60465"></a>}
</pre><a name="60483"></a>
First of all, the name <code>ORG.rpgpoet.Music.wizards.length</code> is classified as an 
<i>ExpressionName</i> because it functions as a <i>PostfixExpression</i>. Therefore, each of 
the names:
<p><pre><a name="60488"></a>
ORG.rpgpoet.Music.wizards
<a name="60490"></a>ORG.rpgpoet.Music
<a name="60492"></a>ORG.rpgpoet
<a name="60494"></a>ORG
</pre><a name="60515"></a>
is initially classified as an <i>AmbiguousName</i>. These are then reclassified:
<p><ul><a name="60526"></a>
<li>Assuming that there is no class or interface named <code>ORG</code> in any other compilation unit of package <code>bazola</code>, then the simple name <code>ORG</code> is reclassified as a <i>PackageName</i>.
<a name="60530"></a>
<li>Next, assuming that there is no class or interface named <code>rpgpoet</code> in any compilation unit of package <code>ORG</code> (and we know that there is no such class or interface because package <code>ORG</code> has a subpackage named <code>rpgpoet</code>), the qualified name <code>ORG.rpgpoet</code> is reclassified as a <i>PackageName</i>.
<a name="60542"></a>
<li>Next, because package <code>ORG.rpgpoet</code> has an interface type named <code>Music</code>, the qualified name <code>ORG.rpgpoet.Music</code> is reclassified as a <i>TypeName</i>.
<a name="60540"></a>
<li>Finally, because the name <code>ORG.rpgpoet.Music</code> is a <i>TypeName</i>, the qualified name <code>ORG.rpgpoet.Music.wizards</code> is reclassified as an <i>ExpressionName</i>.
</ul><a name="22349"></a>
<h3>6.5.3    Meaning of Package Names</h3>
<a name="32757"></a>
The meaning of a name classified as a <i>PackageName</i> is determined as follows.
<p><a name="22481"></a>
<h4>6.5.3.1    Simple Package Names</h4>
<a name="21719"></a>
If a package name consists of a single <i>Identifier</i>, then this identifier denotes a top-
level package named by that identifier. If no package of that name is accessible, as 
determined by the host system <a href="7.doc.html#13180">(&#167;7.4.3)</a>, then a compile-time error occurs.
<p><a name="22482"></a>
<h4>6.5.3.2    Qualified Package Names</h4>
<a name="21727"></a>
If a package name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> must also be a package name. The 
package name <i>Q</i><code>.</code><i>Id</i> names a package that is the member named <i>Id</i> within the 
package named by <i>Q</i>. If <i>Q</i> does not name an accessible package or <i>Id</i> does not 
name an accessible subpackage of that package, then a compile-time error occurs.
<p><a name="21721"></a>
<h3>6.5.4    Meaning of Type Names</h3>
<a name="32763"></a>
The meaning of a name classified as a <i>TypeName</i> is determined as follows.
<p><a name="21810"></a>
<h4>6.5.4.1    Simple Type Names</h4>
<a name="32799"></a>
If a type name consists of a single <i>Identifier</i>, then the identifier must occur in the 
scope of a declaration of a type with this name, or a compile-time error occurs. It 
is possible that the identifier occurs within the scope of more than one type with 
that name, in which case the type denoted by the name is determined as follows:
<p><ul><a name="21741"></a>
<li>If a type with that name is declared in the current compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a>, either by a single-type-import declaration <a href="7.doc.html#26699">(&#167;7.5.1)</a> or by a declaration of a class or interface &#32;type <a href="7.doc.html#26783">(&#167;7.6)</a>, then the simple type name denotes that type.
<a name="21751"></a>
<li>Otherwise, if a type with that name is declared in another compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a> of the package <a href="7.doc.html#26535">(&#167;7.1)</a> containing the identifier, then the identifier denotes that type. Note that, in systems that store compilation units in a file system, such a compilation unit must have a file name that is the name of the type <a href="7.doc.html#26783">(&#167;7.6)</a>.
<a name="21758"></a>
<li>Otherwise, if a type of that name is declared by exactly one type-import-on-demand declaration <a href="7.doc.html#26725">(&#167;7.5.2)</a> of the compilation unit containing the identifier, then the simple type name denotes that type.
<a name="32932"></a>
<li>Otherwise, if a type of that name is declared by more than one type-import-on-demand declaration of the compilation unit, then the name is ambiguous as a type name; a compile-time error occurs.
<a name="32933"></a>
<li>Otherwise, the name is undefined as a type name; a compile-time error occurs.
</ul><a name="32934"></a>
This order for considering type declarations is designed to choose the most 
explicit of two or more applicable type declarations.
<p><a name="21811"></a>
<h4>6.5.4.2    Qualified Type Names</h4>
<a name="32818"></a>
If a type name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> must be a package name. The type 
name <i>Q</i><code>.</code><i>Id</i> names a type that is the member named <i>Id</i> within the package named 
by <i>Q</i>. If <i>Q</i> does not name an accessible package, or <i>Id</i> does not name a type within 
that package, or the type named <i>Id</i> within that package is not accessible <a href="6.doc.html#33916">(&#167;6.6)</a>, 
then a compile-time error occurs.
<p><a name="32816"></a>
The example:<p>
<pre><a name="21789"></a>package wnj.test;
</pre><pre><a name="21790"></a>
class Test {
<a name="21791"></a>	public static void main(String[] args) {
<a name="21792"></a>		java.util.Date date =
<a name="21793"></a>			new java.util.Date(System.currentTimeMillis());
<a name="21794"></a>		System.out.println(date.toLocaleString());
<a name="21795"></a>	}
<a name="21796"></a>}
</pre><a name="21797"></a>
produced the following output the first time it was run:
<p><pre><a name="21798"></a>Sun Jan 21 22:56:29 1996
</pre><a name="21799"></a>
In this example:
<p><ul><a name="21800"></a>
<li>The name <code>wnj.test</code> must name a package on the host system. It is resolved by first looking for the package <code>wnj</code>, using the procedure described in <a href="6.doc.html#22481">&#167;6.5.3.1</a>, and then making sure that the subpackage <code>test</code> of this package is accessible.
<a name="21807"></a>
<li>The name <code>java.util.Date</code> <a href="javautil.doc2.html#7433">(&#167;21.3)</a> must denote a type, so we first use the procedure recursively to determine if <code>java.util</code> is an accessible package, which it is, and then look to see if the type <code>Date</code> is accessible in this package.
</ul><a name="21650"></a>
<h3>6.5.5    Meaning of Expression Names</h3>
<a name="32767"></a>
The meaning of a name classified as an <i>ExpressionName</i> is determined as follows.
<p><a name="22022"></a>
<h4>6.5.5.1    Simple Expression Names</h4>
<a name="22023"></a>
If an expression name consists of a single <i>Identifier</i>, then:
<p><ul><a name="22030"></a>
<li>If the <i>Identifier</i> appears within the scope <a href="6.doc.html#33623">(&#167;6.3)</a> of a local variable declaration <a href="14.doc.html#5920">(&#167;14.3)</a> or parameter declaration (<a href="8.doc.html#38698">&#167;8.4.1</a>, <a href="8.doc.html#29488">&#167;8.6.1</a>, <a href="14.doc.html#79311">&#167;14.18</a>) with that name, then the expression name denotes a variable, that is, that local variable or parameter. Local variables and parameters are never hidden (<a href="6.doc.html#33623">&#167;6.3</a>, <a href="6.doc.html#34133">&#167;6.3.1</a>, <a href="14.doc.html#5920">&#167;14.3</a>), so there is necessarily at most one such local variable or parameter. The type of the expression name is the declared type of the local variable or parameter.
<a name="22052"></a>
<li>Otherwise, if the <i>Identifier</i> appears within a class declaration <a href="8.doc.html#3857">(&#167;8)</a>:
<ul>
<a name="22062"></a>
<li>If there is not exactly one member of that class <a href="8.doc.html#21831">(&#167;8.2)</a> that is a field with that name, then a compile-time error results.
<a name="22063"></a>
<li>Otherwise, if the single member field with that name is declared <code>final</code> <a href="8.doc.html#35962">(&#167;8.3.1.2)</a>, then the expression name denotes the value of the field. The type of the expression name is the declared type of the field. If the <i>Identifier</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
<a name="22077"></a>
<li>Otherwise, the expression name denotes a variable, the single member field with that name. The type of the expression name is the field's declared type.
</ul>
</ul><ul><a name="60351"></a>
<br><br>If the field is an instance variable <a href="8.doc.html#37544">(&#167;8.3.1.1)</a>, the expression name must appear within the declaration of an instance method <a href="8.doc.html#40420">(&#167;8.4)</a>, constructor <a href="8.doc.html#41652">(&#167;8.6)</a>, or instance variable initializer <a href="8.doc.html#38013">(&#167;8.3.2.2)</a>. If it appears within a <code>static</code> method <a href="8.doc.html#229128">(&#167;8.4.3.2)</a>, static initializer <a href="8.doc.html#39245">(&#167;8.5)</a>, or initializer for a <code>static</code> variable (<a href="8.doc.html#37544">&#167;8.3.1.1</a>, <a href="12.doc.html#44630">&#167;12.4.2</a>), then a compile-time error occurs.
</ul><ul><a name="60376"></a>
<li>Otherwise, the identifier appears within an interface declaration <a href="9.doc.html#238678">(&#167;9)</a>:
<ul>
<a name="60380"></a>
<li>If there is not exactly one member of that interface <a href="9.doc.html#32392">(&#167;9.2)</a> that is a field with that name, then a compile-time error results.
<a name="32963"></a>
<li>Otherwise, the expression name denotes the value of the single member field of that name. The type of the expression name is the declared type of the field. If the <i>Identifier</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
</ul>
</ul><a name="22118"></a>
In the example:
<p><pre><a name="22119"></a>
class Test {
<br><a name="22120"></a>	static int v;
<br><br><a name="61612"></a>	static final int f = 3;
<br><a name="61613"></a>
	public static void main(String[] args) {
<a name="61614"></a>		int i;
<a name="22124"></a>		i = 1;
<a name="22125"></a>		v = 2;
<a name="22126"></a>		f = 33;										// compile-time error
<a name="22127"></a>		System.out.println(i + " " + v + " " + f);
<a name="22128"></a>	}
<br><a name="22129"></a>}
</pre><a name="22130"></a>
the names used as the left-hand-sides in the assignments to <code>i</code>, <code>v</code>, and <code>f</code> denote the 
local variable <code>i</code>, the field <code>v</code>, and the value of <code>f</code> (not the variable <code>f</code>, because <code>f</code> is a 
<code>final</code> variable). The example therefore produces an error at compile time 
because the last assignment does not have a variable as its left-hand side. If the 
erroneous assignment is removed, the modified code can be compiled and it will 
produce the output:
<p><pre><a name="22131"></a>1 2 3
</pre><a name="22133"></a>
<h4>6.5.5.2    Qualified Expression Names</h4>
<a name="33085"></a>
If an expression name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> has already been classified as a 
package name, a type name, or an expression name:
<p><ul><a name="22747"></a>
<li>If <i>Q</i> is a package name, then a compile-time error occurs.
<a name="22294"></a>
<li>If <i>Q</i> is a type name that names a class type <a href="8.doc.html#3857">(&#167;8)</a>, then:
<ul>
<a name="22298"></a>
<li>If there is not exactly one accessible <a href="6.doc.html#33916">(&#167;6.6)</a> member of the class type that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="22299"></a>
<li>Otherwise, if the single accessible member field is not a class variable (that is, it is not declared <code>static</code>), then a compile-time error occurs.
<a name="41289"></a>
<li>Otherwise, if the class variable is declared <code>final</code>, then <i>Q</i><code>.</code><i>Id</i> denotes the value of the class variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the class variable. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
<a name="22303"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes the class variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the class variable.
</ul>
<a name="22145"></a>
<li>If <i>Q</i> is a type name that names an interface type <a href="9.doc.html#238678">(&#167;9)</a>, then:
<ul>
<a name="33167"></a>
<li>If there is not exactly one accessible <a href="6.doc.html#33916">(&#167;6.6)</a> member of the interface type that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="33169"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes the value of the field. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
</ul>
<a name="22165"></a>
<li>If <i>Q</i> is an expression name, let <i>T</i> be the type of the expression <i>Q</i>:
<ul>
<a name="22169"></a>
<li>If <i>T</i> is not a reference type, a compile-time error occurs.
<a name="33185"></a>
<li>If there is not exactly one accessible <a href="6.doc.html#33916">(&#167;6.6)</a> member of the type <i>T</i> that is a field named <i>Id</i>, then a compile-time error occurs.
<a name="22170"></a>
<li>Otherwise, if this field is any of the following:
<ul>
<a name="33204"></a>
<li>A field of an interface type
<a name="33205"></a>
<li>A <code>final</code> field of a class type (which may be either a class variable or an instance variable)
<a name="33208"></a>
<li>The <code>final</code> field <code>length</code> of an array type
</ul>
<a name="33211"></a>
<li>then <i>Q</i><code>.</code><i>Id</i> denotes the value of the field. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field. If <i>Q</i><code>.</code><i>Id</i> appears in a context that requires a variable and not a value, then a compile-time error occurs.
<a name="22173"></a>
<li>Otherwise, <i>Q</i><code>.</code><i>Id</i> denotes a variable, the field <i>Id</i> of class <i>T</i>, which may be either a class variable or an instance variable. The type of the expression <i>Q</i><code>.</code><i>Id</i> is the declared type of the field
</ul>
</ul><a name="62391"></a>
The example:
<p><pre><a name="22175"></a>
class Point {
<a name="22176"></a>	int x, y;
<a name="22177"></a>	static int nPoints;
<a name="22178"></a>}
<a name="22179"></a>
class Test {
<a name="22180"></a>	public static void main(String[] args) {
<a name="22181"></a>		int i = 0;
<a name="22182"></a>		i.x++;								// compile-time error
<a name="22183"></a>		Point p = new Point();
<a name="22184"></a>		p.nPoints();								// compile-time error
<a name="22185"></a>	}
<a name="22186"></a>}
</pre><a name="22187"></a>
encounters two compile-time errors, because the <code>int</code> variable <code>i</code> has no members, 
and because <code>nPoints</code> is not a method of class <code>Point</code>.
<p><a name="21652"></a>
<h3>6.5.6    Meaning of Method Names</h3>
<a name="32771"></a>
A <i>MethodName</i> can appear only in a method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a>. The 
meaning of a name classified as a <i>MethodName</i> is determined as follows.
<p><a name="54512"></a>
<h4>6.5.6.1    Simple Method Names</h4>
<a name="54513"></a>
If a method name consists of a single <i>Identifier</i>, then <i>Identifier</i> is the method name 
to be used for method invocation. The <i>Identifier</i> must name at least one method of 
the class or interface within whose declaration the <i>Identifier</i> appears. See <a href="15.doc.html#20448">&#167;15.11</a> 
for further discussion of the interpretation of simple method names in method 
invocation expressions.
<p><a name="54547"></a>
<h4>6.5.6.2    Qualified Method Names</h4>
<a name="33243"></a>
If a method name is of the form <i>Q</i><code>.</code><i>Id</i>, then <i>Q</i> has already been classified as a 
package name, a type name, or an expression name. If <i>Q</i> is a package name, then a 
compile-time error occurs. Otherwise, <i>Id</i> is the method name to be used for 
method invocation. If <i>Q</i> is a type name, then <i>Id</i> must name at least one <code>static</code> 
method of the type <i>Q</i>. If <i>Q</i> is an expression name, then let <i>T</i> be the type of the 
expression <i>Q</i>; <i>Id</i> must name at least one method of the type <i>T</i>. See <a href="15.doc.html#20448">&#167;15.11</a> for further
discussion of the interpretation of qualified method names in method invocation
expressions.
<p><a name="33916"></a>
<h2>6.6    Qualified Names and Access Control</h2>
<a name="33917"></a>
Qualified names are a means of access to members of packages and reference 
types; related means of access include field access expressions <a href="15.doc.html#41267">(&#167;15.10)</a> and 
method invocation expressions <a href="15.doc.html#20448">(&#167;15.11)</a>. All three are syntactically similar in that 
a "<code>.</code>" token appears, preceded by some indication of a package, type, or expression
having a type and followed by an <i>Identifier</i> that names a member of the package
or type. These are collectively known as constructs for <i>qualified access</i>.
<p><a name="33924"></a>
Java provides mechanisms for <i>access control</i>, to prevent the users of a package or class from depending on unnecessary details of the implementation of that package or class. Access control applies to qualified access and to the invocation of constructors by class instance creation expressions <a href="15.doc.html#41147">(&#167;15.8)</a>, explicit constructor invocations <a href="8.doc.html#78435">(&#167;8.6.5)</a>, and the method <code>newInstance</code> of class <code>Class</code> <a href="javalang.doc2.html#15088">(&#167;20.3.6)</a>.<p>
<a name="62634"></a>
If access is permitted, then the accessed entity is said to be <i>accessible</i>.<p>
<a name="62395"></a>
<h3>6.6.1    Determining Accessibility</h3>
<ul><a name="33934"></a>
<li>Whether a package is accessible is determined by the host system <a href="7.doc.html#37758">(&#167;7.2)</a>.
<a name="62409"></a>
<li>If a class or interface type is declared <code>public</code>, then it may be accessed by any Java code that can access the package in which it is declared. If a class or interface type is not declared <code>public</code>, then it may be accessed only from within the package in which it is declared.
<a name="62410"></a>
<li>A member (field or method) of a reference (class, interface, or array) type or a constructor of a class type is accessible only if the type is accessible and the member or constructor is declared to permit access:
<ul>
<a name="62795"></a>
<li>If the member or constructor is declared <code>public</code>, then access is permitted. All members of interfaces are implicitly <code>public</code>.
<a name="62561"></a>
<li>Otherwise, if the member or constructor is declared <code>protected</code>, then access is permitted only when one of the following is true:
<ul><ul>
<a name="62562"></a>
<li>Access to the member or constructor occurs from within the package containing the class in which the <code>protected</code> member is declared.
<a name="62452"></a>
<li>Access occurs within a subclass of the class in which the <code>protected</code> member is declared, and the access is correct as described in <a href="6.doc.html#62587">&#167;6.6.2</a>.
</ul>
</ul><a name="62857"></a>
<li>Otherwise, if the member or constructor is declared <code>private</code>, then access is permitted only when it occurs from within the class in which it is declared.
<a name="62586"></a>
<li>Otherwise, we say there is default access, which is permitted only when the access occurs from within the package in which the type is declared.
</ul>
</ul><a name="62587"></a>
<h3>6.6.2    Details on <code>protected</code> Access</h3>
<a name="62638"></a>
A <code>protected</code> member or constructor of an object may be accessed from outside 
the package in which it is declared only by code that is responsible for the implementation
of that object. Let <i>C</i> be the class in which a <code>protected</code> member or constructor
is declared and let <i>S</i> be the subclass of <i>C</i> in whose declaration the use of 
the <code>protected</code> member or constructor occurs. Then:
<p><ul><a name="60602"></a>
<li>If an access is of a <code>protected</code> member (field or method), let <i>Id</i> be its name. Consider then the means of qualified access:
<ul>
<a name="33943"></a>
<li>If the access is by a field access expression of the form <code>super.</code><i>Id</i>, then the access is permitted.
<a name="33945"></a>
<li>If the access is by a qualified name <i>Q</i><code>.</code><i>Id</i>, where <i>Q</i> is a <i>TypeName</i>, then the access is permitted if and only if <i>Q</i> is <i>S</i> or a subclass of <i>S</i>.
<a name="33946"></a>
<li>If the access is by a qualified name <i>Q</i><code>.</code><i>Id</i>, where <i>Q</i> is an <i>ExpressionName</i>, then the access is permitted if and only if the type of the expression <i>Q</i> is <i>S</i> or a subclass of <i>S</i>.
<a name="33947"></a>
<li>If the access is by a field access expression <i>E</i><code>.</code><i>Id</i>, where <i>E</i> is a <i>Primary</i> expression, or by a method invocation expression <i>E</i><code>.</code><i>Id</i><code>(</code>. . .<code>)</code>, where <i>E</i> is a <i>Primary</i> expression, then the access is permitted if and only if the type of <i>E</i> is <i>S</i> or a subclass of <i>S</i>.
</ul>
<a name="60590"></a>
<li>Otherwise, if an access is of a <code>protected</code> constructor:
<ul>
<a name="60601"></a>
<li>If the access is by a superclass constructor invocation <code>super(</code>. . .<code>)</code>, then the access is permitted.
<a name="62811"></a>
<li>If the access is by a class instance creation expression <code>new</code> <i>T</i><code>(</code>. . .<code>)</code>, then the access is not permitted. (A <code>protected</code> constructor can be accessed by a class instance creation expression only from within the package in which it is defined.)
<a name="62828"></a>
<li>If the access is by an invocation of the method <code>newInstance</code> of class <code>Class</code> <a href="javalang.doc2.html#15088">(&#167;20.3.6)</a>, then the access is not permitted.
</ul>
</ul><a name="62666"></a>
<h3>6.6.3    An Example of Access Control</h3>
<a name="62647"></a>
For examples of access control, consider the two compilation units:
<p><pre><br><a name="33958"></a>package points;
<br><a name="33959"></a>class PointVec { Point[] vec; }
</pre><a name="33960"></a>
and:
<p><pre><br><a name="33961"></a>package points;
<br></pre><pre><a name="33962"></a>
public class Point {
<a name="33963"></a>	protected int x, y;
<a name="33964"></a>	public void move(int dx, int dy) { x += dx; y += dy; }
<a name="33965"></a>	public int getX() { return x; }
<a name="33966"></a>	public int getY() { return y; }
<a name="33967"></a>}
</pre><a name="33968"></a>
which declare two class types in the package <code>points</code>:
<p><ul><a name="33969"></a>
<li>The class type <code>PointVec</code> is not <code>public</code> and not part of the <code>public</code> interface of the package <code>points</code>, but rather can be used only by other classes in the package.
<a name="33970"></a>
<li>The class type <code>Point</code> is declared <code>public</code> and is available to other packages. It is part of the <code>public</code> interface of the package <code>points</code>.
<a name="33971"></a>
<li>The methods <code>move</code>, <code>getX</code>, and <code>getY</code> of the class <code>Point</code> are declared <code>public</code> and so are available to any Java code that uses an object of type <code>Point</code>.
<a name="33972"></a>
<li>The fields <code>x</code> and <code>y</code> are declared <code>protected</code> and are accessible outside the package <code>points</code> only in subclasses of class <code>Point,</code> and only when they are fields of objects that are being implemented by the code that is accessing them.
</ul><a name="33976"></a>
See <a href="6.doc.html#36191">&#167;6.6.7</a> for an example of how the <code>protected</code> access modifier limits access.
<p><a name="36060"></a>
<h3>6.6.4    Example: Access to <code>public</code> and Non-<code>public</code> Classes</h3>
<a name="36063"></a>
If a class lacks the <code>public</code> modifier, access to the class declaration is limited to 
the package in which it is declared <a href="6.doc.html#33916">(&#167;6.6)</a>. In the example:
<p><pre><br><a name="36076"></a>package points;
<br></pre><pre><a name="36077"></a>
public class Point {
<a name="36078"></a>	public int x, y;
<a name="36079"></a>	public void move(int dx, int dy) { x += dx; y += dy; }
<a name="36080"></a>}
<br><a name="36081"></a>
class PointList {
<a name="36082"></a>	Point next, prev;
<a name="36083"></a>}
</pre><a name="36084"></a>
two classes are declared in the compilation unit. The class <code>Point</code> is available outside
the package <code>points</code>, while the class <code>PointList</code> is available for access only 
within the package. Thus a compilation unit in another package can access 
<code>points.Point</code>, either by using its fully qualified name:
<p><pre><br><a name="36085"></a>package pointsUser;
<br></pre><pre><a name="36086"></a>
class Test {
<a name="36087"></a>	public static void main(String[] args) {
<a name="36088"></a>		points.Point p = new points.Point();
<a name="36089"></a>		System.out.println(p.x + " " + p.y);
<a name="36090"></a>	}
<a name="36091"></a>}
</pre><a name="36092"></a>
or by using a single-type-import declaration <a href="7.doc.html#26699">(&#167;7.5.1)</a> that mentions the fully 
qualfied name, so that the simple name may be used thereafter:
<p><pre><br><a name="36096"></a>package pointsUser;
<br><br><a name="36097"></a>import points.Point;
<br></pre><pre><a name="36098"></a>
class Test {
<a name="36099"></a>	public static void main(String[] args) {
<a name="36100"></a>		Point p = new Point();
<a name="36101"></a>		System.out.println(p.x + " " + p.y);
<a name="36102"></a>	}
<a name="36103"></a>}
</pre><a name="36104"></a>
However, this compilation unit cannot use or import <code>points.PointList</code>, which 
is not declared <code>public</code> and is therefore inaccessible outside package <code>points</code>.
<p><a name="36154"></a>
<h3>6.6.5    Example: Default-Access Fields, Methods, and Constructors</h3>
<a name="36155"></a>
If none of the access modifiers <code>public</code>, <code>protected</code>, or <code>private</code> are specified, a 
class member or constructor is accessible throughout the package that contains the 
declaration of the class in which the class member is declared, but the class member
or constructor is not accessible in any other package. If a <code>public</code> class has a 
method or constructor with default access, then this method or constructor is not 
accessible to or inherited by a subclass declared outside this package.
<p><a name="60607"></a>
For example, if we have:<p>
<pre><br><a name="36156"></a>package points;
<br></pre><pre><a name="36157"></a>
public class Point {
<a name="36158"></a>	public int x, y;
<a name="36159"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<a name="61627"></a>	public void moveAlso(int dx, int dy) { move(dx, dy); }
<a name="36160"></a>}
</pre><a name="36161"></a>
then a subclass in another package may declare an unrelated <code>move</code> method, with 
the same signature <a href="8.doc.html#38649">(&#167;8.4.2)</a> and return type. Because the original <code>move</code> method is 
not accessible from package <code>morepoints</code>, <code>super</code> may not be used:
<p><pre><br><a name="36165"></a>package morepoints;
<br></pre><pre><a name="36166"></a>
public class PlusPoint extends points.Point {
<a name="36167"></a>	public void move(int dx, int dy) {
<a name="61624"></a>		super.move(dx, dy);								// compile-time error
<a name="36170"></a>		moveAlso(dx, dy);
<a name="61628"></a>	}
<a name="36171"></a>}
</pre><a name="61629"></a>
Because move of <code>Point</code> is not overridden by <code>move</code> in <code>PlusPoint</code>, the method 
<code>moveAlso</code> in <code>Point</code> never calls the method move in <code>PlusPoint</code>.
<p><a name="61639"></a>
Thus if you delete the <code>super.move</code> call from <code>PlusPoint</code> and execute the test program:<p>
<pre><a name="61642"></a>
import points.Point;
<a name="61643"></a>
import morepoints.PlusPoint;
<a name="61644"></a>
class Test {
<a name="61645"></a>
    public static void main(String[] args) {
<a name="61646"></a>        PlusPoint pp = new PlusPoint();
<a name="61647"></a>        pp.move(1, 1);
<a name="61648"></a>    }
<br><a name="61649"></a>}
</pre><a name="61640"></a>
it terminates normally. If move of <code>Point</code> were overridden by <code>move</code> in <code>PlusPoint</code>, 
then this program would recurse infinitely, until a <code>StackoverflowError</code> 
occurred.
<p><a name="36250"></a>
<h3>6.6.6    Example: <code>public</code> Fields, Methods, and Constructors</h3>
<a name="36251"></a>
A <code>public</code> class member or constructor is accessible throughout the package 
where it is declared and from any other package that has access to the package in 
which it is declared <a href="7.doc.html#13194">(&#167;7.4.4)</a>. For example, in the compilation unit:
<p><pre><br><a name="36180"></a>package points;
<br></pre><pre><a name="36181"></a>
public class Point {
<br><a name="36182"></a>	int x, y;
<br><a name="36183"></a>
	public void move(int dx, int dy) {
<a name="36184"></a>		x += dx; y += dy;
<a name="36185"></a>		moves++;
<a name="36186"></a>	}
<br><br><a name="36187"></a>	public static int moves = 0;
<br><a name="36188"></a>}
</pre><a name="36189"></a>
the <code>public</code> class <code>Point</code> has as <code>public</code> members the <code>move</code> method and the <code>moves</code> 
field. These <code>public</code> members are accessible to any other package that has access 
to package <code>points</code>. The fields <code>x</code> and <code>y</code> are not <code>public</code> and therefore are accessible 
only from within the package <code>points</code>.
<p><a name="36191"></a>
<h3>6.6.7    Example: <code>protected</code> Fields, Methods, and Constructors</h3>
<a name="36201"></a>
Consider this example, where the <code>point</code> package declares:
<p><pre><br><a name="36202"></a>package points;
<br></pre><pre><a name="36203"></a>
public class Point {
<br><a name="36322"></a>	protected int x, y;
<br><a name="36324"></a>
	void warp(threePoint.Point3d a) {
<a name="61672"></a>		if (a.z &gt; 0)						// compile-time error: cannot access a.z
<a name="61670"></a>			a.delta(this);
<a name="36332"></a>	}
<br><a name="36323"></a>}
</pre><a name="36204"></a>
and the <code>threePoint</code> package declares:
<p><pre><br><a name="36331"></a>package threePoint;
<br><br><a name="36205"></a>import points.Point;
<br></pre><pre><a name="36206"></a>
public class Point3d extends Point {
<br><a name="36315"></a>	protected int z;
<br><a name="36207"></a>
	public void delta(Point p) {
<a name="36295"></a>		p.x += this.x;						// compile-time error: cannot access p.x
<a name="36296"></a>		p.y += this.y;						// compile-time error: cannot access p.y
<a name="36297"></a>	}
<br><a name="36208"></a>
	public void delta3d(Point3d q) {
<a name="36300"></a>		q.x += this.x;
<a name="36317"></a>		q.y += this.y;
<a name="36319"></a>		q.z += this.z;
<a name="36302"></a>	}
<br><a name="36209"></a>}
</pre><a name="36210"></a>
which defines a class <code>Point3d</code>. A compile-time error occurs in the method <code>delta 
</code>here: it cannot access the protected members <code>x</code> and <code>y</code> of its parameter <code>p</code>, because 
while <code>Point3d</code> (the class in which the references to fields <code>x</code> and <code>y</code> occur) is a subclass
of <code>Point</code> (the class in which <code>x</code> and <code>y</code> are declared), it is not involved in the 
implementation of a <code>Point</code> (the type of the parameter <code>p</code>). The method <code>delta3d</code> 
can access the protected members of its parameter <code>q</code>, because the class <code>Point3d</code> is 
a subclass of <code>Point</code> and is involved in the implementation of a <code>Point3d</code>.
<p><a name="36214"></a>
The method <code>delta</code> could try to cast (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>) its parameter to be a <code>Point3d</code>, but this cast would fail, causing an exception, if the class of <code>p</code> at run time were not <code>Point3d</code>.<p>
<a name="61715"></a>
A compile-time error also occurs in the method warp: it cannot access the protected member <code>z</code> of its parameter <code>a</code>, because while the class <code>Point</code> (the class in which the reference to field <code>z</code> occurs) is involved in the implementation of a <code>Point</code> (the type of the parameter a), it is not a subclass of <code>Point</code> (the class in which <code>z</code> is declared). <p>
<a name="36233"></a>
<h3>6.6.8    Example: <code>private</code> Fields, Methods, and Constructors</h3>
<a name="36235"></a>
<code>A</code> <code>private</code> class member or constructor is accessible only within the class body in 
which the member is declared and is not inherited by subclasses. In the example:
<p><pre><a name="36237"></a>
class Point {
<br><a name="36344"></a>	Point() { setMasterID(); }
<br><a name="36238"></a>
	int x, y;
<a name="36239"></a>	private int ID;
<a name="36240"></a>	private static int masterID = 0;
<br><a name="36241"></a>	private void setMasterID() { ID = masterID++; }
<br><a name="36242"></a>}
</pre><a name="36243"></a>
the <code>private</code> members <code>ID,</code> m<code>asterID</code>, and <code>setMasterID</code> may be used only 
within the body of class <code>Point</code>. They may not be accessed by qualified names, 
field access expressions, or method invocation expressions outside the body of the 
declaration of <code>Point</code>.
<p><a name="62528"></a>
See <a href="8.doc.html#16830">&#167;8.6.8</a> for an example that uses a <code>private</code> constructor.<p>
<a name="25430"></a>
<h2>6.7    Fully Qualified Names</h2>
<a name="24074"></a>
Every package, class, interface, array type, and primitive type has a fully qualified 
name. It follows that every type except the null type has a fully qualified name.
<p><ul><a name="9478"></a>
<li>The fully qualified name of a primitive type is the keyword for that primitive type, namely <code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>.
<a name="33330"></a>
<li>The fully qualified name of a named package that is not a subpackage of a named package is its simple name.
<a name="33332"></a>
<li>The fully qualified name of a named package that is a subpackage of another named package consists of the fully qualified name of the containing package, followed by "<code>.</code>", followed by the simple (member) name of the subpackage.
<a name="28912"></a>
<li>The fully qualified name of a class or interface that is declared in an unnamed package is the simple name of the class or interface.
<a name="33340"></a>
<li>The fully qualified name of a class or interface that is declared in a named package consists of the fully qualified name of the package, followed by "<code>.</code>", followed by the simple name of the class or interface.
<a name="9454"></a>
<li>The fully qualified name of an array type consists of the fully qualified name of the component type of the array type followed by "<code>[]</code>".
</ul><a name="11162"></a>
Examples:
<p><ul><a name="12348"></a>
<li>The fully qualified name of the type <code>long</code> is "<code>long</code>".
<a name="12351"></a>
<li>The fully qualified name of the standard package <code>java.lang</code> is "<code>java.lang</code>" because it is subpackage <code>lang</code> of package <code>java</code>.
<a name="33392"></a>
<li>The fully qualified name of the class <code>Object</code>, which is defined in the package <code>java.lang</code>, is "<code>java.lang.Object</code>".
<a name="33394"></a>
<li>The fully qualified name of the interface <code>Enumeration</code>, which is defined in the package <code>java.util</code>, is "<code>java.util.Enumeration</code>".
<a name="33378"></a>
<li>The fully qualified name of the type "array of <code>double</code>" is "<code>double[]</code>".
<a name="33380"></a>
<li>The fully qualified name of the type "array of array of array of array of <code>String</code>" is "<code>java.lang.String[][][][]</code>".
</ul><a name="12352"></a>
In the example:
<p><pre><a name="12353"></a>package points;
</pre><pre><a name="12362"></a>
class Point { int x, y; }
<a name="12354"></a>
class PointVec {
<a name="12355"></a>	Point[] vec;
<a name="56765"></a>}
</pre><a name="56766"></a>
the fully qualified name of the type <code>Point</code> is "<code>points.Point</code>"; the fully qualified 
name of the type <code>PointVec</code> is "<code>points.PointVec</code>"; and the fully qualified name 
of the type of the field <code>vec</code> of class <code>PointVec</code> is "<code>points.Point[]</code>".
<p><a name="11186"></a>
<h2>6.8    Naming Conventions</h2>
<a name="9218"></a>
The Java system and standard classes attempt to use, whenever possible, names 
chosen according to the conventions presented here. These conventions help to 
make code more readable and avoid certain kinds of name conflicts.
<p><a name="34468"></a>
We recommend these conventions for use in all Java programs. However, these conventions should not be followed slavishly if long-held conventional usage dictates otherwise. So, for example, the <code>sin</code> and <code>cos</code> methods of the class <code>java.lang.Math</code> have mathematically conventional names, even though these method names flout Java convention because they are short and are not verbs.<p>
<a name="9184"></a>
<h3>6.8.1    Package Names</h3>
<a name="9253"></a>
Names of packages that are to be made widely available should be formed as 
described in <a href="7.doc.html#40169">&#167;7.7</a>. Such names are always qualified names whose first identifier 
consists of two or three uppercase letters that name an Internet domain, such as 
<code>COM</code>, <code>EDU</code>, <code>GOV</code>, <code>MIL</code>, <code>NET</code>, <code>ORG</code>, or a two-letter ISO country code such as <code>UK</code> or <code>JP</code>. 
Here are examples of hypothetical unique names that might be formed under this 
convention:
<p><pre><a name="9241"></a>
COM.JavaSoft.jag.Oak
<a name="9242"></a>ORG.NPR.pledge.driver
<a name="9252"></a>UK.ac.city.rugby.game
</pre><a name="32841"></a>
Names of packages intended only for local use should have a first identifier that begins with a lowercase letter, but that first identifier specifically should not be the identifier <code>java</code>; package names that start with the identifier <code>java</code> are reserved to JavaSoft for naming standard Java packages.<p>
<a name="29469"></a>
When package names occur in expressions:<p>
<ul><a name="12971"></a>
<li>If a package name is hidden by a field declaration, then <code>import</code> declarations <a href="7.doc.html#26656">(&#167;7.5)</a> can usually be used to make available the type names declared in that package.
<a name="34379"></a>
<li>If a package name is hidden by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other Java code.
<a name="34365"></a>
<li>The first component of a package name is normally not easily mistaken for a type name, as a type name normally begins with a single uppercase letter. (The Java language does not actually rely on case distinctions to determine whether a name is a package name or a type name. It is not possible for a type name to hide a package name.)
</ul><a name="29466"></a>
<h3>6.8.2    Class and Interface Type Names</h3>
<a name="32824"></a>
Names of class types should be descriptive nouns or noun phrases, not overly 
long, in mixed case with the first letter of each word capitalized. For example:
<p><pre><a name="9292"></a>
<code>ClassLoader
</code><a name="9298"></a><code>SecurityManager
</code><a name="9309"></a><code>Thread
</code><a name="9299"></a><code>Dictionary
</code><a name="9316"></a>BufferedInputStream
</pre><a name="9111"></a>
Likewise, names of interface types should be short and descriptive, not overly long, in mixed case with the first letter of each word capitalized. The name may be a descriptive noun or noun phrase, which is appropriate when an interface is used as if it were an abstract superclass, such as interfaces <code>java.io.DataInput</code> and <code>java.io.DataOutput</code>; or it may be an adjective describing a behavior, as for the interfaces <code>java.lang.Runnable</code> and <code>java.lang.Cloneable</code>.<p>
<a name="12992"></a>
Hiding involving class and interface type names is rare. Names of fields, parameters, and local variables normally do not hide type names because they conventionally begin with a lowercase letter whereas type names conventionally begin with an uppercase letter.<p>
<a name="9322"></a>
<h3>6.8.3    Method Names</h3>
<a name="34563"></a>
Method names should be verbs or verb phrases, in mixed case, with the first letter 
lowercase and the first letter of any subsequent words capitalized. Here are some 
additional specific conventions for method names:
<p><ul><a name="34587"></a>
<li>Methods to <code>get</code> and <code>set</code> an attribute that might be thought of as a variable <i>V</i> should be named <code>get</code><i>V</i> and <code>set</code><i>V</i>. An example is the methods <code>getPriority</code> <a href="javalang.doc18.html#2819">(&#167;20.20.22)</a> and <code>setPriority</code> <a href="javalang.doc18.html#14175">(&#167;20.20.23)</a> of class <code>java.lang.Thread</code>.
<a name="34594"></a>
<li>A method that returns the length of something should be named <code>length</code>, as in class <code>java.lang.String</code> <a href="javalang.doc11.html#13985">(&#167;20.12.11)</a>.
<a name="9341"></a>
<li>A method that tests a <code>boolean</code> condition <i>V</i> about an object should be named <code>is</code><i>V</i>. An example is the method <code>isInterrupted</code> of class <code>java.lang.Thread</code> <a href="javalang.doc18.html#29183">(&#167;20.20.32)</a>.
<a name="34650"></a>
<li>A method that converts its object to a particular format <i>F</i> should be named <code>to</code><i>F</i>. Examples are the method <code>toString</code> of class <code>java.lang.Object</code> <a href="javalang.doc1.html#1152">(&#167;20.1.2)</a> and the methods <code>toLocaleString</code> <a href="javautil.doc2.html#7495">(&#167;21.3.27)</a> and <code>toGMTString</code> <a href="javautil.doc2.html#7496">(&#167;21.3.28)</a> of class <code>java.util.Date</code>.
</ul><a name="34660"></a>
Whenever possible and appropriate, basing the names of methods in a new class 
on names in an existing class that is similar, especially a class from the standard 
Java Application Programming Interface classes, will make it easier to use.
<p><a name="9384"></a>
Method names cannot hide or be hidden by other names <a href="6.doc.html#21652">(&#167;6.5.6)</a>.<p>
<a name="9351"></a>
<h3>6.8.4    Field Names</h3>
<a name="32831"></a>
Names of fields that are not <code>final</code> should be in mixed case with a lowercase first 
letter and the first letters of subsequent words capitalized. Note that well-designed 
Java classes have very few <code>public</code> or <code>protected</code> fields, except for fields that are 
constants (<code>final</code> <code>static</code> fields) <a href="6.doc.html#9367">(&#167;6.8.5)</a>.
<p><a name="56830"></a>
Fields should have names that are nouns, noun phrases, or abbreviations for nouns. Examples of this convention are the fields <code>buf</code>, <code>pos</code>, and <code>count</code> of the class <code>java.io.ByteArrayInputStream</code> <a href="javaio.doc4.html#28355">(&#167;22.6)</a> and the field <code>bytesTransferred</code> of the class <code>java.io.InterruptedIOException</code> <a href="javaio.doc27.html#30212">(&#167;22.30.1)</a>.<p>
<a name="13055"></a>
Hiding involving field names is rare.<p>
<ul><a name="29526"></a>
<li>If a field name hides a package name, then an <code>import</code> declaration <a href="7.doc.html#26656">(&#167;7.5)</a> can usually be used to make available the type names declared in that package.
<a name="13069"></a>
<li>If a field name hides a type name, then a fully qualified name for the type can be used.
<a name="29539"></a>
<li>Field names cannot hide method names.
<a name="9539"></a>
<li>If a field name is hidden by a declaration of a parameter or local variable, then the name of the parameter or local variable can be changed without affecting other Java code.
</ul><a name="9367"></a>
<h3>6.8.5    Constant Names</h3>
<a name="9368"></a>
The names of constants in interface types should be, and <code>final</code> variables of class 
types may conventionally be, a sequence of one or more words, acronyms, or 
abbreviations, all uppercase, with components separated by underscore "<code>_</code>" characters.
Constant names should be descriptive and not unnecessarily abbreviated. 
Conventionally they may be any appropriate part of speech. Examples of names 
for constants include <code>MIN_VALUE</code>, <code>MAX_VALUE</code>, <code>MIN_RADIX</code>, and <code>MAX_RADIX</code> of the 
class <code>java.lang.Character</code>.
<p><a name="9563"></a>
A group of constants that represent alternative values of a set, or, less frequently, masking bits in an integer value, are sometimes usefully specified with a common acronym as a name prefix, as in:<p>
<pre><a name="9564"></a>
interface ProcessStates {
<a name="9565"></a>	int PS_RUNNING = 0;
<a name="9566"></a>	int PS_SUSPENDED = 1;
<a name="9568"></a>}
</pre><a name="13087"></a>
Hiding involving constant names is rare:
<p><ul><a name="9569"></a>
<li>Constant names should be longer than three letters, so that they do not hide the initial component of a unique package name.
<a name="62840"></a>
<li>Constant names normally have no lowercase letters, so they will not normally hide names of packages, types, or fields, whose names normally contain at least one lowercase letter.
<a name="62841"></a>
<li>Constant names cannot hide method names, because they are distinguished syntactically.
</ul><a name="62552"></a>
<h3>6.8.6    Local Variable and Parameter Names</h3>
<a name="9381"></a>
Local variable and parameter names should be short, yet meaningful. They are 
often short sequences of lowercase letters that are not words. For example:
<p><ul><a name="12405"></a>
<li>Acronyms, that is the first letter of a series of words, as in <code>cp</code> for a variable holding a reference to a <code>ColoredPoint</code>
<a name="12410"></a>
<li>Abbreviations, as in <code>buf</code> holding a pointer to a <code>buffer</code> of some kind
<a name="12434"></a>
<li>Mnemonic terms, organized in some way to aid memory and understanding, typically by using a set of local variables with conventional names patterned after the names of parameters to widely used classes. For example:
<ul>
<a name="12435"></a>
<li><code>in</code> and <code>out</code>, whenever some kind of input and output are involved, patterned after the fields of <code>java.lang.System</code>
<a name="12436"></a>
<li><code>off</code> and <code>len</code>, whenever an offset and length are involved, patterned after the parameters to the <code>read</code> and <code>write</code> methods of the interfaces <code>DataInput</code> and <code>DataOutput</code> of <code>java.io</code>
</ul>
</ul><a name="12367"></a>
One-character local variable or parameter names should be avoided, except for temporary and looping variables, or where a variable holds an undistinguished value of a type. Conventional one-character names are:<p>
<ul><a name="9148"></a>
<li><code>b</code> for a <code>byte</code>
<a name="9149"></a>
<li><code>c</code> for a <code>char</code>
<a name="12485"></a>
<li><code>d</code> for a <code>double</code>
<a name="9150"></a>
<li><code>e</code> for an <code>Exception</code>
<a name="12479"></a>
<li><code>f</code> for a <code>float</code>
<a name="9151"></a>
<li><code>i</code>, <code>j</code>, and <code>k</code> for integers
<a name="12846"></a>
<li><code>l</code> for a <code>long</code>
<a name="9155"></a>
<li><code>o</code> for an <code>Object</code>
<a name="12475"></a>
<li><code>s</code> for a <code>String</code>
<a name="12474"></a>
<li><code>v</code> for an arbitrary value of some type
</ul><a name="34406"></a>
Local variable or parameter names that consist of only two or three uppercase letters should be avoided to avoid potential conflicts with the initial country codes and domain names that are the first component of unique package names <a href="7.doc.html#40169">(&#167;7.7)</a>.<p>
<a name="65318"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="5.doc.html">Prev</a> | <a href="7.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>