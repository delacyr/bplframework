<html>
<head>
<title>The Java Language Specification
 Blocks and Statements</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="13.doc.html">Prev</a> | <a href="15.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="44383"></a>
<p><strong>
CHAPTER
 14 </strong></p>
<a name="101241"></a>
<h1>Blocks and Statements</h1>
<hr><p>
<a name="45234"></a>
The sequence of execution of a Java program is controlled by <i>statements</i>, 
which are executed for their effect and do not have values.
<p><a name="17960"></a>
Some statements <i>contain</i> other statements as part of their structure; such other statements are substatements of the statement. We say that statement <i>S</i><i></i> <i>immediately &#32;contains</i> statement <i>U</i><code></code> if there is no statement <i>T</i><em></em> different from <i>S</i><i></i> and <i>U</i><code></code> such that <i>S</i><i></i> contains <i>T</i><em></em> and <i>T</i><em></em> contains <i>U</i>. In the same manner, some statements contain expressions <a href="15.doc.html#4709">(&#167;15)</a> as part of their structure.<p>
<a name="43082"></a>
The first section of this chapter discusses the distinction between normal and abrupt completion of statements <a href="14.doc.html#5894">(&#167;14.1)</a>. Most of the remaining sections explain the various kinds of statements, describing in detail both their normal behavior and any special treatment of abrupt completion.<p>
<a name="43210"></a>
Blocks are explained first <a href="14.doc.html#24644">(&#167;14.2)</a>, because they can appear in certain places where other kinds of statements are not allowed, and because one other kind of statement, a local variable declaration statement <a href="14.doc.html#5920">(&#167;14.3)</a>, must be immediately contained within a block.<p>
<a name="43203"></a>
Next a grammatical maneuver is explained that sidesteps the familiar "dangling <code>else</code>" problem <a href="14.doc.html#32584">(&#167;14.4)</a>.<p>
<a name="43118"></a>
Statements that will be familiar to C and C++ programmers are the empty <a href="14.doc.html#5970">(&#167;14.5)</a>, labeled <a href="14.doc.html#78993">(&#167;14.6)</a>, expression <a href="14.doc.html#5984">(&#167;14.7)</a>, <code>if</code> <a href="14.doc.html#5991">(&#167;14.8)</a>, <code>switch</code> <a href="14.doc.html#35518">(&#167;14.9)</a>, <code>while</code> <a href="14.doc.html#237277">(&#167;14.10)</a>, <code>do</code> <a href="14.doc.html#6045">(&#167;14.11)</a>, <code>for</code> <a href="14.doc.html#24588">(&#167;14.12)</a>, <code>break</code> <a href="14.doc.html#6842">(&#167;14.13)</a>, <code>continue</code> <a href="14.doc.html#6122">(&#167;14.14)</a>, and <code>return</code> <a href="14.doc.html#6767">(&#167;14.15)</a> statements.<p>
<a name="43199"></a>
Unlike C and C++, Java has no <code>goto</code> statement. However, the <code>break</code> and <code>continue</code> statements are extended in Java to allow them to mention statement labels.<p>
<a name="43200"></a>
The Java statements that are not in the C language are the <code>throw</code> <a href="14.doc.html#237350">(&#167;14.16)</a>, <code>synchronized</code> <a href="14.doc.html#79287">(&#167;14.17)</a>, and <code>try</code> <a href="14.doc.html#79311">(&#167;14.18)</a> statements.<p>
<a name="43110"></a>
The last section <a href="14.doc.html#236365">(&#167;14.19)</a> of this chapter addresses the requirement that every statement be <i>reachable</i> in a certain technical sense.<p>
<a name="5894"></a>
<h2>14.1    Normal and Abrupt Completion of Statements</h2>
<a name="78796"></a>
Every statement has a normal mode of execution in which certain computational 
steps are carried out. The following sections describe the normal mode of execution
for each kind of statement. If all the steps are carried out as described, with no 
indication of abrupt completion, the statement is said to <i>complete normally</i>. However,
certain events may prevent a statement from completing normally:
<p><ul><a name="47062"></a>
<li>The <code>break</code> <a href="14.doc.html#6842">(&#167;14.13)</a>, <code>continue</code> <a href="14.doc.html#6122">(&#167;14.14)</a>, and <code>return</code> <a href="14.doc.html#6767">(&#167;14.15)</a> statements cause a transfer of control that may prevent normal completion of statements that contain them.
<a name="78802"></a>
<li>Evaluation of certain Java expressions may throw exceptions from the Java Virtual Machine; these expressions are summarized in <a href="15.doc.html#79448">&#167;15.5</a>. An explicit <code>throw</code> <a href="14.doc.html#237350">(&#167;14.16)</a> statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements.
</ul><a name="5898"></a>
If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to <i>complete abruptly</i>. An abrupt completion always has an associated <i>reason</i>, which is one of the following:<p>
<ul><a name="5899"></a>
<li>A <code>break</code> with no label
<a name="78812"></a>
<li>A <code>break</code> with a given label
<a name="5901"></a>
<li>A <code>continue</code> with no label
<a name="78822"></a>
<li>A <code>continue</code> with a given label
<a name="5903"></a>
<li>A <code>return</code> with no value
<a name="5904"></a>
<li>A <code>return</code> with a given value
<a name="78827"></a>
<li>A <code>throw</code> with a given value, including exceptions thrown by the Java Virtual Machine
</ul><a name="237105"></a>
The terms "complete normally" and "complete abruptly" also apply to the evaluation of expressions <a href="15.doc.html#79448">(&#167;15.5)</a>. The only reason an expression can complete abruptly is that an exception is thrown, because of either a <code>throw</code> with a given value <a href="14.doc.html#237350">(&#167;14.16)</a> or a run-time exception or error (<a href="11.doc.html#44043">&#167;11</a>, <a href="15.doc.html#79448">&#167;15.5</a>).<p>
<a name="237118"></a>
If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed.<p>
<a name="24642"></a>
Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed.<p>
<a name="24647"></a>
Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.<p>
<a name="24644"></a>
<h2>14.2    Blocks</h2>
<a name="6391"></a>
A <i>block</i> is a sequence of statements and local variable declaration statements 
within braces.
<p><ul><pre>
<i>Block:<br>
</i>	<code>{ </code><i>BlockStatements</i><sub><i>opt</i></sub><code> }
</code>
<i>BlockStatements:<br>
</i><code>	</code><i>BlockStatement<br>
</i><code>	</code><i>BlockStatements</i><code> </code><i>BlockStatement
</i>
<i>BlockStatement:<br>
</i>	<i>LocalVariableDeclarationStatement<br>
</i>	<i>Statement
</i></pre></ul><a name="5918"></a>
A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.<p>
<a name="5920"></a>
<h2>14.3    Local Variable Declaration Statements</h2>
<a name="25561"></a>
A <i>local variable declaration statement</i> declares one or more local variable names.
<p><ul><pre>
<i>LocalVariableDeclarationStatement:<br>
</i>	<i>LocalVariableDeclaration</i><code> ;
</code>
<i>LocalVariableDeclaration:<br>
</i>	<i>Type</i><code> </code><i>VariableDeclarators
</i></pre></ul><a name="238231"></a>
The following are repeated from <a href="8.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:
<p><ul><pre>
<i>VariableDeclarators:<br>
</i>	<i>VariableDeclarator<br>
</i>	<i>VariableDeclarators</i><code> , </code><i>VariableDeclarator
</i>
<i>VariableDeclarator:<br>
</i>	<i>VariableDeclaratorId<br>
</i>	<i>VariableDeclaratorId</i><code> = </code><i>VariableInitializer
</i>
<i>VariableDeclaratorId:<br>
</i>	<i>Identifier<br>
</i>	<i>VariableDeclaratorId</i><code> [ ]
</code>
<i>VariableInitializer:<br>
</i>	<i>Expression<br>
</i>	<i>ArrayInitializer
</i></pre></ul><a name="32641"></a>
Every local variable declaration statement is immediately contained by a block. Local variable declaration statements may be intermixed freely with other kinds of statements in the block.<p>
<a name="35375"></a>
A local variable declaration can also appear in the header of a <code>for</code> statement <a href="14.doc.html#24588">(&#167;14.12)</a>. In this case it is executed in the same manner as if it were part of a local variable declaration statement.<p>
<a name="35393"></a>
<h3>14.3.1    Local Variable Declarators and Types</h3>
<a name="35391"></a>
Each <i>declarator</i> in a local variable declaration declares one local variable, whose 
name is the <i>Identifier</i> that appears in the declarator.
<p><a name="35396"></a>
The type of the variable is denoted by the <i>Type</i> that appears at the start of the local variable declaration, followed by any bracket pairs that follow the <i>Identifier</i> in the declarator. Thus, the local variable declaration:<p>
<pre><a name="35400"></a>int a, b[], c[][];
</pre><a name="35401"></a>
is equivalent to the series of declarations:
<p><pre><a name="35402"></a>
int a;
<a name="35403"></a>int[] b;
<a name="35404"></a>int[][] c;
</pre><a name="35405"></a>
Brackets are allowed in declarators as a nod to the tradition of C and C++. The 
general rule, however, also means that the local variable declaration:
<p><pre><a name="35406"></a>float[][] f[][], g[][][], h[];													// Yechh!
</pre><a name="35409"></a>
is equivalent to the series of declarations:
<p><pre><a name="35410"></a>
float[][][][] f;
<a name="35411"></a>float[][][][][] g;
<a name="35412"></a>float[][][] h;
</pre><a name="35427"></a>
We do not recommend such "mixed notation" for array declarations.
<p><a name="32644"></a>
<h3>14.3.2    Scope of Local Variable Declarations</h3>
<a name="45940"></a>
The scope of a local variable declared in a block is the rest of the block, including 
its own initializer. The name of the local variable parameter may not be redeclared 
as a local variable or exception parameter within its scope, or a compile-time error 
occurs; that is, hiding the name of a local variable is not permitted.
<p><a name="45944"></a>
A local variable cannot be referred to using a qualified name <a href="6.doc.html#33916">(&#167;6.6)</a>, only a simple name.<p>
<a name="45938"></a>
The example:<p>
<pre><a name="32598"></a>
class Test {
<a name="32601"></a>	static int x;
<a name="32599"></a>	public static void main(String[] args) {
<a name="32600"></a>		int x = x;
<a name="32602"></a>	}
<a name="32603"></a>}
</pre><a name="32604"></a>
causes a compile-time error because the initialization of <code>x</code> is within the scope of 
the declaration of <code>x</code> as a local variable, and the local <code>x</code> does not yet have a value 
and cannot be used.
<p><a name="32610"></a>
The following program does compile:<p>
<pre><a name="32613"></a>
class Test {
<a name="32614"></a>	static int x;
<a name="32615"></a>	public static void main(String[] args) {
<a name="32616"></a>		int x = (x=2)*2;
<a name="32619"></a>		System.out.println(x);
<a name="32617"></a>	}
<a name="32618"></a>}
</pre><a name="32611"></a>
because the local variable <code>x</code> is definitely assigned <a href="16.doc.html#25979">(&#167;16)</a> before it is used. It prints:
<p><pre><a name="236246"></a>4
</pre><a name="5925"></a>
Here is another example:<p>
<pre><a name="5926"></a>
class Test {
<a name="32622"></a>	public static void main(String[] args) {
<a name="50177"></a>		System.out.print("2+1=");
<a name="5927"></a>		int two = 2, three = two + 1;
<a name="5928"></a>		System.out.println(three);
<a name="50179"></a>	}
<a name="5929"></a>}
</pre><a name="17863"></a>
which compiles correctly and produces the output:
<p><pre><a name="17864"></a>2+1=3
</pre><a name="7616"></a>
The initializer for <code>three</code> can correctly refer to the variable <code>two</code> declared in an earlier
declarator, and the method invocation in the next line can correctly refer to the 
variable <code>three</code> declared earlier in the block.
<p><a name="35349"></a>
The scope of a local variable declared in a <code>for</code> statement is the rest of the <code>for</code> statement, including its own initializer.<p>
<a name="32558"></a>
If a declaration of an identifier as a local variable appears within the scope of a parameter or local variable of the same name, a compile-time error occurs. Thus the following example does not compile:<p>
<pre><a name="32645"></a>
class Test {
<a name="32646"></a>	public static void main(String[] args) {
<a name="50181"></a>		int i;
<a name="32663"></a>		for (int i = 0; i &lt; 10; i++)
<a name="32664"></a>			System.out.println(i);
<a name="32652"></a>	}
<a name="32653"></a>}
</pre><a name="32559"></a>
This restriction helps to detect some otherwise very obscure bugs. (A similar 
restriction on hiding of members by local variables was judged impractical, 
because the addition of a member in a superclass could cause subclasses to have to 
rename local variables.)
<p><a name="35322"></a>
On the other hand, local variables with the same name may be declared in two separate blocks or <code>for</code> statements neither of which contains the other. Thus:<p>
<pre><a name="17888"></a>
class Test {
<a name="17889"></a>	public static void main(String[] args) {
<a name="17890"></a>		for (int i = 0; i &lt; 10; i++)
<a name="17891"></a>			System.out.print(i + " ");
<a name="17892"></a>		for (int i = 10; i &gt; 0; i--)
<a name="17893"></a>			System.out.print(i + " ");
<a name="17894"></a>		System.out.println();
<a name="17895"></a>	}
<a name="17896"></a>}
</pre><a name="17897"></a>
compiles without error and, when executed, produces the output:
<p><pre><a name="17881"></a>0 1 2 3 4 5 6 7 8 9 10 9 8 7 6 5 4 3 2 1
</pre><a name="32673"></a>
<h3>14.3.3    Hiding of Names by Local Variables</h3>
<a name="32716"></a>
If a name declared as a local variable is already declared as a field or type name, 
then that outer declaration is hidden throughout the scope of the local variable. 
The field or type name can almost always <a href="6.doc.html#11186">(&#167;6.8)</a> still be accessed using an appropriately
qualified name. For example, the keyword <code>this</code> can be used to access a 
hidden field <code>x</code>, using the form <code>this.x</code>. Indeed, this idiom typically appears in constructors
<a href="8.doc.html#41652">(&#167;8.6)</a>:
<p><pre><a name="32566"></a>
class Pair {
<a name="32567"></a>	Object first, second;
<a name="32568"></a>	public Pair(Object first, Object second) {
<a name="32569"></a>		this.first = first;
<a name="32570"></a>		this.second = second;
<a name="32571"></a>	}
<a name="32572"></a>}
</pre><a name="32573"></a>
In this example, the constructor takes parameters having the same names as the 
fields to be initialized. This is simpler than having to invent different names for 
the parameters and is not too confusing in this stylized context. In general, however,
it is considered poor style to have local variables with the same names as 
fields.
<p><a name="32717"></a>
<h3>14.3.4    Execution of Local Variable Declarations</h3>
<a name="32574"></a>
A local variable declaration statement is an executable statement. Every time it is 
executed, the declarators are processed in order from left to right. If a declarator 
has an initialization expression, the expression is evaluated and its value is 
assigned to the variable. If a declarator does not have an initialization expression, 
then a Java compiler must prove, using exactly the algorithm given in <a href="16.doc.html#25979">&#167;16</a>, that 
every reference to the variable is necessarily preceded by execution of an assignment
to the variable. If this is not the case, then a compile-time error occurs.
<p><a name="32578"></a>
Each initialization (except the first) is executed only if the evaluation of the preceding initialization expression completes normally. Execution of the local variable declaration completes normally only if evaluation of the last initialization expression completes normally; if the local variable declaration contains no initialization expressions, then executing it always completes normally.<p>
<a name="32584"></a>
<h2>14.4    Statements</h2>
<a name="32588"></a>
There are many kinds of statements in the Java language. Most correspond to 
statements in the C and C++ languages, but some are unique to Java.
<p><a name="5958"></a>
As in C and C++, the Java <code>if</code> statement suffers from the so-called "dangling <code>else</code> problem," illustrated by this misleadingly formatted example:<p>
<pre><a name="17933"></a>
if (door.isOpen())
<a name="5960"></a>	if (resident.isVisible())
<a name="35428"></a>		resident.greet("Hello!");
<a name="5961"></a>else door.bell.ring();								// A "dangling else"
</pre><a name="5962"></a>
The problem is that both the outer <code>if</code> statement and the inner <code>if</code> statement might 
conceivably own the <code>else</code> clause. In this example, one might surmise that the programmer
intended the <code>else</code> clause to belong to the outer <code>if</code> statement. The Java 
language, like C and C++ and many languages before them, arbitrarily decree that 
an <code>else</code> clause belongs to the innermost <code>if</code> to which it might possibly belong. 
This rule is captured by the following grammar:
<p><ul><pre>
<i>Statement:<br>
	StatementWithoutTrailingSubstatement<br>
	LabeledStatement<br>
	IfThenStatement<br>
	IfThenElseStatement<br>
	WhileStatement<br>
	ForStatement
</i>
<i>StatementNoShortIf:<br>
	StatementWithoutTrailingSubstatement<br>
	LabeledStatementNoShortIf<br>
	IfThenElseStatementNoShortIf<br>
	WhileStatementNoShortIf<br>
	ForStatementNoShortIf
</i>
<i>StatementWithoutTrailingSubstatement:<br>
	Block<br>
	EmptyStatement<br>
	ExpressionStatement<br>
	SwitchStatement<br>
	DoStatement<br>
	BreakStatement<br>
	ContinueStatement<br>
	ReturnStatement<br>
	SynchronizedStatement<br>
	ThrowStatement<br>
	TryStatement
</i></pre></ul><a name="8344"></a>
The following are repeated from <a href="14.doc.html#5991">&#167;14.8</a> to make the presentation here clearer:
<p><ul><pre>
<i>IfThenStatement:<br>
</i>	<code>if ( </code><i>Expression</i><code> ) </code><i>Statement
</i>
<i>IfThenElseStatement:<br>
</i>	<code>if ( </code><i>Expression</i><code> ) </code><i>StatementNoShortIf</i><code> else </code><i>Statement
</i>
<i>IfThenElseStatementNoShortIf:<br>
</i>	<code>if ( </code><i>Expression</i><code> ) </code><i>StatementNoShortIf</i><code> else </code><i>StatementNoShortIf
</i></pre></ul><a name="5969"></a>
Statements are thus grammatically divided into two categories: those that might end in an <code>if</code> statement that has no <code>else</code> clause (a "short <code>if</code> statement") and those that definitely do not. Only statements that definitely do not end in a short <code>if</code> statement may appear as an immediate substatement before the keyword <code>else</code> in an <code>if</code> statement that does have an <code>else</code> clause. This simple rule prevents the "dangling <code>else</code>" problem. The execution behavior of a statement with the "no short <code>if</code>" restriction is identical to the execution behavior of the same kind of statement without the "no short <code>if</code>" restriction; the distinction is drawn purely to resolve the syntactic difficulty.<p>
<a name="5970"></a>
<h2>14.5    The Empty Statement</h2>
<a name="5971"></a>
An <i>empty statement</i> does nothing.
<p><ul><pre>
<i>EmptyStatement:<br>
</i>	<code>;
</code></pre></ul><a name="5973"></a>
Execution of an empty statement always completes normally.
<p><a name="78993"></a>
<h2>14.6    Labeled Statements</h2>
<a name="78994"></a>
Statements may have <i>label</i> prefixes.
<p><ul><pre>
<i>LabeledStatement:<br>
</i>	<i>Identifier</i><code> : </code><i>Statement
</i>
<i>LabeledStatementNoShortIf:<br>
</i>	<i>Identifier</i><code> : </code><i>StatementNoShortIf
</i></pre></ul><a name="78997"></a>
The <i>Identifier</i> is declared to be the label of the immediately contained <i>Statement</i>.
<p><a name="17941"></a>
Unlike C and C++, the Java language has no <code>goto</code> statement; identifier statement labels are used with <code>break</code> <a href="14.doc.html#6842">(&#167;14.13)</a> or <code>continue</code> <a href="14.doc.html#6122">(&#167;14.14)</a> statements appearing anywhere within the labeled statement.<p>
<a name="78998"></a>
A statement labeled by an identifier must not appear anywhere within another statement labeled by the same identifier, or a compile-time error will occur. Two statements can be labeled by the same identifier only if neither statement contains the other.<p>
<a name="35441"></a>
There is no restriction against using the same identifier as a label and as the name of a package, class, interface, method, field, parameter, or local variable. Use of an identifier to label a statement does not hide a package, class, interface, method, field, parameter, or local variable with the same name. Use of an identifier &#32;as a local variable or as the parameter of an exception handler <a href="14.doc.html#79311">(&#167;14.18)</a> does not hide a statement label with the same name.<p>
<a name="79000"></a>
A labeled statement is executed by executing the immediately contained <i>Statement</i>. If the statement is labeled by an <i>Identifier</i> and the contained <i>Statement</i> completes abruptly because of a <code>break</code> with the same <i>Identifier</i>, then the labeled statement completes normally. In all other cases of abrupt completion of the <i>Statement</i>, &#32;the labeled statement completes abruptly for the same reason.<p>
<a name="5984"></a>
<h2>14.7    Expression Statements</h2>
<a name="5985"></a>
Certain kinds of expressions may be used as statements by following them with 
semicolons:
<p><ul><pre>
<i>ExpressionStatement:<br>
</i>	<i>StatementExpression</i><code> ;
</code>
<i>StatementExpression:<br>
</i>	<i>Assignment<br>
	PreIncrementExpression<br>
	PreDecrementExpression<br>
	PostIncrementExpression<br>
	PostDecrementExpression<br>
	MethodInvocation<br>
</i>	<i>ClassInstanceCreationExpression
</i></pre></ul><a name="5988"></a>
An <i>expression statement</i> is executed by evaluating the expression; if the expression has a value, the value is discarded. Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.<p>
<a name="5989"></a>
Unlike C and C++, the Java language allows only certain forms of expressions to be used as expression statements. Note that Java does not allow a "cast to <code>void</code>"-<code>void</code> is not a type in Java-so the traditional C trick of writing an expression statement such as:<p>
<pre><a name="35455"></a>(void) ... ;								// This idiom belongs to C, not to Java!
</pre><a name="35457"></a>
does not work in Java. On the other hand, Java allows all the most useful kinds of 
expressions in expressions statements, and Java does not require a method invocation
used as an expression statement to invoke a <code>void</code> method, so such a trick is 
almost never needed. If a trick is needed, either an assignment statement <a href="15.doc.html#5281">(&#167;15.25)</a> 
or a local variable declaration statement <a href="14.doc.html#5920">(&#167;14.3)</a> can be used instead.
<p><a name="5991"></a>
<h2>14.8    The <code>if</code> Statement</h2>
<a name="35469"></a>
The <code>if</code> statement allows conditional execution of a statement or a conditional 
choice of two statements, executing one or the other but not both.
<p><ul><pre>
<i>IfThenStatement:<br>
</i>	<code>if ( </code><i>Expression</i><code> ) </code><i>Statement
</i>
<i>IfThenElseStatement:<br>
</i>	<code>if ( </code><i>Expression</i><code> ) </code><i>StatementNoShortIf</i><code> else </code><i>Statement
</i>
<i>IfThenElseStatementNoShortIf:<br>
</i>	<code>if ( </code><i>Expression</i><code> ) </code><i>StatementNoShortIf</i><code> else </code><i>StatementNoShortIf
</i></pre></ul><a name="24313"></a>
The <i>Expression</i> must have type <code>boolean</code>, or a compile-time error occurs.
<p><a name="237433"></a>
<h3>14.8.1    The <code>if-then</code> Statement</h3>
<a name="35473"></a>
An <code>if</code>-<code>then</code> statement is executed by first evaluating the <i>Expression</i>. If evaluation 
of the <i>Expression</i> completes abruptly for some reason, the <code>if</code>-<code>then</code> statement 
completes abruptly for the same reason. Otherwise, execution continues by making
a choice based on the resulting value:
<p><ul><a name="5997"></a>
<li>If the value is <code>true</code>, then the contained <i>Statement</i> is executed; the <code>if</code>-<code>then</code> statement completes normally only if execution of the <i>Statement</i> completes normally.
<a name="5998"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>if</code>-<code>then</code> statement completes normally.
</ul><a name="237435"></a>
<h3>14.8.2    The <code>if-then-else</code> Statement</h3>
<a name="236506"></a>
An <code>if</code>-<code>then</code>-<code>else</code> statement is executed by first evaluating the <i>Expression</i>. If 
evaluation of the <i>Expression</i> completes abruptly for some reason, then the <code>if</code>-
<code>then</code>-<code>else</code> &#32;statement completes abruptly for the same reason. Otherwise, execution
continues by making a choice based on the resulting value:
<p><ul><a name="6000"></a>
<li>If the value is <code>true</code>, then the first contained <i>Statement</i> (the one before the <code>else</code> keyword) is executed; the <code>if</code>-<code>then</code>-<code>else</code> statement completes normally only if execution of that statement completes normally.
<a name="42708"></a>
<li>If the value is <code>false</code>, then the second contained <i>Statement</i> (the one after the <code>else</code> keyword) is executed; the <code>if</code>-<code>then</code>-<code>else</code> statement completes normally only if execution of that statement completes normally. 
</ul><a name="35518"></a>
<h2>14.9    The <code>switch</code> Statement</h2>
<a name="35522"></a>
The <code>switch</code> statement transfers control to one of several statements depending on 
the value of an expression.
<p><ul><pre>
<i>SwitchStatement:<br>
</i><code>	switch ( </code><i>Expression</i><code> ) </code><i>SwitchBlock
</i>
<i>SwitchBlock:<br>
</i>	<code>{ </code>S<i>witchBlockStatementGroups</i><sub><i>opt</i></sub><code> </code><i>SwitchLabels</i><sub><i>opt</i></sub><code> }
</code>
<i>SwitchBlockStatementGroups:<br>
</i><code>	</code><i>SwitchBlockStatementGroup<br>
</i><code>	</code><i>SwitchBlockStatementGroups</i><code> </code><i>SwitchBlockStatementGroup
</i>
<i>SwitchBlockStatementGroup:<br>
</i>	<i>SwitchLabels</i><code> </code><i>BlockStatements
</i>
<i>SwitchLabels:<br>
</i>	<i>SwitchLabel<br>
</i>	<i>SwitchLabels</i><code> </code><i>SwitchLabel
</i>
<i>SwitchLabel:<br>
</i><code>	case </code><i>ConstantExpression</i><code> :<br>
	default :
</code></pre></ul><a name="237298"></a>
The type of the <i>Expression</i> must be <code>char</code>, <code>byte</code>, <code>short</code>, or <code>int</code>, or a compile-time error occurs.<p>
<a name="237299"></a>
The body of a <code>switch</code> statement must be a block. Any statement immediately contained by the block may be labeled with one or more <code>case</code> or <code>default</code> labels. These labels are said to be <i>associated</i> with the <code>switch</code> statement, as are the values of the constant expressions <a href="15.doc.html#5313">(&#167;15.27)</a> in the <code>case</code> labels.<p>
<a name="237328"></a>
All of the following must be true, or a compile-time error will result:<p>
<ul><a name="237329"></a>
<li>Every <code>case</code> constant expression associated with a <code>switch</code> statement must be assignable <a href="5.doc.html#170768">(&#167;5.2)</a> to the type of the <code>switch</code> <i>Expression</i>.
<a name="237333"></a>
<li>No two of the <code>case</code> constant expressions associated with a <code>switch</code> statement may have the same value.
<a name="237334"></a>
<li>At most one <code>default</code> label may be associated with the same <code>switch</code> statement.
</ul><a name="237303"></a>
In C and C++ the body of a <code>switch</code> statement can be a statement and statements with <code>case</code> labels do not have to be immediately contained by that statement. Consider the simple loop:<p>
<pre><a name="237281"></a>for (i = 0; i &lt; n; ++i) foo();
</pre><a name="237282"></a>
where <code>n</code> is known to be positive. A trick known as <i>Duff's device</i> can be used in C 
or C++ to unroll the loop, but this is not valid Java code:
<p><pre><a name="237283"></a>
int q = (n+7)/8;
<a name="237284"></a>switch (n%8) {
<a name="237285"></a>case 0:			do {		foo();				// Great C hack, Tom,
<a name="237286"></a>case 7:					foo();				// but it's not valid in Java.
<a name="237287"></a>case 6:					foo();
<a name="237288"></a>case 5:					foo();
<a name="237289"></a>case 4:					foo();
<a name="237290"></a>case 3:					foo();
<a name="237291"></a>case 2:					foo();
<a name="237292"></a>case 1:					foo();
<a name="237293"></a>			} while (--q &gt;= 0);
<a name="237294"></a>}
</pre><a name="237295"></a>
Fortunately, this trick does not seem to be widely known or used. Moreover, it is 
less needed nowadays; this sort of code transformation is properly in the province 
of state-of-the-art optimizing compilers.
<p><a name="217138"></a>
When the <code>switch</code> statement is executed, first the <i>Expression</i> is evaluated. If evaluation of the <i>Expression</i> completes abruptly for some reason, the <code>switch</code> statement completes abruptly for the same reason. Otherwise, execution continues by comparing the value of the <i>Expression </i>with each <code>case</code> constant. Then there is a choice:<p>
<ul><a name="6012"></a>
<li>If one of the <code>case</code> constants is equal to the value of the expression, then we say that the <code>case</code> matches, and all statements after the matching <code>case</code> label in the switch block, if any, are executed in sequence. If all these statements complete normally, or if there are no statements after the matching <code>case</code> label, then the entire <code>switch</code> statement completes normally.
</ul><ul><a name="6013"></a>
<li>If no <code>case</code> matches but there is a <code>default</code> label, then all statements after the matching <code>default</code> label in the switch block, if any, are executed in sequence. If all these statements complete normally, or if there are no statements after the <code>default</code> label, then the entire <code>switch</code> statement completes normally.
<a name="6014"></a>
<li>If no <code>case</code> matches and there is no <code>default</code> label, then no further action is taken and the <code>switch</code> statement completes normally.
</ul><a name="237254"></a>
If any statement immediately contained by the <i>Block</i> body of the <code>switch</code> statement completes abruptly, it is handled as follows:<p>
<ul><a name="6017"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>switch</code> statement completes normally.
<a name="237272"></a>
<li>If execution of the <i>Statement</i> completes abruptly for any other reason, the <code>switch</code> statement completes abruptly for the same reason. The case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="14.doc.html#78993">(&#167;14.6)</a>.
</ul><a name="237607"></a>
As in C and C++, execution of statements in a switch block "falls through labels" in Java. For example, the program:<p>
<pre><a name="237615"></a>
class Toomany {
<a name="237616"></a>
	static void howMany(int k) {
<a name="237617"></a>		switch (k) {
<a name="237618"></a>		case 1:			System.out.print("one ");
<a name="237619"></a>		case 2:			System.out.print("too ");
<a name="237620"></a>		case 3:			System.out.println("many");
<a name="237621"></a>		}
<a name="237622"></a>	}
<br><a name="237623"></a>
	public static void main(String[] args) {
<a name="237624"></a>		howMany(3);
<a name="237625"></a>		howMany(2);
<a name="237626"></a>		howMany(1);
<a name="237627"></a>	}
<br><a name="237628"></a>}
</pre><a name="237629"></a>
contains a switch block in which the code for each case falls through into the code 
for the next case. As a result, the program prints:
<p><pre><a name="237632"></a>
many
<a name="237633"></a>too many
<a name="237634"></a>one too many
</pre><a name="237630"></a>
If code is not to fall through case to case in this manner, then <code>break</code> statements 
should be used, as in this example:
<p><pre><a name="237644"></a>
class Twomany {
<a name="237645"></a>
	static void howMany(int k) {
<a name="237646"></a>		switch (k) {
<a name="237647"></a>		case 1:			System.out.println("one");
<a name="237648"></a>					break;					// exit the switch
<a name="237649"></a>		case 2:			System.out.println("two");
<a name="237650"></a>					break;					// exit the switch
<a name="237651"></a>		case 3:			System.out.println("many");
<a name="237652"></a>					break;					// not needed, but good style
<a name="237653"></a>		}
<a name="237654"></a>	}
<br><a name="237655"></a>
	public static void main(String[] args) {
<a name="237656"></a>		howMany(1);
<a name="237657"></a>		howMany(2);
<a name="237658"></a>		howMany(3);
<a name="237659"></a>	}
<br><a name="237660"></a>}
</pre><a name="237642"></a>
This program prints:
<p><pre><a name="237670"></a>
one
<a name="237671"></a>two
<a name="237672"></a>many
</pre><a name="237277"></a>
<h2>14.10    The <code>while</code> Statement</h2>
<a name="237278"></a>
The <code>while</code> statement executes an <i>Expression</i> and a <i>Statement</i> repeatedly until the 
value of the <i>Expression</i> is <code>false</code>.
<p><ul><pre>
<i>WhileStatement:<br>
</i>	<code>while ( </code><i>Expression</i><code> ) </code><i>Statement
</i>
<i>WhileStatementNoShortIf:<br>
</i>	<code>while ( </code><i>Expression</i><code> ) </code><i>StatementNoShortIf
</i></pre></ul><a name="35485"></a>
The <i>Expression</i> must have type <code>boolean</code>, or a compile-time error occurs.
<p><a name="217153"></a>
A <code>while</code> statement is executed by first evaluating the <i>Expression</i>. If evaluation of the <i>Expression</i> completes abruptly for some reason, the <code>while</code> statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:<p>
<ul><a name="6028"></a>
<li>If the value is <code>true</code>, then the contained <i>Statement</i> is executed. Then there is a choice:
<ul>
<a name="6029"></a>
<li>If execution of the <i>Statement</i> completes normally, then the entire <code>while</code> statement is executed again, beginning by re-evaluating the <i>Expression</i>.
<a name="6030"></a>
<li>If execution of the <i>Statement</i> completes abruptly, see <a href="14.doc.html#21139">&#167;14.10.1</a> below.
</ul>
<a name="6031"></a>
<li>If the value of the <i>Expression</i> is <code>false</code>, no further action is taken and the <code>while</code> statement completes normally.
</ul><a name="6032"></a>
If the value of the <i>Expression</i> is <code>false</code> the first time it is evaluated, then the 
<i>Statement</i> &#32;is not executed.
<p><a name="21139"></a>
<h3>14.10.1    Abrupt Completion</h3>
<a name="6033"></a>
Abrupt completion of the contained <i>Statement</i> is handled in the following manner:
<p><ul><a name="6034"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>while</code> statement completes normally.
<ul>
<a name="6035"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>continue</code> with no label, then the entire <code>while</code> statement is executed again.
<a name="79063"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79064"></a>
<li>If the <code>while</code> statement has label <i>L</i>, then the entire <code>while</code> statement is executed again.
<a name="79065"></a>
<li>If the <code>while</code> statement does not have label <i>L</i>, the <code>while</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="79070"></a>
<li>If execution of the <i>Statement</i> completes abruptly for any other reason, the <code>while</code> statement completes abruptly for the same reason. Note that the case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="14.doc.html#78993">(&#167;14.6)</a>.
</ul>
</ul><a name="6045"></a>
<h2>14.11    The <code>do</code> Statement</h2>
<a name="35504"></a>
The <code>do</code> statement executes a <i>Statement</i> and an <i>Expression</i> repeatedly until the 
value of the <i>Expression</i> is <code>false</code>.
<p><ul><pre>
<i>DoStatement:<br>
</i><code>	do </code><i>Statement</i><code> while ( </code><i>Expression</i><code> ) ;
</code></pre></ul><a name="35496"></a>
The <i>Expression</i> must have type <code>boolean</code>, or a compile-time error occurs.
<p><a name="6048"></a>
A <code>do</code> statement is executed by first executing the <i>Statement</i>. Then there is a choice:<p>
<ul><a name="217176"></a>
<li>If execution of the <i>Statement</i> completes normally, then the <i>Expression</i> is evaluated. If evaluation of the <i>Expression</i> completes abruptly for some reason, the <code>do</code> statement completes abruptly for the same reason. Otherwise, there is a choice based on the resulting value:
<ul>
<a name="217172"></a>
<li>If the value is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="6051"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="6052"></a>
<li>If execution of the <i>Statement</i> completes abruptly, see <a href="14.doc.html#45366">&#167;14.11.1</a> below.
</ul><a name="6053"></a>
Executing a <code>do</code> statement always executes the contained <i>Statement</i> at least once.
<p><a name="45366"></a>
<h3>14.11.1    Abrupt Completion</h3>
<a name="43246"></a>
Abrupt completion of the contained <i>Statement</i> is handled in the following manner:
<p><ul><a name="6714"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>break</code> with no label, then no further action is taken and the <code>do</code> statement completes normally.
<a name="6056"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>continue</code> with no label, then the <i>Expression</i> is evaluated. Then there is a choice based on the resulting value:
<ul>
<a name="6057"></a>
<li>If the value is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="6058"></a>
<li>If the value is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="79109"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79110"></a>
<li>If the <code>do</code> statement has label <i>L</i>, then the <i>Expression</i> is evaluated. Then there is a choice:
<ul>
<a name="79111"></a>
<li>If the value of the <i>Expression</i> is <code>true</code>, then the entire <code>do</code> statement is executed again.
<a name="79112"></a>
<li>If the value of the <i>Expression</i> is <code>false</code>, no further action is taken and the <code>do</code> statement completes normally.
</ul>
<a name="79113"></a>
<li>If the <code>do</code> statement does not have label <i>L</i>, the <code>do</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="24581"></a>
<li>If execution of the <i>Statement</i> completes abruptly for any other reason, the <code>do</code> statement completes abruptly for the same reason. The case of abrupt completion because of a <code>break</code> with a label is handled by the general rule <a href="14.doc.html#78993">(&#167;14.6)</a>.
</ul><a name="24585"></a>
<h3>14.11.2    Example of <code>do</code> statement</h3>
<a name="43313"></a>
The following code is one possible implementation of the <code>toHexString</code> method 
<a href="javalang.doc6.html#7332">(&#167;20.7.14)</a> of class <code>Integer</code>:
<p><pre><a name="43303"></a>
public static String toHexString(int i) {
<a name="43304"></a>	StringBuffer buf = new StringBuffer(8);
<a name="43305"></a>	do {
<a name="43306"></a>		buf.append(Character.forDigit(i &amp; 0xF, 16));
<a name="43307"></a>		i &gt;&gt;&gt;= 4;
<a name="43308"></a>	} while (i != 0);
<a name="43309"></a>	return buf.reverse().toString();
<a name="43310"></a>}
</pre><a name="24586"></a>
Because at least one digit must be generated, the <code>do</code> statement is an appropriate 
control structure.
<p><a name="24588"></a>
<h2>14.12    The <code>for</code> Statement</h2>
<a name="35537"></a>
The <code>for</code> statement executes some initialization code, then executes an <i>Expression</i>, 
a <i>Statement</i>, and some update code repeatedly until the value of the <i>Expression</i> is 
<code>false</code>.
<p><ul><pre>
<i>ForStatement:<br>
</i>	<code>for ( </code><i>ForInit</i><sub><i>opt</i></sub><code> ; </code><i>Expression</i><sub><i>opt</i></sub><code> ; </code><i>ForUpdate</i><sub><i>opt</i></sub><code> )<br>
</code>		<i>Statement
</i>
<i>ForStatementNoShortIf:<br>
</i>	<code>for ( </code><i>ForInit</i><sub><i>opt</i></sub><code> ; </code><i>Expression</i><sub><i>opt</i></sub><code> ; </code><i>ForUpdate</i><sub><i>opt</i></sub><code> )<br>
		</code><i>StatementNoShortIf
</i>
<i>ForInit:<br>
</i>	<i>StatementExpressionList<br>
	LocalVariableDeclaration
</i>
<i>ForUpdate:<br>
	StatementExpressionList
</i>
<i>StatementExpressionList:<br>
	StatementExpression<br>
	StatementExpressionList</i><code> , </code><i>StatementExpression
</i></pre></ul><a name="35529"></a>
The <i>Expression</i> must have type <code>boolean</code>, or a compile-time error occurs.
<p><a name="45367"></a>
<h3>14.12.1    Initialization of <code>for</code> statement</h3>
<a name="11751"></a>
A <code>for</code> statement is executed by first executing the <i>ForInit</i> code:
<p><ul><a name="6081"></a>
<li>If the <i>ForInit</i> code is a list of statement expressions <a href="14.doc.html#5984">(&#167;14.7)</a>, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the <code>for</code> statement completes abruptly for the same reason; any <i>ForInit</i> statement expressions to the right of the one that completed abruptly are not evaluated.
<a name="6082"></a>
<li>If the <i>ForInit</i> code is a local variable declaration, it is executed as if it were a local variable declaration statement <a href="14.doc.html#5920">(&#167;14.3)</a> appearing in a block. In this case, the scope of a declared local variable is its own initializer and any further declarators in the <i>ForInit</i> part, plus the <i>Expression</i>, <i>ForUpdate</i>, and contained <i>Statement</i> of the <code>for</code> statement. If execution of the local variable declaration completes abruptly for any reason, the <code>for</code> statement completes abruptly for the same reason.
<a name="6083"></a>
<li>If the <i>ForInit</i> part is not present, no action is taken.
</ul><a name="45370"></a>
<h3>14.12.2    Iteration of <code>for</code> statement</h3>
<a name="217196"></a>
Next, a <code>for</code> iteration step is performed, as follows:
<p><ul><a name="217202"></a>
<li>If the <i>Expression</i> is present, it is evaluated, and if evaluation of the <i>Expression</i> completes abruptly, the <code>for</code> statement completes abruptly for the same reason. Otherwise, there is then a choice based on the presence or absence of the <i>Expression</i> and the resulting value if the <i>Expression</i> is present:
<ul>
<a name="6086"></a>
<li>If the <i>Expression</i> is not present, or it is present and the value resulting from its evaluation is <code>true</code>, then the contained <i>Statement</i> is executed. Then there is a choice:
<ul>
<a name="6087"></a>
<li>If execution of the <i>Statement</i> completes normally, then the following two steps are performed in sequence:
<ul>
<a name="45351"></a>
<li>First, if the <i>ForUpdate</i> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the <code>for</code> statement completes abruptly for the same reason; any <i>ForUpdate</i> statement expressions to the right of the one that completed abruptly are not evaluated. If the <i>ForUpdate</i> part is not present, no action is taken.
<a name="236152"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="236156"></a>
<li>If execution of the <i>Statement</i> completes abruptly, see <a href="14.doc.html#45371">&#167;14.12.3</a> below.
</ul>
<a name="236157"></a>
<li>If the <i>Expression</i> is present and the value resulting from its evaluation is <code>false</code>, no further action is taken and the <code>for</code> statement completes normally.
</ul>
</ul><a name="6092"></a>
If the value of the <i>Expression</i> is <code>false</code> the first time it is evaluated, then the <i>Statement</i> is not executed.<p>
<a name="6093"></a>
If the <i>Expression</i> is not present, then the only way a <code>for</code> statement can complete normally is by use of a <code>break</code> statement.<p>
<a name="45371"></a>
<h3>14.12.3    Abrupt Completion of <code>for</code> statement</h3>
<a name="43248"></a>
Abrupt completion of the contained <i>Statement</i> is handled in the following manner:
<p><ul><a name="6095"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>for</code> statement completes normally.
<a name="6096"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>continue</code> with no label, then the following two steps are performed in sequence:
<ul>
<a name="6097"></a>
<li>First, if the <i>ForUpdate</i> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If the <i>ForUpdate</i> &#32;part is not present, no action is taken.
<a name="6098"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="79161"></a>
<li>If execution of the <i>Statement</i> completes abruptly because of a <code>continue</code> with label <i>L</i>, then there is a choice:
<ul>
<a name="79162"></a>
<li>If the <code>for</code> statement has label <i>L</i>, then the following two steps are performed in sequence:
<ul>
<a name="79163"></a>
<li>First, if the <i>ForUpdate</i> part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If the<i> ForUpdate</i> is not present, no action is taken.
<a name="79164"></a>
<li>Second, another <code>for</code> iteration step is performed.
</ul>
<a name="79165"></a>
<li>If the <code>for</code> statement does not have label <i>L</i>, the <code>for</code> statement completes abruptly because of a <code>continue</code> with label <i>L</i>.
</ul>
<a name="6104"></a>
<li>If execution of the <i>Statement</i> completes abruptly for any other reason, the <code>for</code> statement completes abruptly for the same reason. Note that the case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements <a href="14.doc.html#78993">(&#167;14.6)</a>.
</ul><a name="6842"></a>
<h2>14.13    The <code>break</code> Statement</h2>
<a name="35540"></a>
A break statement transfers control out of an enclosing statement.
<p><ul><pre>
<i>BreakStatement:<br>
</i>	<code>break </code><i>Identifier</i><sub><i>opt</i></sub><code> ;
</code></pre></ul><a name="43392"></a>
A <code>break</code> statement with no label attempts to transfer control to the innermost enclosing <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement; this statement, which is called the <i>break target</i>, then immediately completes normally. To be precise, a <code>break</code> statement with no label always completes abruptly, the reason being a <code>break</code> with no label. If no <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement encloses the <code>break</code> statement, a compile-time error occurs.<p>
<a name="79188"></a>
A <code>break</code> statement with label <i>Identifier</i> attempts to transfer control to the enclosing labeled statement <a href="14.doc.html#78993">(&#167;14.6)</a> that has the same <i>Identifier</i> as its label; this statement, which is called the <i>break target</i>, then immediately completes normally. In this case, the <code>break</code> target need not be a <code>while</code>, <code>do</code>, <code>for</code>, or <code>switch</code> statement. To be precise, a <code>break</code> statement with label <i>Identifier</i> always completes abruptly, the reason being a <code>break</code> with label <i>Identifier</i>. If no labeled statement with <i>Identifier</i> &#32;as its label encloses the <code>break</code> statement, a compile-time error occurs.<p>
<a name="43504"></a>
It can be seen, then, that a <code>break</code> statement always completes abruptly.<p>
<a name="43404"></a>
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="14.doc.html#79311">(&#167;14.18)</a> within the break target whose <code>try</code> blocks contain the <code>break</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the break target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>break</code> statement.<p>
<a name="18004"></a>
In the following example, a mathematical graph is represented by an array of arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself. In this example it is assumed that there are no redundant edges; that is, for any two nodes <i>P</i> and <i>Q</i>, where <i>Q</i> may be the same as <i>P</i>, there is at most one edge from <i>P</i> to <i>Q</i>. Nodes are represented by integers, and there is an edge from node <i>i</i> to node <code>edges[</code><i>i</i><code>][</code><i>j</i><code>]</code> for every <i>i</i> and <i>j</i> for which the array reference <code>edges[</code><i>i</i><code>][</code><i>j</i><code>]</code> does not throw an <code>IndexOutOfBoundsException</code>.<p>
<a name="42801"></a>
The task of the method <code>loseEdges</code>, given integers <i>i</i> and <i>j</i>, is to construct a new graph by copying a given graph but omitting the edge from node <i>i</i> to node <i>j</i>, if any, and the edge from node <i>j</i> to node <i>i</i>, if any:<p>
<pre><a name="42813"></a>
class Graph {
<a name="42814"></a>	int edges[][];
<a name="42816"></a>	public Graph(int[][] edges) { this.edges = edges; }
<a name="42818"></a>
	public Graph loseEdges(int i, int j) {
<a name="42819"></a>		int n = edges.length;
<a name="42820"></a>		int[][] newedges = new int[n][];
<a name="42821"></a>		for (int k = 0; k &lt; n; ++k) {
<a name="42822"></a>
			edgelist: {
<a name="42823"></a>				int z;
<a name="42824"></a>
				search: {
<a name="42825"></a>					if (k == i) {
<a name="42826"></a>						for (z = 0; z &lt; edges[k].length; ++z)
<a name="42827"></a>							if (edges[k][z] == j)
<a name="42828"></a>								break search;
<a name="42829"></a>					} else if (k == j) {
<a name="42831"></a>						for (z = 0; z &lt; edges[k].length; ++z)
<a name="42832"></a>							if (edges[k][z] == i)
<a name="42833"></a>								break search;
<a name="42834"></a>					}
<a name="42835"></a>					// No edge to be deleted; share this list.
<a name="42836"></a>					newedges[k] = edges[k];
<a name="42837"></a>					break edgelist;
<a name="42838"></a>				}//search
<a name="42839"></a>				// Copy the list, omitting the edge at position z.
<a name="42840"></a>				int m = edges[k].length - 1;
<a name="42841"></a>				int ne[] = new int[m];
<a name="42842"></a>				System.arraycopy(edges[k], 0, ne, 0, z);
<a name="42843"></a>				System.arraycopy(edges[k], z+1, ne, z, m-z);
<a name="42879"></a>				newedges[k] = ne;
<a name="42844"></a>			}//edgelist
<a name="42845"></a>		}
<a name="42846"></a>		return new Graph(newedges);
<a name="42847"></a>	}
<a name="42848"></a>}
</pre><a name="42887"></a>
Note the use of two statement labels, <code>edgelist</code> and <code>search</code>, and the use of <code>break</code> 
statements. This allows the code that copies a list, omitting one edge, to be shared 
between two separate tests, the test for an edge from node <i>i</i> to node <i>j</i>, and the test 
for an edge from node <i>j</i> to node <i>i</i>.
<p><a name="6122"></a>
<h2>14.14    The <code>continue</code> Statement</h2>
<a name="6123"></a>
A <code>continue</code> statement may occur only in a <code>while</code>, <code>do</code>, or <code>for</code> statement; statements
of these three kinds are called <i>iteration statements</i>. Control passes to the 
loop-continuation point of an iteration statement.
<p><ul><pre>
<i>ContinueStatement:<br>
</i>	<code>continue </code><i>Identifier</i><sub><i>opt</i></sub><code> ;
</code></pre></ul><a name="6125"></a>
A <code>continue</code> statement with no label attempts to transfer control to the innermost enclosing <code>while</code>, <code>do</code>, or <code>for</code> statement; this statement, which is called the <i>continue target</i>, then immediately ends the current iteration and begins a new one. To be precise, such a <code>continue</code> statement always completes abruptly, the reason being a <code>continue</code> with no label. If no <code>while</code>, <code>do</code>, or <code>for</code> statement encloses the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="79215"></a>
A <code>continue</code> statement with label <i>Identifier</i> attempts to transfer control to the enclosing labeled statement <a href="14.doc.html#78993">(&#167;14.6)</a> that has the same <i>Identifier</i> as its label; that statement, which is called the <i>continue target</i>, then immediately ends the current iteration and begins a new one. The continue target must be a <code>while</code>, <code>do</code>, or <code>for</code> statement or a compile-time error occurs. More precisely, a <code>continue</code> statement with label <i>Identifier</i> always completes abruptly, the reason being a <code>continue</code> with label <i>Identifier</i>. If no labeled statement with <i>Identifier</i> as its label contains the <code>continue</code> statement, a compile-time error occurs.<p>
<a name="43498"></a>
It can be seen, then, that a <code>continue</code> statement always completes abruptly.<p>
<a name="6136"></a>
See the descriptions of the <code>while</code> statement <a href="14.doc.html#237277">(&#167;14.10)</a>, <code>do</code> statement <a href="14.doc.html#6045">(&#167;14.11)</a>, and <code>for</code> statement <a href="14.doc.html#24588">(&#167;14.12)</a> for a discussion of the handling of abrupt termination because of <code>continue</code>.<p>
<a name="43422"></a>
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="14.doc.html#79311">(&#167;14.18)</a> within the continue target whose <code>try</code> blocks contain the <code>continue</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>continue</code> statement.<p>
<a name="42935"></a>
In the <code>Graph</code> example in the preceding section, one of the <code>break</code> statements is used to finish execution of the entire body of the outermost <code>for</code> loop. This <code>break</code> can be replaced by a <code>continue</code> if the <code>for</code> loop itself is labeled:<p>
<pre><a name="42900"></a>
class Graph {
<a name="42901"></a>	. . .
<a name="42903"></a>	public Graph loseEdges(int i, int j) {
<a name="42904"></a>		int n = edges.length;
<a name="42905"></a>		int[][] newedges = new int[n][];
<a name="42906"></a>
		edgelists: for (int k = 0; k &lt; n; ++k) {
<a name="42908"></a>			int z;
<a name="42909"></a>
			search: {
<a name="42989"></a>				if (k == i) {
<a name="42990"></a>					. . .
<a name="42991"></a>				} else if (k == j) {
<a name="42916"></a>					. . .
<a name="42919"></a>				}
<a name="42921"></a>				newedges[k] = edges[k];
<a name="42922"></a>				continue edgelists;
<a name="42923"></a>			}//search
<a name="42925"></a>			. . .
<a name="42983"></a>		}//edgelists
<a name="42932"></a>		return new Graph(newedges);
<a name="42933"></a>	}
<a name="42934"></a>}
</pre><a name="42984"></a>
Which to use, if either, is largely a matter of programming style.
<p><a name="6767"></a>
<h2>14.15    The <code>return</code> Statement</h2>
<a name="124158"></a>
A <code>return</code> statement returns control to the invoker of a method (<a href="8.doc.html#40420">&#167;8.4</a>, <a href="15.doc.html#20448">&#167;15.11</a>) or 
constructor (<a href="8.doc.html#41652">&#167;8.6</a>, <a href="15.doc.html#41147">&#167;15.8</a>).
<p><ul><pre>
<i>ReturnStatement:<br>
</i>	<code>return </code><i>Expression</i><sub><i>opt</i></sub><code> ;
</code></pre></ul><a name="236030"></a>
A <code>return</code> statement with no <i>Expression </i>must be contained in the body of a method that is declared, using the keyword <code>void</code>, not to return any value <a href="8.doc.html#40420">(&#167;8.4)</a>, or in the body of a constructor <a href="8.doc.html#41652">(&#167;8.6)</a>. A compile-time error occurs if a <code>return</code> statement appears within a static initializer <a href="8.doc.html#39245">(&#167;8.5)</a>. A <code>return</code> statement with no <i>Expression</i> attempts to transfer control to the invoker of the method or constructor that contains it. To be precise, a <code>return</code> statement with no <i>Expression</i> always completes abruptly, the reason being a <code>return</code> with no value.<p>
<a name="6148"></a>
A <code>return</code> statement with an <i>Expression</i> must be contained in a method declaration that is declared to return a value <a href="8.doc.html#40420">(&#167;8.4)</a> or a compile-time error occurs. The <i>Expression</i> must denote a variable or value of some type <i>T</i>, or a compile-time error occurs. The type <em>T</em> must be assignable <a href="5.doc.html#170768">(&#167;5.2)</a> to the declared result type of the method, or a compile-time error occurs.<p>
<a name="43489"></a>
A <code>return</code> statement with an <i>Expression</i> attempts to transfer control to the invoker of the method that contains it; the value of the <i>Expression</i> becomes the value of the method invocation. More precisely, execution of such a <code>return</code> statement first evaluates the <i>Expression</i>. If the evaluation of the <i>Expression</i> completes abruptly for some reason, then the <code>return</code> statement completes abruptly for that reason. If evaluation of the <i>Expression</i> completes normally, producing a value <i>V</i>, then the <code>return</code> statement completes abruptly, the reason being a <code>return</code> with value <i>V</i>.<p>
<a name="43495"></a>
It can be seen, then, that a <code>return</code> statement always completes abruptly.<p>
<a name="43508"></a>
The preceding descriptions say "attempts to transfer control" rather than just "transfers control" because if there are any <code>try</code> statements <a href="14.doc.html#79311">(&#167;14.18)</a> within the method or constructor whose <code>try</code> blocks contain the <code>return</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>return</code> statement.<p>
<a name="237350"></a>
<h2>14.16    The <code>throw</code> Statement</h2>
<a name="79254"></a>
A <code>throw</code> statement causes an exception <a href="11.doc.html#44043">(&#167;11)</a> to be thrown. The result is an immediate
transfer of control <a href="11.doc.html#44153">(&#167;11.3)</a> that may exit multiple statements and multiple 
constructor, static and field initializer evaluations, and method invocations until a 
<code>try</code> statement <a href="14.doc.html#79311">(&#167;14.18)</a> is found that catches the thrown value. If no such <code>try</code> 
statement is found, then execution of the thread (<a href="17.doc.html#26250">&#167;17</a>, <a href="javalang.doc18.html#2658">&#167;20.20</a>) that executed the 
<code>throw</code> is terminated <a href="11.doc.html#44153">(&#167;11.3)</a> after invocation of the <code>UncaughtException</code> method 
<a href="javalang.doc19.html#2901">(&#167;20.21.31)</a> for the thread group to which the thread belongs.
<p><ul><pre>
<i>ThrowStatement:<br>
</i>	<code>throw </code><i>Expression</i><code> ;
</code></pre></ul><a name="236072"></a>
The <i>Expression</i> in a throw statement must denote a variable or value of a reference type which is assignable <a href="5.doc.html#170768">(&#167;5.2)</a> to the type <code>Throwable</code>, or a compile-time error occurs. Moreover, at least one of the following three conditions must be true, or a compile-time error occurs:<p>
<ul><a name="236073"></a>
<li>The exception is not a checked exception <a href="11.doc.html#44121">(&#167;11.2)</a>-specifically, one of the following situations is true:
<ul>
<a name="39922"></a>
<li>The type of the <i>Expression</i> is the class <code>RuntimeException</code> or a subclass of <code>RuntimeException</code>.
<a name="236074"></a>
<li>The type of the <i>Expression</i> is the class <code>Error</code> or a subclass of <code>Error</code>.
</ul>
<a name="236078"></a>
<li>The <code>throw</code> statement is contained in the <code>try</code> block of a <code>try</code> statement <a href="14.doc.html#79311">(&#167;14.18)</a> and the type of the <i>Expression</i> is assignable <a href="5.doc.html#170768">(&#167;5.2)</a> to the type of the parameter of at least one <code>catch</code> clause of the <code>try</code> statement. (In this case we say the thrown value is <i>caught</i> by the <code>try</code> statement.)
<a name="236082"></a>
<li>The <code>throw</code> statement is contained in a method or constructor declaration and the type of the <i>Expression</i> is assignable <a href="5.doc.html#170768">(&#167;5.2)</a> to at least one type listed in the <code>throws</code> clause (<a href="8.doc.html#78323">&#167;8.4.4</a>, <a href="8.doc.html#244611">&#167;8.6.4</a>) of the declaration.
</ul><a name="236055"></a>
A <code>throw</code> statement first evaluates the <i>Expression</i>. If the evaluation of the <i>Expression</i> completes abruptly for some reason, then the <code>throw</code> completes abruptly for that reason. If evaluation of the <i>Expression</i> completes normally, producing a value <i>V</i>, then the <code>throw</code> statement completes abruptly, the reason being a <code>throw</code> with value <i>V</i>.<p>
<a name="43545"></a>
It can be seen, then, that a <code>throw</code> statement always completes abruptly.<p>
<a name="43541"></a>
If there are any enclosing <code>try</code> statements <a href="14.doc.html#79311">(&#167;14.18)</a> whose <code>try</code> blocks contain the <code>throw</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed as control is transferred outward, until the thrown value is caught. Note that abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>throw</code> statement.<p>
<a name="79283"></a>
If a <code>throw</code> statement is contained in a method declaration, but its value is not caught by some <code>try</code> statement that contains it, then the invocation of the method completes abruptly because of the <code>throw</code>.<p>
<a name="79284"></a>
If a <code>throw</code> statement is contained in a constructor declaration, but its value is not caught by some <code>try</code> statement that contains it, then the class instance creation expression (or the method invocation of method <code>newInstance</code> of class <code>Class</code>) that invoked the constructor will complete abruptly because of the <code>throw</code>.<p>
<a name="43567"></a>
If a <code>throw</code> statement is contained in a static initializer <a href="8.doc.html#39245">(&#167;8.5)</a>, then a compile-time check ensures that either its value is always an unchecked exception or its value is always caught by some <code>try</code> statement that contains it. If, despite this check, the value is not caught by some <code>try</code> statement that contains the <code>throw</code> statement, then the value is rethrown if it is an instance of class <code>Error</code> or one of its subclasses; otherwise, it is wrapped in an <code>ExceptionInInitializerError</code> object, which is then thrown <a href="12.doc.html#44630">(&#167;12.4.2)</a>.<p>
<a name="79285"></a>
By convention, user-declared throwable types should usually be declared to be subclasses of class <code>Exception</code>, which is a subclass of class <code>Throwable</code> (<a href="11.doc.html#44278">&#167;11.5</a>, <a href="javalang.doc20.html#46198">&#167;20.22</a>).<p>
<a name="79287"></a>
<h2>14.17    The <code>synchronized</code> Statement</h2>
<a name="79291"></a>
A <code>synchronized</code> statement acquires a mutual-exclusion lock <a href="17.doc.html#28460">(&#167;17.13)</a> on behalf 
of the executing thread, executes a block, then releases the lock. While the executing
thread owns the lock, no other thread may acquire the lock.
<p><ul><pre>
<i>SynchronizedStatement:<br>
</i>	<code>synchronized ( </code><i>Expression</i><code> ) </code><i>Block
</i></pre></ul><a name="217233"></a>
The type of <i>Expression</i> must be a reference type, or a compile-time error occurs. 
<p><a name="217245"></a>
A <code>synchronized</code> statement is executed by first evaluating the <i>Expression</i>.<p>
<a name="236514"></a>
If evaluation of the <i>Expression</i> completes abruptly for some reason, then the <code>synchronized</code> statement completes abruptly for the same reason.<p>
<a name="236515"></a>
Otherwise, if the value of the <i>Expression</i> is <code>null</code>, a <code>NullPointerException</code> is thrown.<p>
<a name="79295"></a>
Otherwise, let the non-<code>null</code> value of the <i>Expression</i> be <i>V</i>. The executing thread locks the lock associated with <i>V</i>. Then the <i>Block </i>is executed. If execution of the <i>Block</i> completes normally, then the lock is unlocked and the <code>synchronized</code> statement completes normally. If execution of the <i>Block</i> completes abruptly for any reason, then the lock is unlocked and the <code>synchronized</code> statement then completes abruptly for the same reason.<p>
<a name="79305"></a>
Acquiring the lock associated with an object does not of itself prevent other threads from accessing fields of the object or invoking unsynchronized methods on the object. Other threads can also use <code>synchronized</code> methods or the <code>synchronized</code> &#32;statement in a conventional manner to achieve mutual exclusion.<p>
<a name="79306"></a>
The locks acquired by <code>synchronized</code> statements are the same as the locks that are acquired implicitly by <code>synchronized</code> methods; see <a href="8.doc.html#55408">&#167;8.4.3.5</a>. A single thread may hold a lock more than once. The example:<p>
<pre><a name="237226"></a>
class Test {
<a name="237227"></a>	public static void main(String[] args) {
<a name="237228"></a>		Test t = new Test();
<a name="22894"></a>		synchronized(t) {
<a name="22895"></a>			synchronized(t) {
<a name="22896"></a>				System.out.println("made it!");
<a name="22897"></a>			}
<a name="22898"></a>		}
<a name="22899"></a>	}
<a name="22900"></a>}
</pre><a name="22901"></a>
prints:
<p><pre><a name="22902"></a>made it!
</pre><a name="22903"></a>
This example would deadlock if a single thread were not permitted to lock a lock 
more than once.
<p><a name="79311"></a>
<h2>14.18    The <code>try</code> statement</h2>
<a name="79312"></a>
A <code>try</code> statement executes a block. If a value is thrown and the <code>try</code> statement has 
one or more <code>catch</code> clauses that can catch it, then control will be transferred to the 
first such <code>catch</code> clause. If the <code>try</code> statement has a <code>finally</code> clause, then another 
block of code is executed, no matter whether the <code>try</code> block completes normally or 
abruptly, and no matter whether a <code>catch</code> clause is first given control.
<p><ul><pre>
<i>TryStatement:<br>
</i><code>	try </code><i>Block</i><code> </code><i>Catches<br>
</i><code>	try </code><i>Block</i><code> </code><i>Catches</i><sub><i>opt</i></sub><code> </code><i>Finally
</i>
<i>Catches:<br>
</i>	<i>CatchClause<br>
</i>	<i>Catches</i><code> </code><i>CatchClause
</i>
<i>CatchClause:<br>
</i>	<code>catch ( </code><i>FormalParameter</i><code> ) </code><i>Block
</i>
<i>Finally:<br>
</i><code>	finally </code><i>Block
</i></pre></ul><a name="45818"></a>
The following is repeated from <a href="8.doc.html#38698">&#167;8.4.1</a> to make the presentation here clearer:
<p><ul><pre>
<i>FormalParameter:<br>
</i>	<i>Type</i><code> </code><i>VariableDeclaratorId
</i></pre></ul><a name="237406"></a>
The following is repeated from <a href="8.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:
<p><ul><pre>
<i>VariableDeclaratorId:<br>
</i>	<i>Identifier<br>
</i>	<i>VariableDeclaratorId</i><code> [ ]
</code></pre></ul><a name="79317"></a>
The <i>Block</i> immediately after the keyword <code>try</code> is called the <code>try</code> block of the <code>try</code> statement. The <i>Block</i> immediately after the keyword <code>finally</code> is called the <code>finally</code> block of the <code>try</code> statement.<p>
<a name="79318"></a>
A <code>try</code> statement may have <code>catch</code> clauses (also called <i>exception handlers</i>). A &#32;<code>catch</code> clause must have exactly one parameter (which is called an <i>exception parameter</i>); the declared type of the exception parameter must be the class <code>Throwable</code> or a subclass of <code>Throwable</code>, or a compile-time error occurs. The scope of the parameter variable is the <i>Block</i> of the <code>catch</code> clause. An exception parameter must not have the same name as a local variable or parameter in whose scope it is declared, or a compile-time error occurs.<p>
<a name="45876"></a>
The scope of the name of an exception parameter is the <i>Block</i> of the <code>catch</code> clause. The name of the parameter may not be redeclared as a local variable or exception parameter within the <i>Block</i> of the <code>catch</code> clause; that is, hiding the name of an exception parameter is not permitted.<p>
<a name="45880"></a>
Exception parameters cannot be referred to using qualified names <a href="6.doc.html#33916">(&#167;6.6)</a>, only by simple names.<p>
<a name="24142"></a>
Exception handlers are considered in left-to-right order: the earliest possible <code>catch</code> clause accepts the exception, receiving as its actual argument the thrown exception object.<p>
<a name="24143"></a>
A <code>finally</code> clause ensures that the <code>finally</code> block is executed after the <code>try</code> block and any <code>catch</code> block that might be executed, no matter how control leaves the <code>try</code> block or <code>catch</code> block.<p>
<a name="79319"></a>
Handling of the <code>finally</code> block is rather complex, so the two cases of a <code>try</code> statement with and without a <code>finally</code> block are described separately.<p>
<a name="24134"></a>
<h3>14.18.1    Execution of <code>try-catch</code></h3>
<a name="79320"></a>
A <code>try</code> statement without a <code>finally</code> block is executed by first executing the <code>try</code> 
block. Then there is a choice:
<p><ul><a name="79321"></a>
<li>If execution of the <code>try</code> block completes normally, then no further action is taken and the <code>try</code> statement completes normally.
<a name="79322"></a>
<li>If execution of the <code>try</code> block completes abruptly because of a <code>throw</code> of a value <i>V</i>, then there is a choice:
<ul>
<a name="79323"></a>
<li>If the run-time type of <i>V</i><i></i> is assignable <a href="5.doc.html#170768">(&#167;5.2)</a> to the <i>Parameter</i> of any <code>catch</code> clause of the <code>try</code> statement, then the first (leftmost) such <code>catch</code> clause is selected. The value <i>V</i><i></i> is assigned to the parameter of the selected <code>catch</code> clause, and the <i>Block</i> of that <code>catch</code> clause is executed. If that block completes normally, then the <code>try</code> statement completes normally; if that block completes abruptly for any reason, then the <code>try</code> statement completes abruptly for the same reason.
<a name="79324"></a>
<li>If the run-time type of <i>V</i><i></i> is not assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the <code>try</code> statement completes abruptly because of a <code>throw</code> of the value <i>V</i>.
</ul>
<a name="79325"></a>
<li>If execution of the <code>try</code> block completes abruptly for any other reason, then the <code>try</code> statement completes abruptly for the same reason.
</ul><a name="18065"></a>
In the example:
<p><pre><a name="18066"></a>class BlewIt extends Exception {
<a name="236619"></a>	BlewIt() { }
<a name="236620"></a>	BlewIt(String s) { super(s); }
<a name="236621"></a>}
<a name="236622"></a>class Test {
<a name="236623"></a>	static void blowUp() throws BlewIt { throw new BlewIt(); }
<a name="237378"></a>	public static void main(String[] args) {
</pre><pre><a name="236625"></a>
		try {
<a name="236626"></a>			blowUp();
<a name="236627"></a>		} catch (RuntimeException r) {
<a name="236628"></a>			System.out.println("RuntimeException:" + r);
<a name="236629"></a>		} catch (BlewIt b) {
<a name="236630"></a>			System.out.println("BlewIt");
<a name="236631"></a>		}
<a name="236632"></a>	}
<br><a name="236633"></a>}
</pre><a name="236651"></a>
the exception <code>BlewIt</code> is thrown by the method <code>blowUp</code>. The <code>try</code><strong>-</strong><code>catch</code> statement 
in the body of <code>main</code> has two <code>catch</code> clauses. The run-time type of the exception is 
<code>BlewIt</code> which is not assignable to a variable of type <code>RuntimeException</code>, but is 
assignable to a variable of type <code>BlewIt</code>, so the output of the example is:
<p><pre><a name="236656"></a>BlewIt
</pre><a name="236653"></a>
<h3>14.18.2    Execution of <code>try-catch-finally</code></h3>
<a name="79326"></a>
A <code>try</code> statement with a <code>finally</code> block is executed by first executing the <code>try</code> 
block. Then there is a choice:
<p><ul><a name="79327"></a>
<li>If execution of the <code>try</code> block completes normally, then the <code>finally</code> block is executed, and then there is a choice:
<ul>
<a name="160341"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes normally.
<a name="160342"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i><i></i>.
</ul>
<a name="79328"></a>
<li>If execution of the <code>try</code> block completes abruptly because of a <code>throw</code> of a value <i>V</i>, then there is a choice:
<ul>
<a name="79329"></a>
<li>If the run-time type of <i>V</i><i></i> is assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the first (leftmost) such <code>catch</code> clause is selected. The value <i>V</i><i></i> is assigned to the parameter of the selected <code>catch</code> clause, and the <i>Block</i> of that <code>catch</code> clause is executed. Then there is a choice:
<ul>
<a name="79330"></a>
<li>If the <code>catch</code> block completes normally, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="160348"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes normally.
<a name="160349"></a>
<li>If the <code>finally</code> block completes abruptly for any reason, then the <code>try</code> statement completes abruptly for the same reason.
</ul>
<a name="79331"></a>
<li>If the <code>catch</code> block completes abruptly for reason <i>R</i><i></i>, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79332"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly for reason <i>R</i><i></i>.
<a name="79333"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i><i></i> (and reason <i>R</i><i></i> is discarded).
</ul>
</ul>
<a name="79334"></a>
<li>If the run-time type of <i>V</i><i></i> is not assignable to the parameter of any <code>catch</code> clause of the <code>try</code> statement, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79335"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly because of a <code>throw</code> of the value <i>V</i>.
<a name="79336"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i><i></i> (and the <code>throw</code> of value <i>V</i><i></i> is discarded and forgotten).
</ul>
</ul>
<a name="79337"></a>
<li>If execution of the <code>try</code> block completes abruptly for any other reason <i>R</i><i></i>, then the <code>finally</code> block is executed. Then there is a choice:
<ul>
<a name="79338"></a>
<li>If the <code>finally</code> block completes normally, then the <code>try</code> statement completes abruptly for reason <i>R</i><i></i>.
<a name="79339"></a>
<li>If the <code>finally</code> block completes abruptly for reason <i>S</i>, then the <code>try</code> statement completes abruptly for reason <i>S</i><i></i> (and reason <i>R</i><i></i> is discarded).
</ul>
</ul><a name="18069"></a>
The example:
<p><pre><a name="236658"></a>class BlewIt extends Exception {
<a name="236659"></a>	BlewIt() { }
<a name="236660"></a>	BlewIt(String s) { super(s); }
<a name="236661"></a>}
</pre><pre><a name="236662"></a>
class Test {
<a name="236663"></a>
	static void blowUp() throws BlewIt {<br>
		throw new NullPointerException();<br>
	}
<a name="236664"></a>
	public static void main(String[] args) {
<a name="236665"></a>		try {
<a name="236666"></a>			blowUp();
<a name="236669"></a>		} catch (BlewIt b) {
<a name="236670"></a>			System.out.println("BlewIt");
<a name="236671"></a>		} finally {
<a name="236685"></a>			System.out.println("Uncaught Exception");
<a name="236686"></a>		}
<a name="236672"></a>	}
<br><a name="236673"></a>}
</pre><a name="18070"></a>
produces the output:
<p><pre><a name="236697"></a>
Uncaught Exception
<a name="236698"></a>java.lang.NullPointerException
<a name="236699"></a>	at Test.blowUp(Test.java:7)
<a name="236700"></a>	at Test.main(Test.java:11)
</pre><a name="236703"></a>
The <code>NullPointerException</code> (which is a kind of <code>RuntimeException</code>) that is 
thrown by method <code>blowUp</code> is not caught by the <code>try</code> statement in <code>main</code>, because a 
<code>NullPointerException</code> is not assignable to a variable of type <code>BlewIt</code>. This 
causes the <code>finally</code> clause to execute, after which the thread executing <code>main</code>, 
which is the only thread of the test program, terminates because of an uncaught 
exception <a href="javalang.doc19.html#2901">(&#167;20.21.31)</a>, which results in printing the exception name and a simple 
backtrace.
<p><a name="236365"></a>
<h2>14.19    Unreachable Statements</h2>
<a name="237365"></a>
It is a compile-time error if a statement cannot be executed because it is <i>unreachable
</i>. Every Java compiler must carry out the conservative flow analysis specified 
here to make sure all statements are reachable.
<p><a name="237366"></a>
This section is devoted to a precise explanation of the word "reachable." The idea is that there must be some possible execution path from the beginning of the constructor, method, or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of <code>while</code>, <code>do</code>, and <code>for</code> statements whose condition expression has the constant value <code>true</code>, the values of expressions are not taken into account in the flow analysis. For example, a Java compiler will accept the code:<p>
<pre><a name="79345"></a>
{
<a name="79347"></a>	int n = 5;
<a name="79348"></a>	while (n &gt; 7) n = 2;
<a name="79349"></a>}
</pre><a name="79350"></a>
even though the value of <code>n</code> is known at compile time and in principle it can be 
known at compile time that the assignment to <code>k</code> can never be executed. A Java 
compiler must operate according to the rules laid out in this section.
<p><a name="79351"></a>
The rules in this section define two technical terms:<p>
<ul><a name="79352"></a>
<li>whether a statement is <i>reachable</i>
<a name="79353"></a>
<li>whether a statement <i>can complete normally</i>
</ul><a name="79354"></a>
The definitions here allow a statement to complete normally only if it is reachable.
<p><a name="236611"></a>
To shorten the description of the rules, the customary abbreviation "iff" is used to mean "if and only if."<p>
<a name="236612"></a>
The rules are as follows:<p>
<ul><a name="236613"></a>
<li>The block that is the body of a constructor, method, or static initializer is reachable.
<a name="160362"></a>
<li>An empty block that is not a switch block can complete normally iff it is reachable. A nonempty block that is not a switch block can complete normally iff the last statement in it can complete normally. The first statement<i></i> in a nonempty block that is not a switch block is reachable iff the block is reachable. Every other statement <i>S</i><i></i> in a nonempty block that is not a switch block is reachable iff the statement preceding <i>S</i><i></i> can complete normally.
<a name="160365"></a>
<li>A local variable declaration statement can complete normally iff it is reachable.
<a name="79357"></a>
<li>An empty statement can complete normally iff it is reachable.
<a name="79359"></a>
<li>A labeled statement can complete normally if at least one of the following is true:
<ul>
<a name="21184"></a>
<li>The contained statement can complete normally.
<a name="21188"></a>
<li>There is a reachable <code>break</code> statement that exits the labeled statement.
</ul>
</ul><ul><a name="21187"></a>
<br><br>The contained statement is reachable iff the labeled statement is reachable.
</ul><ul><a name="79360"></a>
<li>An expression statement can complete normally iff it is reachable.
<a name="236410"></a>
<li>The <code>if</code> statement, whether or not it has an <code>else</code> part, is handled in an unusual manner. For this reason, it is discussed separately at the end of this section.
<a name="79366"></a>
<li>A <code>switch</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79367"></a>
<li>The last statement in the switch block can complete normally.
<a name="237563"></a>
<li>The switch block is empty or contains only switch labels.
<a name="237564"></a>
<li>There is at least one switch label after the last switch block statement group.
<a name="79368"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>switch</code> statement.
</ul>
<a name="237548"></a>
<li>A switch block is reachable iff its <code>switch</code> statement is reachable.
<a name="237550"></a>
<li>A statement in a switch block is reachable iff its <code>switch</code> statement is reachable and at least one of the following is true:
<ul>
<a name="79370"></a>
<li>It bears a <code>case</code> or <code>default</code> label.
<a name="79371"></a>
<li>There is a statement preceding it in the <code>switch</code> block and that preceding statement can complete normally.
</ul>
<a name="79372"></a>
<li>A <code>while</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79373"></a>
<li>The <code>while</code> statement is reachable and the condition expression is not a constant expression with value <code>true</code>.
<a name="79374"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>while</code> statement.
</ul>
</ul><ul><a name="79375"></a>
<br><br>The contained statement is reachable iff the <code>while</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.
</ul><ul><a name="79376"></a>
<li>A <code>do</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79377"></a>
<li>The contained statement can complete normally and the condition expression is not a constant expression with value <code>true</code>.
<a name="79378"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>do</code> statement.
</ul>
</ul><ul><a name="79379"></a>
<br><br>The contained statement is reachable iff the <code>do</code> statement is reachable.
</ul><ul><a name="79380"></a>
<li>A <code>for</code> statement can complete normally iff at least one of the following is true:
<ul>
<a name="79381"></a>
<li>The <code>for</code> statement is reachable, there is a condition expression, and the condition expression is not a constant expression with value <code>true</code>.
<a name="79382"></a>
<li>There is a reachable <code>break</code> statement that exits the <code>for</code> statement.
</ul>
</ul><ul><a name="79383"></a>
<br><br>The contained statement is reachable iff the <code>for</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.
</ul><ul><a name="79384"></a>
<li>A <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code> statement cannot complete normally.
<a name="79385"></a>
<li>A <code>synchronized</code> statement can complete normally iff the contained statement can complete normally. The contained statement is reachable iff the <code>synchronized</code> statement is reachable.
<a name="79386"></a>
<li>A <code>try</code> statement can complete normally iff both of the following are true:
<ul>
<a name="79387"></a>
<li>The <code>try</code> block can complete normally or any <code>catch</code> block can complete <code>normally</code>.
<a name="79388"></a>
<li>If the <code>try</code> statement has a <code>finally</code> block, then the <code>finally</code> block can complete normally.
</ul>
<a name="79389"></a>
<li>The <code>try</code> block is reachable iff the <code>try</code> statement is reachable.
<a name="79390"></a>
<li>A <code>catch</code> block <i>C</i> is reachable iff both of the following are true:
<ul>
<a name="79391"></a>
<li>Some expression or <code>throw</code> statement in the <code>try</code> block is reachable and can throw an exception whose type is assignable to the parameter of the <code>catch</code> clause <i>C</i>. (An expression is considered reachable iff the innermost statement containing it is reachable.)
<a name="79392"></a>
<li>There is no earlier <code>catch</code> block <i>A</i> in the <code>try</code> statement such that the type of <i>C</i>'s parameter is the same as or a subclass of the type of <i>A</i>'s parameter.
</ul>
<a name="236212"></a>
<li>If a <code>finally</code> block is present, it is reachable iff the <code>try</code> statement is reachable.
</ul><a name="236419"></a>
One might expect the <code>if</code> statement to be handled in the following manner, but these are not the rules that Java actually uses:<p>
<ul><a name="236554"></a>
<li>HYPOTHETICAL: An <code>if-then</code> statement can complete normally iff at least one of the following is <code>true</code>:
<ul>
<a name="236555"></a>
<li>The <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.
<a name="236407"></a>
<li>The <code>then</code>-statement can complete normally.
</ul>
</ul><ul><a name="236408"></a>
<br><br>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.
</ul><ul><a name="236409"></a>
<li>HYPOTHETICAL: An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>. The <code>else</code> statement is reachable iff the <code>if</code>-<code>then</code>-<code>else </code>statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.
</ul><a name="236422"></a>
This approach would be consistent with the treatment of other control structures 
in Java. However, in order to allow the if statement to be used conveniently for 
"conditional compilation" purposes, the actual rules are as follows:
<p><ul><a name="236424"></a>
<li>ACTUAL: An <code>if</code>-<code>then</code> statement can complete normally iff it is reachable. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable.
<a name="236428"></a>
<li>ACTUAL: An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally. The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable. The <code>else</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable.
</ul><a name="236451"></a>
As an example, the following statement results in a compile-time error:
<p><pre><a name="236452"></a>while (false) { x=3; }
</pre><a name="236453"></a>
because the statement <code>x=3;</code> is not reachable; but the superficially similar case:
<p><pre><a name="236456"></a>if (false) { x=3; }
</pre><a name="236454"></a>
does not result in a compile-time error. An optimizing compiler may realize that 
the statement <code>x=3;</code> will never be executed and may choose to omit the code for 
that statement from the generated <code>class</code> file, but the statement <code>x=3;</code> is not 
regarded as "unreachable" in the technical sense specified here.
<p><a name="238244"></a>
The rationale for this differing treatment is to allow programmers to define "flag variables" such as:<p>
<pre><a name="236464"></a>static final boolean DEBUG = false;
</pre><a name="236471"></a>
and then write code such as:
<p><pre><a name="236466"></a>if (DEBUG) { x=3; }
</pre><a name="236477"></a>
The idea is that it should be possible to change the value of <code>DEBUG</code> from <code>false</code> to 
<code>true</code> or from <code>true</code> to <code>false</code> and then compile the code correctly with no other 
changes to the program text.
<p><a name="238425"></a>
This ability to "conditionally compile" has a significant impact on, and relationship to, binary compatibility <a href="13.doc.html#44871">(&#167;13)</a>. If a set of classes that use such a "flag" variable are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. A change to the value of a flag is, therefore, not binary compatible with preexisting binaries <a href="13.doc.html#45139">(&#167;13.4.8)</a>. (There are other reasons for such incompatibility as well, such as the use of constants in <code>case</code> labels in <code>switch</code> statements; see <a href="13.doc.html#45139">&#167;13.4.8</a>.)<p>
<a name="246702"></a>
<p>
<a name="241248"></a>
<p>
<a name="241250"></a>
<p>
<a name="241251"></a>
<p>
<a name="241252"></a>
<p>
<a name="241253"></a>
<p>
<a name="241254"></a>
<p>
<a name="241255"></a>
<p>
<a name="241256"></a>
<p>
<a name="241257"></a>
<p>
<a name="241258"></a>
<p>
<a name="241259"></a>
<p>
<a name="241260"></a>
<p>
<a name="241261"></a>
<p>
<a name="241262"></a>
<p>
<a name="241263"></a>
<p>
<a name="241264"></a>
<p>
<a name="241265"></a>
<p>
<a name="241266"></a>
<p>
<a name="241267"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="13.doc.html">Prev</a> | <a href="15.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>