<html>
<head>
<title>The Java Language Specification
 Classes</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="7.doc.html">Prev</a> | <a href="9.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="3857"></a>
<p><strong>
CHAPTER
 8 </strong></p>
<a name="44365"></a>
<h1>Classes</h1>
<hr><p>
<a name="228205"></a>
Class declarations define new reference types and describe how they are 
implemented <a href="8.doc.html#15372">(&#167;8.1)</a>.
<p><a name="228209"></a>
The name of a class has as its scope all type declarations in the package in which the class is declared <a href="8.doc.html#39196">(&#167;8.1.1)</a>. A class may be declared <code>abstract</code> <a href="8.doc.html#34944">(&#167;8.1.2.1)</a> and must be declared <code>abstract</code> if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> <a href="8.doc.html#54727">(&#167;8.1.2.2)</a>, in which case it cannot have subclasses. If a class is declared <code>public</code>, then it can be referred to from other packages.<p>
<a name="35674"></a>
Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class <a href="8.doc.html#21723">(&#167;8.1.3)</a> and may implement interfaces <a href="8.doc.html#34031">(&#167;8.1.4)</a>.<p>
<a name="15689"></a>
The body of a class declares members (fields and methods), static initializers, and constructors <a href="8.doc.html#18988">(&#167;8.1.5)</a>. The scope of the name of a member is the entire declaration of the class to which the member belongs. Field, method, and constructor declarations may include the access modifiers <a href="6.doc.html#33916">(&#167;6.6)</a> <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members <a href="8.doc.html#21831">(&#167;8.2)</a>. Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.<p>
<a name="15807"></a>
Field declarations <a href="8.doc.html#40898">(&#167;8.3)</a> describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> <a href="8.doc.html#35962">(&#167;8.3.1.2)</a>, in which case it cannot be assigned to except as part of its declaration. Any field declaration may include an initializer; the declaration of a <code>final</code> field must include an initializer.<p>
<a name="35821"></a>
Method declarations <a href="8.doc.html#40420">(&#167;8.4)</a> describe code that may be invoked by method invocation expressions <a href="15.doc.html#20448">(&#167;15.11)</a>. A class method is invoked relative to the class type; an instance method is invoked with respect to some particular object that is an instance of the class type. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> <a href="8.doc.html#11246">(&#167;8.4.3.3)</a>, in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code <a href="8.doc.html#31125">(&#167;8.4.3.4)</a>. A <code>synchronized</code> method <a href="8.doc.html#55408">(&#167;8.4.3.5)</a> automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement <a href="14.doc.html#79287">(&#167;14.17)</a>, thus allowing its activities to be synchronized with those of other threads <a href="17.doc.html#26250">(&#167;17)</a>.<p>
<a name="227762"></a>
Method names may be overloaded <a href="8.doc.html#227768">(&#167;8.4.7)</a>.<p>
<a name="35837"></a>
Static initializers <a href="8.doc.html#39245">(&#167;8.5)</a> are blocks of executable code that may be used to help initialize a class when it is first loaded <a href="12.doc.html#44557">(&#167;12.4)</a>.<p>
<a name="35735"></a>
Constructors <a href="8.doc.html#41652">(&#167;8.6)</a> are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded <a href="8.doc.html#229266">(&#167;8.6.6)</a>.<p>
<a name="15372"></a>
<h2>8.1    Class Declaration</h2>
<a name="23643"></a>
A <i>class declaration</i> specifies a new reference type:
<p><ul><pre>
<i>ClassDeclaration:<br>
</i>	<i>ClassModifiers</i><sub><i>opt</i></sub><code> class </code><i>Identifier</i><code> </code><i>Super</i><sub><i>opt</i></sub><code> </code><i>Interfaces</i><sub><i>opt</i></sub><code> </code><i>ClassBody
</i></pre></ul><a name="29516"></a>
If a class is declared in a named package <a href="7.doc.html#26621">(&#167;7.4.1)</a> with fully qualified name <i>P</i> 
<a href="6.doc.html#25430">(&#167;6.7)</a>, then the class has the fully qualified name <i>P</i><code>.</code><i>Identifier</i>. If the class is in an 
unnamed package <a href="7.doc.html#26639">(&#167;7.4.2)</a>, then the class has the fully qualified name <i>Identifier</i>. 
In the example:
<p><pre><a name="29524"></a>class Point { int x, y; }
</pre><a name="29525"></a>
the class <code>Point</code> is declared in a compilation unit with no <code>package</code> statement, and 
thus <code>Point</code> is its fully qualified name, whereas in the example:
<p><pre><a name="29526"></a>
package vista;
<a name="29527"></a>class Point { int x, y; }
</pre><a name="29528"></a>
the fully qualified name of the class <code>Point</code> is <code>vista.Point</code>. (The package name 
<code>vista</code> is suitable for local or personal use; if the package were intended to be 
widely distributed, it would be better to give it a unique package name <a href="7.doc.html#40169">(&#167;7.7)</a>.)
<p><a name="77906"></a>
A compile-time error occurs if the <em>Identifier </em>naming a class appears as the name of any other class type or interface type declared in the same package <a href="7.doc.html#26783">(&#167;7.6)</a>.<p>
<a name="28418"></a>
A compile-time error occurs if the <i>Identifier</i> naming a class is also declared as a type by a single-type-import declaration <a href="7.doc.html#26699">(&#167;7.5.1)</a> in the compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a> containing the class declaration.<p>
<a name="227770"></a>
In the example:<p>
<pre><a name="18901"></a>
package test;
<br><a name="33758"></a>import java.util.Vector;
<br><a name="25534"></a>
class Point {
<a name="25538"></a>	int x, y;
<a name="244854"></a>}
<br><a name="244855"></a>
interface Point {											// compile-time error #1
<a name="244856"></a>	int getR();
<a name="244821"></a>	int getTheta();
<a name="25541"></a>}
<br><a name="18906"></a>class Vector { Point[] pts; }											// compile-time error #2
</pre><a name="22257"></a>
the first compile-time error is caused by the duplicate declaration of the name 
<code>Point</code> as both a <code>class</code> and an <code>interface</code> in the same package. A second error 
detected at compile time is the attempt to declare the name <code>Vector</code> both by a class 
type declaration and by a single-type-import declaration.
<p><a name="35887"></a>
Note, however, that it is not an error for the <i>Identifier</i> that names a class also to name a type that otherwise might be imported by a type-import-on-demand declaration <a href="7.doc.html#26725">(&#167;7.5.2)</a> in the compilation unit <a href="7.doc.html#40031">(&#167;7.3)</a> containing the class declaration. In the example:<p>
<pre><a name="35908"></a>
package test;
<br><a name="35909"></a>import java.util.*;
<br><a name="35917"></a>class Vector { Point[] pts; }											// not a compile-time error
</pre><a name="35926"></a>
the declaration of the class <code>Vector</code> is permitted even though there is also a class 
<code>java.util.Vector</code>. Within this compilation unit, the simple name <code>Vector</code> refers 
to the class <code>test.Vector</code>, not to <code>java.util.Vector</code> (which can still be referred 
to by code within the compilation unit, but only by its fully qualified name).
<p><a name="39196"></a>
<h3>8.1.1    Scope of a Class Type Name</h3>
<a name="39197"></a>
The <i>Identifier</i> in a class declaration specifies the name of the class. This class 
name has as its scope <a href="6.doc.html#33623">(&#167;6.3)</a> the entire package in which the class is declared. As 
an example, the compilation unit:
<p><pre><br><a name="16470"></a>package points;
<br></pre><pre><a name="16471"></a>
class Point {
<a name="16472"></a>	int x, y;									// coordinates
<a name="16473"></a>	PointColor color;									// color of this point
<a name="16474"></a>	Point next;									// next point with this color<br>
	static int nPoints;
<a name="16475"></a>}
<br><a name="16476"></a>
class PointColor {
<a name="16477"></a>	Point first;									// first point with this color
<a name="16478"></a>	PointColor(int color) {
<a name="228374"></a>		this.color = color;
<a name="228375"></a>	}
<a name="16479"></a>	private int color;									// color components
<a name="16480"></a>}
</pre><a name="16486"></a>
defines two classes that use each other in the declarations of their class members. 
Because the class type names <code>Point</code> and <code>PointColor</code> have the entire package 
<code>points</code>, including the entire current compilation unit, as their scope, this example 
compiles correctly-that is, forward reference is not a problem.
<p><a name="21613"></a>
<h3>8.1.2    Class Modifiers</h3>
<a name="54718"></a>
A class declaration may include <i>class modifiers</i>.
<p><ul><pre>
<i>ClassModifiers:<br>
	ClassModifier<br>
	ClassModifiers</i><code> </code><i>ClassModifier
</i>
<i>ClassModifier: one of<br>
	</i><code>public</code><i>&#32;</i><code>abstract&#32;final
</code></pre></ul><a name="14169"></a>
The access modifier <code>public</code> is discussed in <a href="6.doc.html#33916">&#167;6.6</a>. A compile-time error occurs if 
the same modifier appears more than once in a class declaration. If two or more 
class modifiers appear in a class declaration, then it is customary, though not 
required, that they appear in the order consistent with that shown above in the production
for <i>ClassModifier</i>.
<p><a name="34944"></a>
<h4>8.1.2.1    abstract Classes</h4>
<a name="20269"></a>
An <code>abstract</code> class is a class that is incomplete, or to be considered incomplete. 
Only <code>abstract</code> classes may have <code>abstract</code> methods (<a href="8.doc.html#34484">&#167;8.4.3.1</a>, <a href="9.doc.html#78651">&#167;9.4</a>), that is, 
methods that are declared but not yet implemented. If a class that is not <code>abstract</code> 
contains an <code>abstract</code> method, then a compile-time error occurs. A class has 
<code>abstract</code> methods if any of the following is true:
<p><ul><a name="36417"></a>
<li>It explicitly contains a declaration of an <code>abstract</code> method <a href="8.doc.html#78188">(&#167;8.4.3)</a>.
<a name="14240"></a>
<li>It inherits an <code>abstract</code> method from its direct superclass <a href="8.doc.html#21723">(&#167;8.1.3)</a>.
<a name="14247"></a>
<li>A direct superinterface (<a href="8.doc.html#34031">&#167;8.1.4</a>) of the class declares or inherits a method (which is therefore necessarily <code>abstract</code>) and the class neither declares nor inherits a method that implements it.
</ul><a name="54865"></a>
In the example:
<p><pre><a name="54866"></a>
abstract class Point {
<a name="54867"></a>	int x = 1, y = 1;
<a name="54868"></a>	void move(int dx, int dy) {
<a name="54869"></a>		x += dx;
<a name="54870"></a>		y += dy;
<a name="54871"></a>		alert();
<a name="54872"></a>	}
<a name="54873"></a>	abstract void alert();
<a name="54874"></a>}
<br><a name="36437"></a>
abstract class ColoredPoint extends Point {
<a name="36438"></a>	int color;
<a name="36439"></a>}
<br><a name="54875"></a>
class SimplePoint extends Point {
<a name="54876"></a>	void alert() { }
<a name="54877"></a>}
</pre><a name="54878"></a>
a class <code>Point</code> is declared that must be declared <code>abstract</code>, because it contains a 
declaration of an <code>abstract</code> method named <code>alert</code>. The subclass of <code>Point</code> named<code> 
ColoredPoint</code> inherits the <code>abstract</code> method <code>alert</code>, so it must also be declared 
<code>abstract</code>. On the other hand, the subclass of <code>Point</code> named <code>SimplePoint</code> provides
an implementation of <code>alert</code>, so it need not be <code>abstract</code>.
<p><a name="14273"></a>
A compile-time error occurs if an attempt is made to create an instance of an <code>abstract</code> class using a class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a>. An attempt to instantiate an <code>abstract</code> class using the <code>newInstance</code> method of class <code>Class</code> <a href="javalang.doc2.html#15088">(&#167;20.3.6)</a> will cause an <code>InstantiationException</code> <a href="11.doc.html#44285">(&#167;11.5.1)</a> to be thrown. Thus, continuing the example just shown, the statement:<p>
<pre><a name="54881"></a>	Point p = new Point();
</pre><a name="54883"></a>
would result in a compile-time error; the class <code>Point</code> cannot be instantiated 
because it is <code>abstract</code>. However, a <code>Point</code> variable could correctly be initialized 
with a reference to any subclass of <code>Point</code>, and the class <code>SimplePoint</code> is not 
<code>abstract</code>, so the statement:
<p><pre><a name="227781"></a>	Point p = new SimplePoint();
</pre><a name="227782"></a>
would be correct.
<p><a name="227783"></a>
A subclass of an <code>abstract</code> class that is not itself <code>abstract</code> may be instantiated, resulting in the execution of a constructor for the <code>abstract</code> class and, therefore, the execution of the field initializers for instance variables of that class. Thus, in the example just given, instantiation of a <code>SimplePoint</code> causes the default constructor and field initializers for <code>x</code> and <code>y</code> of <code>Point</code> to be executed.<p>
<a name="54900"></a>
It is a compile-time error to declare an <code>abstract</code> class type such that it is not possible to create a subclass that implements all of its <code>abstract</code> methods. This situation can occur if the class would have as members two <code>abstract</code> methods that have the same method signature <a href="8.doc.html#38649">(&#167;8.4.2)</a> but different return types. As an example, the declarations:<p>
<pre><a name="54908"></a>
interface Colorable { void setColor(int color); }
<a name="54909"></a>
abstract class Colored implements Colorable {
<a name="54910"></a>	abstract int setColor(int color);
<a name="54931"></a>}
</pre><a name="25369"></a>
result in a compile-time error: it would be impossible for any subclass of class 
<code>Colored</code> to provide an implementation of a method named <code>setColor</code>, taking one 
argument of type <code>int</code>, that can satisfy both <code>abstract</code> method specifications, 
because the one in interface <code>Colorable</code> requires the same method to return no 
value, while the one in class <code>Colored</code> requires the same method to return a value 
of type <code>int</code> <a href="8.doc.html#40420">(&#167;8.4)</a>.
<p><a name="36521"></a>
A class type should be declared <code>abstract</code> only if the intent is that subclasses can be created to complete the implementation. If the intent is simply to prevent instantiation of a class, the proper way to express this is to declare a constructor <a href="8.doc.html#16830">(&#167;8.6.8)</a> of no arguments, make it <code>private</code>, never invoke it, and declare no other constructors. A class of this form usually contains class methods and variables. The class <code>java.lang.Math</code> is an example of a class that cannot be instantiated; its declaration looks like this:<p>
<pre><a name="36522"></a>
public final class Math {
<br><a name="36523"></a>	private Math() { }							// never instantiate this class
<br><br><a name="36538"></a>	. . . declarations of class variables and methods . . .
<br><a name="36524"></a>}
</pre><a name="54727"></a>
<h4>8.1.2.2    final Classes</h4>
<a name="54729"></a>
A class can be declared <code>final</code> if its definition is complete and no subclasses are 
desired or required. A compile-time error occurs if the name of a <code>final</code> class 
appears in the <code>extends</code> clause <a href="8.doc.html#21723">(&#167;8.1.3)</a> of another <code>class</code> declaration; this implies 
that a <code>final</code> class cannot have any subclasses. A compile-time error occurs if a 
class is declared both <code>final</code> and <code>abstract</code>, because the implementation of such a 
class could never be completed <a href="8.doc.html#34944">(&#167;8.1.2.1)</a>.
<p><a name="36559"></a>
Because a <code>final</code> class never has any subclasses, the methods of a <code>final</code> class are never overridden <a href="8.doc.html#227927">(&#167;8.4.6.1)</a>.<p>
<a name="21723"></a>
<h3>8.1.3    Superclasses and Subclasses</h3>
<a name="29771"></a>
The optional <code>extends</code> clause in a class declaration specifies the <i>direct superclass</i> 
of the current class. A class is said to be a <i>direct subclass</i> of the class it extends. 
The direct superclass is the class from whose implementation the implementation 
of the current class is derived. The <code>extends</code> clause must not appear in the definition
of the class <code>java.lang.Object</code> <a href="javalang.doc1.html#46442">(&#167;20.1)</a>, because it is the primordial class 
and has no direct superclass. If the class declaration for any other class has no 
<code>extends</code> clause, then the class has the class <code>java.lang.Object</code> as its implicit 
direct superclass.
<p><ul><pre>
<i>Super:<br>
</i>	<code>extends </code><i>ClassType
</i></pre></ul><a name="229540"></a>
The following is repeated from <a href="4.doc.html#9317">&#167;4.3</a> to make the presentation here clearer:
<p><ul><pre>
<i>ClassType:<br>
</i>	<i>TypeName
</i></pre></ul><a name="29813"></a>
The <i>ClassType</i> must name an accessible <a href="6.doc.html#33916">(&#167;6.6)</a> class type, or a compile-time error occurs. All classes in the current package are accessible. Classes in other packages are accessible if the host system permits access to the package <a href="7.doc.html#37758">(&#167;7.2)</a> and the class is declared <code>public</code>. If the specified <i>ClassType </i>names a class that is <code>final</code> <a href="8.doc.html#54727">(&#167;8.1.2.2)</a>, then a compile-time error occurs; <code>final</code> classes are not allowed to have subclasses.<p>
<a name="34088"></a>
In the example:<p>
<pre><br><a name="34089"></a>class Point { int x, y; }
<br><br><a name="34090"></a>final class ColoredPoint extends Point { int color; }
<br><a name="34094"></a>class Colored3DPoint extends ColoredPoint { int z; } // error
</pre><a name="29322"></a>
the relationships are as follows:
<p><ul><a name="29323"></a>
<li>The class <code>Point</code> is a direct subclass of <code>java.lang.Object</code><i></i>.
<a name="29324"></a>
<li>The class <code>java.lang.Object</code> is the direct superclass of the class <code>Point</code><i></i>.
<a name="35258"></a>
<li>The class <code>ColoredPoint</code> is a direct subclass of class <code>Point</code><i></i>.
<a name="35261"></a>
<li>The class <code>Point</code> is the direct superclass of class <code>ColoredPoint</code>.
</ul><a name="35273"></a>
The declaration of class <code>Colored3dPoint</code> causes a compile-time error because it 
attempts to extend the <code>final</code> class <code>ColoredPoint</code>.
<p><a name="34079"></a>
The <i>subclass </i>relationship is the transitive closure of the direct subclass relationship. A class <i>A</i><i></i> is a subclass of class <i>C</i><i></i> if either of the following is true:<p>
<ul><a name="34080"></a>
<li><i>A</i> is the direct subclass of <i>C</i>.
<a name="34081"></a>
<li>There exists a class <i>B</i><i></i> such that <i>A</i><i></i> is a subclass of <i>B</i><i></i>, and <i>B</i><i></i> is a subclass of <i>C</i><i></i>, applying this definition recursively.
</ul><a name="34082"></a>
Class <i>C</i><i></i> is said to be a <i>superclass </i>of class <i>A</i><i></i> whenever <i>A</i><i> </i>is a subclass of <i>C</i><i></i>.
<p><a name="36594"></a>
In the example:<p>
<pre><br><a name="34023"></a>class Point { int x, y; }
<br><br><a name="34039"></a>class ColoredPoint extends Point { int color; }
<br><a name="34040"></a>final class Colored3dPoint extends ColoredPoint { int z; }
</pre><a name="35276"></a>
the relationships are as follows:
<p><ul><a name="36602"></a>
<li>The class <code>Point</code> is a superclass of class <code>ColoredPoint</code>.
<a name="36604"></a>
<li>The class <code>Point</code> is a superclass of class <code>Colored3dPoint</code><i></i>.
<a name="36611"></a>
<li>The class <code>ColoredPoint</code> is a subclass of class <code>Point</code>.
<a name="36613"></a>
<li>The class <code>ColoredPoint</code> is a superclass of class <code>Colored3dPoint</code><i></i>.
<a name="36619"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>ColoredPoint</code>.
<a name="36621"></a>
<li>The class <code>Colored3dPoint</code> is a subclass of class <code>Point</code>.
</ul><a name="21739"></a>
A compile-time error occurs if a class is declared to be a subclass of itself. For 
example:
<p><pre><br><a name="34029"></a>class Point extends ColoredPoint { int x, y; }
<br><a name="45856"></a>class ColoredPoint extends Point { int color; }
</pre><a name="25374"></a>
causes a compile-time error. If circularly declared classes are detected at run time, 
as classes are loaded <a href="12.doc.html#44459">(&#167;12.2)</a>, then a <code>ClassCircularityError</code> is thrown.
<p><a name="34031"></a>
<h3>8.1.4    Superinterfaces</h3>
<a name="18953"></a>
The optional <code>implements</code> clause in a class declaration lists the names of interfaces
that are <i>direct superinterfaces</i> of the class being declared:
<p><ul><pre>
<i>Interfaces:<br>
</i>	<code>implements </code><i>InterfaceTypeList
</i>
<i>InterfaceTypeList:<br>
</i>	<i>InterfaceType<br>
</i>	<i>InterfaceTypeList</i><code> , </code><i>InterfaceType
</i></pre></ul><a name="229546"></a>
The following is repeated from <a href="4.doc.html#9317">&#167;4.3</a> to make the presentation here clearer:
<p><ul><pre>
<i>InterfaceType:<br>
</i>	<i>TypeName
</i></pre></ul><a name="34112"></a>
Each <i>InterfaceType</i> must name an accessible <a href="6.doc.html#33916">(&#167;6.6)</a> interface type, or a compile-
time error occurs. All interfaces in the current package are accessible. Interfaces 
in other packages are accessible if the host system permits access to the package 
<a href="7.doc.html#13194">(&#167;7.4.4)</a> and the interface is declared <code>public</code>.
<p><a name="36646"></a>
A compile-time error occurs if the same interface is mentioned two or more times in a single <code>implements</code> clause, even if the interface is named in different ways; for example, the code:<p>
<pre><a name="36651"></a>
class Redundant implements java.lang.Cloneable, Cloneable {
<a name="36652"></a>	int x;
<a name="36654"></a>}
</pre><a name="36655"></a>
results in a compile-time error because the names <code>java.lang.Cloneable</code> and 
<code>Cloneable</code> refer to the same interface.
<p><a name="31147"></a>
An interface type <i>I</i><i></i> is a <i>superinterface</i> of class type <i>C</i><i></i> if any of the following is true:<p>
<ul><a name="34118"></a>
<li><i>I</i><i></i> is a direct superinterface of <i>C</i>.
<a name="29862"></a>
<li><i>C</i><i></i> has some direct superinterface <i>J</i><i></i> for which <i>I</i><i></i> is a superinterface<i></i>, using the definition of "superinterface of an interface" given in <a href="9.doc.html#78598">&#167;9.1.3</a>.
<a name="34121"></a>
<li><i>I</i><i></i> is a superinterface of the direct superclass of <i>C</i><i></i>, using this definition recursively.
</ul><a name="29918"></a>
A class is said to <i>implement</i> all its superinterfaces.
<p><a name="229105"></a>
In the example:<p>
<pre><a name="29875"></a>
public interface Colorable {
<a name="29876"></a>	void setColor(int color);
<a name="29877"></a>	int getColor();
<a name="29878"></a>}
<br><a name="29879"></a>
public interface Paintable extends Colorable {
<a name="29880"></a>	int MATTE = 0, GLOSSY = 1;
<a name="29881"></a>	void setFinish(int finish);
<a name="29882"></a>	int getFinish();
<a name="29883"></a>}
<br><br><a name="29884"></a>class Point { int x, y; }
<br><a name="29885"></a>
class ColoredPoint extends Point implements Colorable {
<a name="29886"></a>	int color;
<a name="29888"></a>	public void setColor(int color) { this.color = color; }
<a name="29889"></a>	public int getColor() { return color; }
<a name="29890"></a>}
<br><a name="29891"></a>
class PaintedPoint extends ColoredPoint implements Paintable <br>
{
<a name="29892"></a>	int finish;
<a name="29893"></a>	public void setFinish(int finish) {
<a name="230320"></a>		this.finish = finish;
<a name="230321"></a>	}
<a name="29894"></a>	public int getFinish() { return finish; }
<a name="29895"></a>}
</pre><a name="29896"></a>
the relationships are as follows:
<p><ul><a name="29897"></a>
<li>The interface <code>Paintable</code> is a superinterface of class <code>PaintedPoint</code>.
<a name="29898"></a>
<li>The interface <code>Colorable</code> is a superinterface of class <code>ColoredPoint</code> and of class <code>PaintedPoint</code>.
<a name="29899"></a>
<li>The interface <code>Paintable</code> is a subinterface of the interface <code>Colorable</code>, and <code>Colorable</code> is a superinterface of <code>Paintable</code>, <code>a</code>s defined in <a href="9.doc.html#78598">&#167;9.1.3</a>.
</ul><a name="29912"></a>
A class can have a superinterface in more than one way. In this example, the class 
<code>PaintedPoint</code> has <code>Colorable</code> as a superinterface both because it is a superinterface
of <code>ColoredPoint</code> and because it is a superinterface of <code>Paintable</code>.
<p><a name="29870"></a>
Unless the class being declared is <code>abstract</code>, the declarations of the methods defined in each direct superinterface must be implemented either by a declaration in this class or by an existing method declaration inherited from the direct superclass, because a class that is not <code>abstract</code> is not permitted to have <code>abstract</code> methods <a href="8.doc.html#34944">(&#167;8.1.2.1)</a>.<p>
<a name="230327"></a>
Thus, the example:<p>
<pre><a name="16122"></a>
interface Colorable {
<a name="16123"></a>	void setColor(int color);
<a name="16124"></a>	int getColor();
<a name="16125"></a>}
<br><br><a name="16126"></a>class Point { int x, y; };
<br><a name="16127"></a>
class ColoredPoint extends Point implements Colorable {
<a name="16128"></a>	int color;
<a name="16129"></a>}
</pre><a name="36705"></a>
causes a compile-time error, because <code>ColoredPoint</code> is not an <code>abstract</code> class but 
it fails to provide an implementation of methods <code>setColor</code> and <code>getColor</code> of the 
interface <code>Colorable</code>.
<p><a name="228059"></a>
It is permitted for a single method declaration in a class to implement methods of more than one superinterface. For example, in the code:<p>
<pre><br><a name="228063"></a>interface Fish { int getNumberOfScales(); }
<br><br><a name="228065"></a>interface Piano { int getNumberOfScales(); }
<br></pre><pre><a name="228061"></a>
class Tuna implements Fish, Piano {
<a name="228070"></a>	// You can tune a piano, but can you tuna fish?
<a name="228069"></a>	int getNumberOfScales() { return 91; }
<a name="228068"></a>}
</pre><a name="228071"></a>
the method <code>getNumberOfScales</code> in class <code>Tuna</code> has a name, signature, and return 
type that matches the method declared in interface <code>Fish</code> and also matches the 
method declared in interface <code>Piano</code>; it is considered to implement both.
<p><a name="228080"></a>
On the other hand, in a situation such as this:<p>
<pre><br><a name="228083"></a>interface Fish { int getNumberOfScales(); }
<br><br><a name="228084"></a>interface StringBass { double getNumberOfScales(); }
<br></pre><pre><a name="228085"></a>
class Bass implements Fish, StringBass {
<a name="228086"></a>	// This declaration cannot be correct, no matter what type is used.
<a name="228087"></a>	public ??? getNumberOfScales() { return 91; }
<a name="228088"></a>}
</pre><a name="228081"></a>
it is impossible to declare a method named <code>getNumberOfScales</code> with the same 
signature and return type as those of both the methods declared in interface <code>Fish</code> 
and in interface <code>StringBass</code>, because a class can have only one method with a 
given signature <a href="8.doc.html#40420">(&#167;8.4)</a>. Therefore, it is impossible for a single class to implement 
both interface <code>Fish</code> and interface <code>StringBass</code> <a href="8.doc.html#228745">(&#167;8.4.6)</a>.
<p><a name="18988"></a>
<h3>8.1.5    Class Body and Member Declarations</h3>
<a name="77979"></a>
A <i>class body</i> may contain declarations of members of the class, that is, fields 
<a href="8.doc.html#40898">(&#167;8.3)</a> and methods <a href="8.doc.html#40420">(&#167;8.4)</a>. A class body may also contain static initializers <a href="8.doc.html#39245">(&#167;8.5)</a> 
and declarations of constructors <a href="8.doc.html#41652">(&#167;8.6)</a> for the class.
<p><ul><pre>
<i>ClassBody:<br>
	</i><code>{ </code><i>ClassBodyDeclarations</i><sub><i>opt</i></sub><code> }
</code>
<i>ClassBodyDeclarations:<br>
</i>	<i>ClassBodyDeclaration<br>
</i>	<i>ClassBodyDeclarations</i><code> </code><i>ClassBodyDeclaration
</i>
<i>ClassBodyDeclaration:<br>
	ClassMemberDeclaration<br>
	StaticInitializer<br>
	ConstructorDeclaration
</i>
<i>ClassMemberDeclaration:<br>
	FieldDeclaration<br>
</i>	<i>MethodDeclaration
</i></pre></ul><a name="14175"></a>
The scope of the name of a member declared in or inherited by a class type is the 
entire body of the class type declaration.
<p><a name="21831"></a>
<h2>8.2    Class Members</h2>
<a name="40942"></a>
The members of a class type are all of the following:
<p><ul><a name="40946"></a>
<li>Members inherited from its direct superclass <a href="8.doc.html#21723">(&#167;8.1.3)</a>, except in class <code>Object</code>, which has no direct superclass
<a name="45862"></a>
<li>Members inherited from any direct superinterfaces <a href="8.doc.html#34031">(&#167;8.1.4)</a>
<a name="45866"></a>
<li>Members declared in the body of the class <a href="8.doc.html#18988">(&#167;8.1.5)</a>
</ul><a name="30394"></a>
Members of a class that are declared <code>private</code> are not inherited by subclasses of that class. Only members of a class that are declared <code>protected</code> or <code>public</code> are inherited by subclasses declared in a package other than the one in which the class is declared.<p>
<a name="230007"></a>
Constructors and static initializers are not members and therefore are not inherited.<p>
<a name="36731"></a>
The example:<p>
<pre><a name="14608"></a>
class Point {
<a name="14609"></a>	int x, y;
<a name="36739"></a>	private Point() { reset(); }
<a name="14610"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="16317"></a>	private void reset() { this.x = 0; this.y = 0; }
<a name="14611"></a>}
<br><a name="14612"></a>
class ColoredPoint extends Point {
<a name="36760"></a>	int color;
<a name="36761"></a>	void clear() { reset(); }														// error
<a name="36762"></a>}
<br><a name="14615"></a>
class Test {
<a name="14616"></a>	public static void main(String[] args) {
<a name="14617"></a>		ColoredPoint c = new ColoredPoint(0, 0);													// error
<a name="16316"></a>		c.reset();													// error
<a name="14618"></a>	}
<a name="14619"></a>}
</pre><a name="14620"></a>
causes four compile-time errors:
<p><ul><a name="16328"></a>
<li>An error occurs because <code>ColoredPoint</code> has no constructor declared with two integer parameters, as requested by the use in <code>main</code>. This illustrates the fact that <code>ColoredPoint</code> does not inherit the constructors of its superclass <code>Point</code>.
<a name="16329"></a>
<li>Another error occurs because <code>ColoredPoint</code> declares no constructors, and therefore a default constructor for it is automatically created <a href="8.doc.html#16823">(&#167;8.6.7)</a>, and this default constructor is equivalent to:
<a name="14624"></a>	ColoredPoint() { super(); }
</ul><ul><a name="14625"></a>
<br><br>which invokes the constructor, with no arguments, for the direct superclass of the class <code>ColoredPoint</code>. The error is that the constructor for <code>Point</code> that takes no arguments is <code>private</code>, and therefore is not accessible outside the class <code>Point</code>, even through a superclass constructor invocation <a href="8.doc.html#78435">(&#167;8.6.5)</a>.
</ul><ul><a name="16327"></a>
<li>Two more errors occur because the method <code>reset</code> of class <code>Point</code> is <code>private</code>, and therefore is not inherited by class <code>ColoredPoint</code>. The method invocations in method <code>clear</code> of class <code>ColoredPoint</code> and in method <code>main</code> of class <code>Test</code> are therefore not correct.
</ul><a name="30229"></a>
<h3>8.2.1    Examples of Inheritance</h3>
<a name="36776"></a>
This section illustrates inheritance of class members through several examples.
<p><a name="40830"></a>
<h4>8.2.1.1    Example: Inheritance with Default Access</h4>
<a name="40831"></a>
Consider the example where the <code>points</code> package declares two compilation units:
<p><pre><br><a name="40832"></a>package points;
<br></pre><pre><a name="40833"></a>
public class Point {
<a name="40834"></a>	int x, y;<br>
	public void move(int dx, int dy) { x += dx; y += dy; }
<a name="40835"></a>}
</pre><a name="40836"></a>
and:
<p><pre><br><a name="40837"></a>package points;
<br></pre><pre><a name="40838"></a>
public class Point3d extends Point {
<a name="40839"></a>	int z;
<a name="40840"></a>	public void move(int dx, int dy, int dz) {
<a name="40841"></a>		x += dx; y += dy; z += dz;
<a name="40842"></a>	}
<a name="40843"></a>}
</pre><a name="40844"></a>
and a third compilation unit, in another package, is:
<p><pre><br><a name="40845"></a>import points.Point3d;
<br></pre><pre><a name="40846"></a>
class Point4d extends Point3d {
<a name="40847"></a>	int w;
<a name="40848"></a>	public void move(int dx, int dy, int dz, int dw) {
<a name="40849"></a>		x += dx; y += dy; z += dz; w += dw; // compile-time errors
<a name="40850"></a>	}
<a name="40851"></a>}
</pre><a name="40852"></a>
Here both classes in the <code>points</code> package compile. The class <code>Point3d</code> inherits the 
fields <code>x</code> and <code>y</code> of class <code>Point</code>, because it is in the same package as <code>Point</code>. The 
class <code>Point4d</code>, which is in a different package, does not inherit the fields <code>x</code> and <code>y</code> 
of class <code>Point</code> or the field <code>z</code> of class <code>Point3d</code>, and so fails to compile.
<p><a name="40853"></a>
A better way to write the third compilation unit would be:<p>
<pre><br><a name="40854"></a>import points.Point3d;
<br></pre><pre><a name="40855"></a>
class Point4d extends Point3d {
<a name="40856"></a>	int w;
<a name="40857"></a>	public void move(int dx, int dy, int dz, int dw) {
<a name="40858"></a>		super.move(dx, dy, dz); w += dw;
<a name="40859"></a>	}
<a name="40860"></a>}
</pre><a name="40861"></a>
using the <code>move</code> method of the superclass <code>Point3d</code> to process <code>dx</code>, <code>dy</code>, and <code>dz</code>. If 
<code>Point4d</code> is written in this way it will compile without errors.
<p><a name="40862"></a>
<h4>8.2.1.2    Inheritance with public and protected</h4>
<a name="40863"></a>
Given the class <code>Point</code>:
<p><pre><br><a name="40864"></a>package points;
<br></pre><pre><a name="40865"></a>
public class Point {
<br><a name="40866"></a>	public int x, y;
<br><br><a name="40867"></a>	protected int useCount = 0;
<br><br><a name="40868"></a>	static protected int totalUseCount = 0;
<br><a name="36785"></a>
	public void move(int dx, int dy) {
<a name="40869"></a>		x += dx; y += dy; useCount++; totalUseCount++;
<a name="40870"></a>	}
<br><a name="40871"></a>}
</pre><a name="40872"></a>
the <code>public</code> and <code>protected</code> fields <code>x</code>, <code>y</code>, <code>useCount</code> and <code>totalUseCount</code> are inherited
in all subclasses of <code>Point</code>. Therefore, this test program, in another package, 
can be compiled successfully:
<p><pre><a name="40873"></a>
class Test extends points.Point {
<a name="40874"></a>	public void moveBack(int dx, int dy) {
<a name="40875"></a>		x -= dx; y -= dy; useCount++; totalUseCount++;
<a name="40876"></a>	}
<a name="40877"></a>}
</pre><a name="40879"></a>
<h4>8.2.1.3    Inheritance with private</h4>
<a name="40880"></a>
In the example:
<p><pre><a name="40881"></a>
class Point {
<br><a name="40882"></a>	int x, y;
<br><a name="40883"></a>
	void move(int dx, int dy) {
<a name="40884"></a>		x += dx; y += dy; totalMoves++;
<a name="40885"></a>	}
<br><br><a name="40886"></a>	private static int totalMoves;
<br><br><a name="40887"></a>	void printMoves() { System.out.println(totalMoves); }
<br><a name="40888"></a>}
<br><a name="40889"></a>
class Point3d extends Point {
<br><a name="40890"></a>	int z;
<br><a name="40891"></a>
	void move(int dx, int dy, int dz) {
<a name="40892"></a>		super.move(dx, dy); z += dz; totalMoves++;
<a name="40893"></a>	}
<br><a name="40894"></a>}
</pre><a name="40822"></a>
the class variable totalMoves can be used only within the class <code>Point</code>; it is not 
inherited by the subclass <code>Point3d</code>. A compile-time error occurs at the point where 
method <code>move</code> of class <code>Point3d</code> tries to increment totalMoves.
<p><a name="23530"></a>
<h4>8.2.1.4    Accessing Members of Inaccessible Classes</h4>
<a name="23515"></a>
Even though a class might not be declared <code>public</code>, instances of the class might be 
available at run time to code outside the package in which it is declared if it has a 
<code>public</code> superclass or superinterface. An instance of the class can be assigned to a 
variable of such a <code>public</code> type. An invocation of a <code>public</code> method of the object 
referred to by such a variable may invoke a method of the class if it implements or 
overrides a method of the <code>public</code> superclass or superinterface. (In this situation, 
the method is necessarily declared <code>public</code>, even though it is declared in a class 
that is not <code>public</code>.)
<p><a name="23519"></a>
Consider the compilation unit:<p>
<pre><br><a name="36842"></a>package points;
<br></pre><pre><a name="36843"></a>
public class Point {
<a name="36844"></a>	public int x, y;
<a name="36847"></a>	public void move(int dx, int dy) {
<a name="36848"></a>		x += dx; y += dy;
<a name="36849"></a>	}
<a name="36850"></a>}
</pre><a name="36865"></a>
and another compilation unit of another package:
<p><pre><br><a name="23520"></a>package morePoints;
<br></pre><pre><a name="23521"></a>
class Point3d extends points.Point {
<a name="23522"></a>	public int z;
<a name="36870"></a>	public void move(int dx, int dy, int dz) {
<a name="36871"></a>		super.move(dx, dy); z += dz;
<a name="36872"></a>	}
<a name="23523"></a>}
<br><a name="23524"></a>
public class OnePoint {
<a name="23525"></a>	static points.Point getOne() { return new Point3d(); }
<a name="23526"></a>}
</pre><a name="23527"></a>
An invocation <code>morePoints.OnePoint.getOne()</code> in yet a third package would 
return a <code>Point3d</code> that can be used as a <code>Point</code>, even though the type <code>Point3d</code> is 
not available outside the package <code>morePoints</code>. The method <code>move</code> could then be 
invoked for that object, which is permissible because method <code>move</code> of <code>Point3d</code> is 
<code>public</code> (as it must be, for any method that overrides a <code>public</code> method must itself 
be <code>public</code>, precisely so that situations such as this will work out correctly). The 
fields <code>x</code> and <code>y</code> of that object could also be accessed from such a third package.
<p><a name="36884"></a>
While the field <code>z</code> of class <code>Point3d</code> is <code>public</code>, it is not possible to access this field from code outside the package <code>morePoints</code>, given only a reference to an instance of class <code>Point3d</code> in a variable <code>p</code> of type <code>Point</code>. This is because the expression <code>p.z</code> is not correct, as <code>p</code> has type <code>Point</code> and class <code>Point</code> has no field named <code>z</code>; also, the expression <code>((Point3d)p).z</code> is not correct, because the class type <code>Point3d</code> cannot be referred to outside package <code>morePoints</code>. The declaration of the field <code>z</code> as <code>public</code> is not useless, however. If there were to be, in package <code>morePoints</code>, a <code>public</code> subclass <code>Point4d</code> of the class <code>Point3d</code>:<p>
<pre><br><a name="36889"></a>package morePoints;
<br></pre><pre><a name="36890"></a>
public class Point4d extends Point3d {
<a name="36891"></a>	public int w;
<a name="36892"></a>	public void move(int dx, int dy, int dz, int dw) {
<a name="36893"></a>		super.move(dx, dy, dz); w += dw;
<a name="36894"></a>	}
<a name="36896"></a>}
<br></pre><a name="36887"></a>
then class <code>Point4d</code> would inherit the field <code>z</code>, which, being <code>public</code>, could then be 
accessed by code in packages other than <code>morePoints</code>, through variables and 
expressions of the <code>public</code> type <code>Point4d</code>.
<p><a name="40898"></a>
<h2>8.3    Field Declarations</h2>
<a name="40823"></a>
The variables of a class type are introduced by <i>field declarations</i>:
<p><ul><pre>
<i>FieldDeclaration:<br>
	FieldModifiers</i><sub><i>opt</i></sub><code> </code><i>Type</i><code> </code><i>VariableDeclarators</i><code> ;
</code>
<i>VariableDeclarators:<br>
</i>	<i>VariableDeclarator<br>
</i>	<i>VariableDeclarators</i><code> , </code><i>VariableDeclarator
</i>
<i>VariableDeclarator:<br>
</i>	<i>VariableDeclaratorId<br>
</i>	<i>VariableDeclaratorId</i><code> = </code><i>VariableInitializer
</i>
<i>VariableDeclaratorId:<br>
</i>	<i>Identifier<br>
</i>	<i>VariableDeclaratorId</i><code> [ ]
</code>
<i>VariableInitializer:<br>
</i>	<i>Expression<br>
</i>	<i>ArrayInitializer
</i></pre></ul><a name="78087"></a>
The <i>FieldModifiers</i> are described in <a href="8.doc.html#78091">&#167;8.3.1</a>. The <i>Identifier</i> in a <i>FieldDeclarator</i> 
may be used in a name to refer to the field. The name of a field has as its scope 
<a href="6.doc.html#33623">(&#167;6.3)</a> the entire body of the class declaration in which it is declared. More than 
one field may be declared in a single field declaration by using more than one 
declarator; the <i>FieldModifiers</i> and <i>Type</i> apply to all the declarators in the declaration.
Variable declarations involving array types are discussed in <a href="10.doc.html#25891">&#167;10.2</a>.
<p><a name="29989"></a>
It is a compile-time error for the body of a class declaration to contain declarations of two fields with the same name. Methods and fields may have the same name, since they are used in different contexts and are disambiguated by the different lookup procedures <a href="6.doc.html#20569">(&#167;6.5)</a>.<p>
<a name="36999"></a>
If the class declares a field with a certain name, then the declaration of that field is said to <i>hide</i> <a href="6.doc.html#34133">(&#167;6.3.1)</a> any and all accessible declarations of fields with the same name in the superclasses and superinterfaces of the class.<p>
<a name="38152"></a>
If a field declaration hides the declaration of another field, the two fields need not have the same type.<p>
<a name="38148"></a>
A class inherits from its direct superclass and direct superinterfaces all the fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.<p>
<a name="37087"></a>
It is possible for a class to inherit more than one field with the same name <a href="8.doc.html#40491">(&#167;8.3.3.3)</a>. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.<p>
<a name="37038"></a>
There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.<p>
<a name="37037"></a>
A hidden field can be accessed by using a qualified name (if it is <code>static</code>) or by using a field access expression <a href="15.doc.html#41267">(&#167;15.10)</a> that contains the keyword <code>super</code> or a cast to a superclass type. See <a href="15.doc.html#20860">&#167;15.10.2</a> for discussion and an example.<p>
<a name="78091"></a>
<h3>8.3.1    Field Modifiers</h3>
<ul><pre>
<i>FieldModifiers:<br>
	FieldModifier<br>
	FieldModifiers</i><code> </code><i>FieldModifier
</i>
<i>FieldModifier: one of<br>
	</i><code>public&#32;protected&#32;private<br>
	final&#32;static&#32;transient&#32;volatile
</code></pre></ul><a name="35964"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="6.doc.html#33916">&#167;6.6</a>. A 
compile-time error occurs if the same modifier appears more than once in a field 
declaration, or if a field declaration has more than one of the access modifiers 
<code>public</code>, <code>protected</code>, and <code>private</code>. If two or more (distinct) field modifiers 
appear in a field declaration, it is customary, though not required, that they appear 
in the order consistent with that shown above in the production for <i>FieldModifier</i>.
<p><a name="37544"></a>
<h4>8.3.1.1    static Fields</h4>
<a name="230789"></a>
If a field is declared <code>static</code>, there exists exactly one incarnation of the field, no 
matter how many instances (possibly zero) of the class may eventually be created. 
A <code>static</code> field, sometimes called a <i>class variable</i>, is incarnated when the class is 
initialized <a href="12.doc.html#44557">(&#167;12.4)</a>.
<p><a name="230793"></a>
A field that is not declared <code>static</code> (sometimes called a non-<code>static</code> field) is called an <i>instance variable</i>. Whenever a new instance of a class is created, a new variable associated with that instance is created for every instance variable declared in that class or any of its superclasses.<p>
<a name="38985"></a>
The example program:<p>
<pre><a name="37567"></a>
class Point {
<a name="37568"></a>	int x, y, useCount;
<a name="37569"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="37572"></a>	final static Point origin = new Point(0, 0);
<a name="37573"></a>}
<br><a name="37574"></a>
class Test {
<a name="37575"></a>	public static void main(String[] args) {
<a name="37576"></a>		Point p = new Point(1,1);
<a name="37577"></a>		Point q = new Point(2,2);
<a name="37578"></a>		p.x = 3; p.y = 3; p.useCount++; p.origin.useCount++;
<a name="37579"></a>		System.out.println("(" + q.x + "," + q.y + ")");
<a name="37615"></a>		System.out.println(q.useCount);
<a name="37581"></a>		System.out.println(q.origin == Point.origin);
<a name="37662"></a>		System.out.println(q.origin.useCount);
<a name="37582"></a>	}
<a name="37583"></a>}
</pre><a name="37584"></a>
prints:
<p><pre><a name="37585"></a>
(2,2)
<a name="37618"></a>0
<a name="37587"></a>true
<a name="37667"></a>1
</pre><a name="37588"></a>
showing that changing the fields <code>x</code>, <code>y</code>, and <code>useCount</code> of <code>p</code> does not affect the fields 
of <code>q</code>, because these fields are instance variables in distinct objects. In this example, 
the class variable <code>origin</code> of the class <code>Point</code> is referenced both using the class 
name as a qualifier, in <code>Point.origin</code>, and using variables of the class type in 
field access expressions <a href="15.doc.html#41267">(&#167;15.10)</a>, as in <code>p.origin</code> and <code>q.origin</code>. These two ways 
of accessing the <code>origin</code> class variable access the same object, evidenced by the 
fact that the value of the reference equality expression <a href="15.doc.html#236163">(&#167;15.20.3)</a>:
<p><pre><a name="227823"></a><code>q.origin==Point.origin
</code></pre><a name="227825"></a>
is <code>true</code>. Further evidence is that the incrementation:
<p><pre><a name="37670"></a>p.origin.useCount++;
</pre><a name="37671"></a>
causes the value of q.origin.useCount to be <code>1</code>; this is so because <code>p.origin</code> and 
<code>q.origin</code> refer to the same variable.
<p><a name="35962"></a>
<h4>8.3.1.2    final Fields</h4>
<a name="14727"></a>
A field can be declared <code>final</code>, in which case its declarator must include a variable 
initializer or a compile-time error occurs. Both class and instance variables 
(<code>static</code> and non-<code>static</code> fields) may be declared <code>final</code>.
<p><a name="37504"></a>
Any attempt to assign to a <code>final</code> field results in a compile-time error. Therefore, once a <code>final</code> field has been initialized, it always contains the same value. If a <code>final</code> field holds a reference to an object, then the state of the object may be changed by operations on the object, but the field will always refer to the same object. This applies also to arrays, because arrays are objects; if a <code>final</code> field holds a reference to an array, then the components of the array may be changed by operations on the array, but the field will always refer to the same array.<p>
<a name="14728"></a>
Declaring a field <code>final</code> can serve as useful documentation that its value will not change, can help to avoid programming errors, and can make it easier for a compiler to generate efficient code.<p>
<a name="37005"></a>
In the example:<p>
<pre><a name="37006"></a>
class Point {
<a name="37053"></a>	int x, y;
<a name="37066"></a>	int useCount;
<a name="37049"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="37058"></a>	final static Point origin = new Point(0, 0);
<a name="37056"></a>}
</pre><a name="37059"></a>
the class <code>Point</code> declares a <code>final</code> class variable <code>origin</code>. The <code>origin</code> variable 
holds a reference to an object that is an instance of class <code>Point</code> whose coordinates 
are (0, 0). The value of the variable <code>Point.origin</code> can never change, so it always 
refers to the same <code>Point</code> object, the one created by its initializer. However, an 
operation on this <code>Point</code> object might change its state-for example, modifying its 
<code>useCount</code> or even, misleadingly, its <code>x</code> or <code>y</code> coordinate.
<p><a name="78119"></a>
<h4>8.3.1.3    transient Fields</h4>
<a name="37020"></a>
Variables may be marked <code>transient</code> to indicate that they are not part of the persistent
state of an object. If an instance of the class <code>Point</code>:
<p><pre><a name="14770"></a>
class Point {
<a name="14771"></a>	int x, y;
<a name="14772"></a>	transient float rho, theta;
<a name="14773"></a>}
</pre><a name="14775"></a>
were saved to persistent storage by a system service, then only the fields <code>x</code> and <code>y</code> 
would be saved. This specification does not yet specify details of such services; 
we intend to provide them in a future version of this specification.
<p><a name="36930"></a>
<h4>8.3.1.4    volatile Fields</h4>
<a name="37715"></a>
As described in <a href="17.doc.html#26250">&#167;17</a>, the Java language allows threads that access shared variables 
to keep private working copies of the variables; this allows a more efficient implementation
of multiple threads. These working copies need be reconciled with the 
master copies in the shared main memory only at prescribed synchronization 
points, namely when objects are locked or unlocked. As a rule, to ensure that 
shared variables are consistently and reliably updated, a thread should ensure that 
it has exclusive use of such variables by obtaining a lock that, conventionally, 
enforces mutual exclusion for those shared variables.
<p><a name="37727"></a>
Java provides a second mechanism that is more convenient for some purposes: a field may be declared <code>volatile</code>, in which case a thread must reconcile its working copy of the field with the master copy every time it accesses the variable. Moreover, operations on the master copies of one or more volatile variables on behalf of a thread are performed by the main memory in exactly the order that the thread requested.<p>
<a name="14790"></a>
If, in the following example, one thread repeatedly calls the method <code>one</code> (but no more than <code>Integer.MAX_VALUE</code> <a href="javalang.doc6.html#2391">(&#167;20.7.2)</a> times in all), and another thread repeatedly calls the method <code>two</code>:<p>
<pre><a name="14792"></a>
class Test {
<br><a name="14793"></a>	static int i = 0, j = 0;
<br><a name="14794"></a>
	static void one() { i++; j++; }
<a name="14796"></a>
	static void two() {
<a name="14797"></a>		System.out.println("i=" + i + " j=" + j);
<a name="14801"></a>	}
<br><a name="14802"></a>}
</pre><a name="14803"></a>
then method <code>two</code> could occasionally print a value for <code>j</code> that is greater than the 
value of <code>i</code>, because the example includes no synchronization and, under the rules 
explained in <a href="17.doc.html#26250">&#167;17</a>, the shared values of <code>i</code> and <code>j</code> might be updated out of order.
<p><a name="37738"></a>
One way to prevent this out-or-order behavior would be to declare methods <code>one</code> and <code>two</code> to be <code>synchronized</code> <a href="8.doc.html#55408">(&#167;8.4.3.5)</a>:<p>
<pre><a name="37768"></a>
class Test {
<br><a name="37769"></a>	static int i = 0, j = 0;
<br><a name="37770"></a>
	static synchronized void one() { i++; j++; }
<a name="37771"></a>
	static synchronized void two() {
<a name="37772"></a>		System.out.println("i=" + i + " j=" + j);
<a name="37773"></a>	}
<br><a name="37774"></a>}
</pre><a name="37777"></a>
This prevents method <code>one</code> and method <code>two</code> from being executed concurrently, and 
furthermore guarantees that the shared values of <code>i</code> and <code>j</code> are both updated before 
method <code>one</code> returns. Therefore method <code>two</code> never observes a value for <code>j</code> greater 
than that for <code>i</code>; indeed, it always observes the same value for <code>i</code> and <code>j</code>.
<p><a name="37789"></a>
Another approach would be to declare <code>i</code> and <code>j</code> to be <code>volatile</code>:<p>
<pre><a name="37793"></a>
class Test {
<br><a name="37794"></a>	static volatile int i = 0, j = 0;
<br><a name="37795"></a>
	static void one() { i++; j++; }
<a name="37796"></a>
	static void two() {
<a name="37797"></a>		System.out.println("i=" + i + " j=" + j);
<a name="37798"></a>	}
<br><a name="37799"></a>}
</pre><a name="37800"></a>
This allows method <code>one</code> and method <code>two</code> to be executed concurrently, but guarantees
that accesses to the shared values for <code>i</code> and <code>j</code> occur exactly as many times, 
and in exactly the same order, as they appear to occur during execution of the program
text by each thread. Therefore, method <code>two</code> never observes a value for <code>j</code> 
greater than that for <code>i</code>, because each update to <code>i</code> must be reflected in the shared 
value for <code>i</code> before the update to <code>j</code> occurs. It is possible, however, that any given 
invocation of method <code>two</code> might observe a value for <code>j</code> that is much greater than the 
value observed for <code>i</code>, because method <code>one</code> might be executed many times between 
the moment when method <code>two</code> fetches the value of <code>i</code> and the moment when 
method <code>two</code> fetches the value of <code>j</code>.
<p><a name="14791"></a>
See <a href="17.doc.html#26250">&#167;17</a> for more discussion and examples.<p>
<a name="24509"></a>
A compile-time error occurs if a <code>final</code> variable is also declared <code>volatile</code>.<p>
<a name="24510"></a>
<h3>8.3.2    Initialization of Fields</h3>
<a name="41082"></a>
If a field declarator contains a <i>variable initializer</i>, then it has the semantics of an 
assignment <a href="15.doc.html#5281">(&#167;15.25)</a> to the declared variable, and:
<p><ul><a name="37635"></a>
<li>If the declarator is for a class variable (that is, a <code>static</code> field), then the variable initializer is evaluated and the assignment performed exactly once, when the class is initialized <a href="12.doc.html#44557">(&#167;12.4)</a>.
<a name="37639"></a>
<li>If the declarator is for an instance variable (that is, a field that is not <code>static</code>), then the variable initializer is evaluated and the assignment performed each time an instance of the class is created <a href="12.doc.html#44670">(&#167;12.5)</a>. 
</ul><a name="38002"></a>
The example:<p>
<pre><a name="30354"></a>
class Point {
<a name="30355"></a>	int x = 1, y = 5;
<a name="30356"></a>}
<br><a name="30357"></a>class Test {
<a name="30358"></a>	public static void main(String[] args) {
<a name="30359"></a>		Point p = new Point();
<a name="30360"></a>		System.out.println(p.x + ", " + p.y);
<a name="30361"></a>	}
<a name="30362"></a>}
</pre><a name="30363"></a>
produces the output:
<p><pre><a name="30377"></a>1, 5
</pre><a name="30378"></a>
because the assignments to <code>x</code> and <code>y</code> occur whenever a new <code>Point</code> is created.
<p><a name="30370"></a>
Variable initializers are also used in local variable declaration statements <a href="14.doc.html#5920">(&#167;14.3)</a>, where the initializer is evaluated and the assignment performed each time the local variable declaration statement is executed.<p>
<a name="38006"></a>
It is a compile-time error if the evaluation of a variable initializer for a field of a class (or interface) can complete abruptly with a checked exception <a href="11.doc.html#44121">(&#167;11.2)</a>.<p>
<a name="38010"></a>
<h4>8.3.2.1    Initializers for Class Variables</h4>
<a name="229741"></a>
A compile-time error occurs if an initialization expression for a class variable contains
a use by a simple name of that class variable or of another class variable 
whose declaration occurs to its right (that is, textually later) in the same class. 
Thus:
<p><pre><a name="229742"></a>
class Test {
<a name="229743"></a>	static float f = j;							// compile-time error: forward reference
<a name="229744"></a>	static int j = 1;
<a name="229745"></a>	static int k = k+1;							// compile-time error: forward reference
<a name="229746"></a>}
</pre><a name="229747"></a>
causes two compile-time errors, because <code>j</code> is referred to in the initialization of <code>f</code> 
before <code>j</code> is declared and because the initialization of <code>k</code> refers to <code>k</code> itself.
<p><a name="37971"></a>
If a reference by simple name to any instance variable occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="37934"></a>
If the keyword <code>this</code> <a href="15.doc.html#31980">(&#167;15.7.2)</a> or the keyword <code>super</code> (<a href="15.doc.html#20860">&#167;15.10.2</a>, <a href="15.doc.html#20448">&#167;15.11</a>) occurs in an initialization expression for a class variable, then a compile-time error occurs.<p>
<a name="229548"></a>
(One subtlety here is that, at run time, <code>static</code> variables that are <code>final</code> and that are initialized with compile-time constant values are initialized first. This also applies to such fields in interfaces <a href="9.doc.html#40720">(&#167;9.3.1)</a>. These variables are "constants" that will never be observed to have their default initial values <a href="4.doc.html#10931">(&#167;4.5.4)</a>, even by devious programs. See <a href="12.doc.html#44630">&#167;12.4.2</a> and <a href="13.doc.html#45139">&#167;13.4.8</a> for more discussion.)<p>
<a name="38013"></a>
<h4>8.3.2.2    Initializers for Instance Variables</h4>
<a name="30374"></a>
A compile-time error occurs if an initialization expression for an instance variable 
contains a use by a simple name of that instance variable or of another instance 
variable whose declaration occurs to its right (that is, textually later) in the same 
class. Thus:
<p><pre><a name="27881"></a>
class Test {
<a name="27882"></a>	float f = j;
<a name="27883"></a>	int j = 1;
<a name="37876"></a>	int k = k+1;
<a name="27884"></a>}
</pre><a name="27885"></a>
causes two compile-time errors, because <code>j</code> is referred to in the initialization of <code>f</code> 
before <code>j</code> is declared and because the initialization of <code>k</code> refers to <code>k</code> itself.
<p><a name="37982"></a>
Initialization expressions for instance variables may use the simple name of any <code>static</code> variable declared in or inherited by the class, even one whose declaration occurs textually later. Thus the example:<p>
<pre><a name="37983"></a>
class Test {
<a name="37984"></a>	float f = j;
<a name="37985"></a>	static int j = 1;
<a name="37987"></a>}
</pre><a name="37988"></a>
compiles without error; it initializes <code>j</code> to <code>1</code> when class <code>Test</code> is initialized, and initializes
<code>f</code> to the current value of <code>j</code> every time an instance of class <code>Test</code> is created.
<p><a name="40409"></a>
Initialization expressions for instance variables are permitted to refer to the current object <code>this</code> <a href="15.doc.html#31980">(&#167;15.7.2)</a> and to use the keyword <code>super</code> (<a href="15.doc.html#20860">&#167;15.10.2</a>, <a href="15.doc.html#20448">&#167;15.11</a>).<p>
<a name="40425"></a>
<h3>8.3.3    Examples of Field Declarations</h3>
<a name="40426"></a>
The following examples illustrate some (possibly subtle) points about field declarations.

<p><a name="40428"></a>
<h4>8.3.3.1    Example: Hiding of Class Variables</h4>
<a name="40429"></a>
The example:
<p><pre><a name="40430"></a>
class Point {
<a name="40431"></a>	static int x = 2;
<a name="40432"></a>}
<br><a name="40433"></a>
class Test extends Point {
<a name="40434"></a>	static double x = 4.7;
<a name="40435"></a>	public static void main(String[] args) {<br>
		new Test().printX();
<a name="229781"></a>	}
<a name="229782"></a>	void printX() {
<a name="40436"></a>		System.out.println(x + " " + super.x);
<a name="40437"></a>	}
<a name="40438"></a>}
</pre><a name="40439"></a>
produces the output:
<p><pre><a name="40440"></a>4.7 2
</pre><a name="40441"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, 
so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. Within the 
declaration of class <code>Test</code>, the simple name <code>x</code> refers to the field declared within 
class <code>Test</code>. Code in class <code>Test</code> may refer to the field <code>x</code> of class <code>Point</code> as <code>super.x</code> 
(or, because <code>x</code> is <code>static</code>, as <code>Point.x</code>). If the declaration of <code>Test.x</code> is deleted:
<p><pre><a name="40442"></a>
class Point {
<a name="40443"></a>	static int x = 2;
<a name="40444"></a>}
<br><a name="40445"></a>
class Test extends Point {
<a name="229789"></a>	public static void main(String[] args) {
<a name="229790"></a>		new Test().printX();
<a name="229791"></a>	}
<a name="229786"></a>	void printX() {
<a name="40447"></a>		System.out.println(x + " " + super.x);
<a name="40448"></a>	}
<a name="40449"></a>}
</pre><a name="40450"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>; instead, the 
simple name <code>x</code> now refers to the field <code>Point.x</code>. Code in class <code>Test</code> may still refer 
to that same field as <code>super.x</code>. Therefore, the output from this variant program is:
<p><pre><a name="40451"></a>2 2
</pre><a name="229119"></a>
<h4>8.3.3.2    Example: Hiding of Instance Variables</h4>
<a name="40453"></a>
This example is similar to that in the previous section, but uses instance variables 
rather than static variables. The code:
<p><pre><a name="40454"></a>
class Point {
<a name="40455"></a>	int x = 2;
<a name="40456"></a>}
<br><a name="40457"></a>
class Test extends Point {
<a name="40458"></a>	double x = 4.7;
<a name="40459"></a>	void printBoth() {
<a name="40460"></a>		System.out.println(x + " " + super.x);
<a name="40461"></a>	}
<a name="40462"></a>	public static void main(String[] args) {
<a name="40463"></a>		Test sample = new Test();
<a name="40464"></a>		sample.printBoth();
<a name="40465"></a>		System.out.println(sample.x + " " + <br>
												((Point)sample).x);
<a name="40466"></a>	}
<a name="40467"></a>}
</pre><a name="40468"></a>
produces the output:
<p><pre><a name="40469"></a>
4.7 2
<a name="40470"></a>4.7 2
</pre><a name="40471"></a>
because the declaration of <code>x</code> in class <code>Test</code> hides the definition of <code>x</code> in class <code>Point</code>, 
so class <code>Test</code> does not inherit the field <code>x</code> from its superclass <code>Point</code>. It must be 
noted, however, that while the field <code>x</code> of class <code>Point</code> is not <i>inherited</i> by class 
<code>Test</code>, it is nevertheless <i>implemented</i> by instances of class <code>Test</code>. In other words, 
every instance of class <code>Test</code> contains two fields, one of type <code>int</code> and one of type 
<code>float</code>. Both fields bear the name <code>x</code>, but within the declaration of class <code>Test</code>, the 
simple name <code>x</code> always refers to the field declared within class <code>Test</code>. Code in 
instance methods of class <code>Test</code> may refer to the instance variable <code>x</code> of class <code>Point</code> 
as <code>super.x</code>.
<p><a name="40472"></a>
Code that uses a field access expression to access field <code>x</code> will access the field named <code>x</code> in the class indicated by the type of reference expression. Thus, the expression <code>sample.x</code> accesses a <code>float</code> value, the instance variable declared in class <code>Test</code>, because the type of the variable sample is <code>Test</code>, but the expression <code>((Point)sample).x</code> accesses an <code>int</code> value, the instance variable declared in class <code>Point</code>, because of the cast to type <code>Point</code>.<p>
<a name="40473"></a>
If the declaration of <code>x</code> is deleted from class <code>Test</code>, as in the program:<p>
<pre><a name="40474"></a>
class Point {
<a name="40475"></a>	static int x = 2;
<a name="40476"></a>}
<br><a name="40477"></a>
class Test extends Point {
<a name="40478"></a>	void printBoth() {
<a name="40479"></a>		System.out.println(x + " " + super.x);
<a name="40480"></a>	}
<a name="40481"></a>	public static void main(String[] args) {
<a name="40482"></a>		Test sample = new Test();
<a name="40483"></a>		sample.printBoth();
<a name="40484"></a>		System.out.println(sample.x + " " +<br>
												((Point)sample).x);
<a name="40485"></a>	}
<a name="40486"></a>}
</pre><a name="40487"></a>
then the field <code>x</code> of class <code>Point</code> is no longer hidden within class <code>Test</code>. Within 
instance methods in the declaration of class <code>Test</code>, the simple name <code>x</code> now refers to 
the field declared within class <code>Point</code>. Code in class <code>Test</code> may still refer to that 
same field as <code>super.x</code>. The expression <code>sample.x</code> still refers to the field <code>x</code> within 
type <code>Test</code>, but that field is now an inherited field, and so refers to the field <code>x</code> 
declared in class <code>Point</code>. The output from this variant program is:
<p><pre><a name="40488"></a>
2 2
<a name="40489"></a>2 2
</pre><a name="40491"></a>
<h4>8.3.3.3    Example: Multiply Inherited Fields</h4>
<a name="40492"></a>
A class may inherit two or more fields with the same name, either from two interfaces
or from its superclass and an interface. A compile-time error occurs on any 
attempt to refer to any ambiguously inherited field by its simple name. A qualified 
name or a field access expression that contains the keyword <code>super</code> <a href="15.doc.html#20860">(&#167;15.10.2)</a> may 
be used to access such fields unambiguously. In the example:
<p><pre><br><a name="40496"></a>interface Frob { float v = 2.0f; }
<br><br><a name="40497"></a>class SuperTest { int v = 3; }
<br></pre><pre><a name="40498"></a>
class Test extends SuperTest implements Frob {
<a name="40499"></a>	public static void main(String[] args) {
<a name="40500"></a>		new Test().printV();
<a name="40501"></a>	}
<a name="40502"></a>	void printV() { System.out.println(v); }
<a name="40503"></a>}
</pre><a name="40504"></a>
the class <code>Test</code> inherits two fields named <code>v</code>, one from its superclass <code>SuperTest</code> and 
one from its superinterface <code>Frob</code>. This in itself is permitted, but a compile-time 
error occurs because of the use of the simple name <code>v</code> in method <code>printV</code>: it cannot 
be determined which <code>v</code> is intended.
<p><a name="41191"></a>
The following variation uses the field access expression <code>super.v</code> to refer to the field named <code>v</code> declared in class <code>SuperTest</code> and uses the qualified name <code>Frob.v</code> to refer to the field named <code>v</code> declared in interface <code>Frob</code>:<p>
<pre><br><a name="40505"></a>interface Frob { float v = 2.0f; }
<br><br><a name="40506"></a>class SuperTest { int v = 3; }
<br></pre><pre><a name="40507"></a>
class Test extends SuperTest implements Frob {
<a name="40508"></a>	public static void main(String[] args) {
<a name="40509"></a>		new Test().printV();
<a name="40510"></a>	}
<a name="40511"></a>	void printV() {
<a name="40512"></a>		System.out.println((super.v + Frob.v)/2);
<a name="40513"></a>	}
<a name="40514"></a>}
</pre><a name="40515"></a>
It compiles and prints:
<p><pre><a name="40516"></a>2.5
</pre><a name="40518"></a>
Even if two distinct inherited fields have the same type, the same value, and are both <code>final</code>, any reference to either field by simple name is considered ambiguous and results in a compile-time error. In the example:<p>
<pre><br><a name="40519"></a>interface Color { int RED=0, GREEN=1, BLUE=2; }
<br><br><a name="40520"></a>interface TrafficLight { int RED=0, YELLOW=1, GREEN=2; }
<br></pre><pre><a name="40521"></a>
class Test implements Color, TrafficLight {
<a name="40522"></a>	public static void main(String[] args) {
<a name="40523"></a>		System.out.println(GREEN);										// compile-time error
<a name="40524"></a>		System.out.println(RED);										// compile-time error
<a name="40525"></a>	}
<a name="40526"></a>}
</pre><a name="40527"></a>
it is not astonishing that the reference to <code>GREEN</code> should be considered ambiguous, 
because class <code>Test</code> inherits two different declarations for <code>GREEN</code> with different 
values. The point of this example is that the reference to <code>RED</code> is also considered 
ambiguous, because two distinct declarations are inherited. The fact that the two 
fields named <code>RED</code> happen to have the same type and the same unchanging value 
does not affect this judgment.
<p><a name="40528"></a>
<h4>8.3.3.4    Example: Re-inheritance of Fields</h4>
<a name="40529"></a>
If the same field declaration is inherited from an interface by multiple paths, the 
field is considered to be inherited only once. It may be referred to by its simple 
name without ambiguity. For example, in the code:
<p><pre><a name="40530"></a>
public interface Colorable {
<a name="40531"></a>	int RED = 0xff0000, GREEN = 0x00ff00, BLUE = 0x0000ff;
<a name="40532"></a>}
<br><a name="40533"></a>
public interface Paintable extends Colorable {
<a name="40534"></a>	int MATTE = 0, GLOSSY = 1;
<a name="40535"></a>}
<br><br><a name="40536"></a>class Point { int x, y; }
<br><a name="40537"></a>
class ColoredPoint extends Point implements Colorable {
<a name="40538"></a>	. . .
<a name="40539"></a>}
<br><a name="40540"></a>
class PaintedPoint extends ColoredPoint implements Paintable 
{
<a name="40541"></a>	. . .  &#32; &#32; &#32;<code>RED</code> &#32; &#32; &#32; . . .
<a name="40542"></a>}
</pre><a name="40423"></a>
the fields <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> are inherited by the class <code>PaintedPoint</code> both 
through its direct superclass <code>ColoredPoint</code> and through its direct superinterface 
<code>Paintable</code>. The simple names <code>RED</code>, <code>GREEN</code>, and <code>BLUE</code> may nevertheless be used 
without ambiguity within the class <code>PaintedPoint</code> to refer to the fields declared in 
interface <code>Colorable</code>.
<p><a name="40420"></a>
<h2>8.4    Method Declarations</h2>
<a name="40422"></a>
A <i>method</i> declares executable code that can be invoked, passing a fixed number of 
values as arguments.
<p><ul><pre>
<i>MethodDeclaration:<br>
</i>	<i>MethodHeader</i><code> </code><i>MethodBody
</i>
<i>MethodHeader:<br>
	MethodModifiers</i><sub><i>opt</i></sub><code> </code><i>ResultType</i><code> </code><i>MethodDeclarator</i><code> </code><i>Throws</i><sub><i>opt
</i></sub>
<i>ResultType:<br>
	Type<br>
	</i><code>void
</code>
<i>MethodDeclarator:<br>
</i>	<i>Identifer</i><code> ( </code><i>FormalParameterList</i><sub><i>opt</i></sub><code> )
</code></pre></ul><a name="37508"></a>
The <i>MethodModifiers</i> are described in <a href="8.doc.html#78188">&#167;8.4.3</a>, the <i>Throws</i> clause in <a href="8.doc.html#78323">&#167;8.4.4</a>, and the 
<i>MethodBody</i> in <a href="8.doc.html#37316">&#167;8.4.5</a>. A method declaration either specifies the type of value that 
the method returns or uses the keyword <code>void</code> to indicate that the method does not 
return a value.
<p><a name="30386"></a>
The <i>Identifier</i> in a <i>MethodDeclarator</i> may be used in a name to refer to the method. A class can declare a method with the same name as the class or a field of the class.<p>
<a name="38703"></a>
For compatibility with older versions of Java, a declaration form for a method that returns an array is allowed to place (some or all of) the empty bracket pairs that form the declaration of the array type after the parameter list. This is supported by the obsolescent production:<p>
<ul><pre>
<i>MethodDeclarator:<br>
</i>	<i>MethodDeclarator</i><code> [ ]
</code></pre></ul><a name="38705"></a>
but should not be used in new Java code.
<p><a name="38056"></a>
It is a compile-time error for the body of a class to have as members two methods with the same signature <a href="8.doc.html#38649">(&#167;8.4.2)</a> (name, number of parameters, and types of any parameters). Methods and fields may have the same name, since they are used in different contexts and are disambiguated by the different lookup procedures <a href="6.doc.html#20569">(&#167;6.5)</a>.<p>
<a name="38698"></a>
<h3>8.4.1    Formal Parameters</h3>
<a name="37472"></a>
The <i>formal parameters</i> of a method, if any, are specified by a list of comma-separated
parameter specifiers. Each parameter specifier consists of a type and an identifier
(optionally followed by brackets) that specifies the name of the parameter:
<p><ul><pre>
<i>FormalParameterList:<br>
</i>	<i>FormalParameter<br>
</i>	<i>FormalParameterList</i><code> , </code><i>FormalParameter
</i>
<i>FormalParameter:<br>
</i>	<i>Type</i><code> </code><i>VariableDeclaratorId
</i></pre></ul><a name="14850"></a>
The following is repeated from <a href="8.doc.html#40898">&#167;8.3</a> to make the presentation here clearer:
<p><ul><pre>
<i>VariableDeclaratorId:<br>
</i>	<i>Identifier<br>
</i>	<i>VariableDeclaratorId</i><code> [ ]
</code></pre></ul><a name="55499"></a>
If a method has no parameters, only an empty pair of parentheses appears in the method's declaration.<p>
<a name="55500"></a>
If two formal parameters are declared to have the same name (that is, their declarations mention the same <i>Identifier</i>), then a compile-time error occurs.<p>
<a name="37477"></a>
When the method is invoked <a href="15.doc.html#20448">(&#167;15.11)</a>, the values of the actual argument expressions initialize newly created parameter variables, each of the declared <i>Type,</i> before execution of the body of the method. The <i>Identifier</i> that appears<i> </i>in the <i>DeclaratorId</i> may be used as a simple name in the body of the method to refer to the formal parameter.<p>
<a name="38643"></a>
The scope of formal parameter names is the entire body of the method. These parameter names may not be redeclared as local variables or exception parameters within the method; that is, hiding the name of a parameter is not permitted.<p>
<a name="38647"></a>
Formal parameters are referred to only using simple names, never by using qualified names <a href="6.doc.html#33916">(&#167;6.6)</a>.<p>
<a name="38649"></a>
<h3>8.4.2    Method Signature</h3>
<a name="37479"></a>
The <i>signature</i> of a method consists of the name of the method and the number and 
types of formal parameters to the method. A class may not declare two methods 
with the same signature, or a compile-time error occurs. The example:
<p><pre><a name="41347"></a>
class Point implements Move {
<a name="41348"></a>	int x, y;
<a name="41349"></a>	abstract void move(int dx, int dy);
<a name="41350"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<a name="41351"></a>}
</pre><a name="41352"></a>
causes a compile-time error because it declares two <code>move</code> methods with the same 
signature. This is an error even though one of the declarations is <code>abstract</code>.
<p><a name="78188"></a>
<h3>8.4.3    Method Modifiers</h3>
<ul><pre>
<i>MethodModifiers:<br>
	MethodModifier<br>
	MethodModifiers</i><code> </code><i>MethodModifier
</i>
<i>MethodModifier: one of<br>
	</i><code>public&#32;protected&#32;private<br>
	abstract&#32;static&#32;final&#32;synchronized&#32;native
</code></pre></ul><a name="35992"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="6.doc.html#33916">&#167;6.6</a>. 
A &#32;compile-time error occurs if the same modifier appears more than once in a 
method declaration, or if a method declaration has more than one of the access 
modifiers <code>public</code>, <code>protected</code>, and <code>private</code>. A compile-time error occurs if a 
method declaration that contains the keyword <code>abstract</code> also contains any one of 
the keywords <code>private</code>, <code>static</code>, <code>final</code>, <code>native</code>, or <code>synchronized</code>.
<p><a name="38745"></a>
If two or more method modifiers appear in a method declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for <i>MethodModifier</i>.<p>
<a name="34484"></a>
<h4>8.4.3.1    abstract Methods</h4>
<a name="38742"></a>
An <code>abstract</code> method declaration introduces the method as a member, providing 
its signature (name and number and type of parameters), return type, and <code>throws</code> 
clause (if any), but does not provide an implementation. The declaration of an 
<code>abstract</code> method <i>m</i> must appear within an <code>abstract</code> class (call it <i>A</i><i></i>); otherwise a 
compile-time error results. Every subclass of <i>A</i><i> </i>that is not <code>abstract</code> must provide 
an implementation for <i>m</i>, or a compile-time error occurs. More precisely, for every 
subclass <i>C</i> of the <code>abstract</code> class <i>A</i><i></i>, if <i>C</i><i></i> is not <code>abstract</code>, then there must be some 
class <i>B</i><i></i> such that all of the following are true:
<p><ul><a name="78209"></a>
<li><i>B</i> is a superclass of <i>C</i><i> </i>or is <i>C</i><i></i> itself.
<a name="78210"></a>
<li><i>B</i> is a subclass of <i>A</i><i></i>.
<a name="78212"></a>
<li><i>B</i> provides a declaration of the method <i>m</i> that is not <code>abstract</code>, and this declaration is inherited by <i>C</i>, thereby providing an implementation of method <i>m</i> that is visible to <i>C</i><i></i>.
</ul><a name="227750"></a>
If there is no such class <i>B</i>, then<i></i> a compile-time error occurs.
<p><a name="230064"></a>
It is a compile-time error for a <code>private</code> method to be declared <code>abstract</code>. It would be impossible for a subclass to implement a <code>private</code> <code>abstract</code> method, because <code>private</code> methods are not visible to subclasses; therefore such a method could never be used.<p>
<a name="230065"></a>
It is a compile-time error for a <code>static</code> method to be declared <code>abstract</code>.<p>
<a name="230073"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="36710"></a>
An <code>abstract</code> class can override an <code>abstract</code> method by providing another <code>abstract</code> method declaration. This can provide a place to put a documentation comment <a href="18.doc.html#25978">(&#167;18)</a>, or to declare that the set of checked exceptions <a href="11.doc.html#44121">(&#167;11.2)</a> that can be thrown by that method, when it is implemented by its subclasses, is to be more limited. For example, consider this code:<p>
<pre><a name="36711"></a>
class BufferEmpty extends Exception {
<a name="29450"></a>	BufferEmpty() { super(); }
<a name="29451"></a>	BufferEmpty(String s) { super(s); }
<a name="29452"></a>}
<br><a name="25657"></a>
class BufferError extends Exception {
<a name="29453"></a>	BufferError() { super(); }
<a name="29454"></a>	BufferError(String s) { super(s); }
<a name="29455"></a>}
<br><a name="25660"></a>
public interface Buffer {
<a name="36714"></a>	char get() throws BufferEmpty, BufferError;
<a name="36715"></a>}
<br><a name="36716"></a>
public abstract class InfiniteBuffer implements Buffer {
<a name="36717"></a>	abstract char get() throws BufferError;
<a name="36718"></a>}
</pre><a name="11245"></a>
The overriding declaration of method <code>get</code> in class <code>InfiniteBuffer</code> states that 
method <code>get</code> in any subclass of <code>InfiniteBuffer</code> never throws a <code>BufferEmpty</code> 
exception, putatively because it generates the data in the buffer, and thus can never 
run out of data.
<p><a name="14765"></a>
An instance method that is not <code>abstract</code> can be overridden by an <code>abstract</code> method. For example, we can declare an <code>abstract</code> class <code>Point</code> that requires its subclasses to implement <code>toString</code> if they are to be complete, instantiable classes:<p>
<pre><a name="14908"></a>
abstract class Point {
<a name="14909"></a>	int x, y;
<a name="14910"></a>	public abstract String toString();
<a name="14911"></a>}
</pre><a name="14912"></a>
This <code>abstract</code> declaration of <code>toString</code> overrides the non-<code>abstract</code> <code>toString</code> 
method of class <code>Object</code> <a href="javalang.doc1.html#1152">(&#167;20.1.2)</a>. (Class <code>Object</code> is the implicit direct superclass 
of class <code>Point</code>.) Adding the code:
<p><pre><a name="38907"></a>
class ColoredPoint extends Point {
<a name="38908"></a>	int color;
<a name="38909"></a>	public String toString() {
<a name="38919"></a>		return super.toString() + ": color " + color; // error
<a name="38920"></a>	}
<a name="38910"></a>}
</pre><a name="38923"></a>
results in a compile-time error because the invocation <code>super.toString()</code> refers 
to method <code>toString</code> in class <code>Point</code>, which is <code>abstract</code> and therefore cannot be 
invoked. Method <code>toString</code> of class <code>Object</code> can be made available to class 
<code>ColoredPoint</code> &#32;only if class <code>Point</code> explicitly makes it available through some 
other method, as in:
<p><pre><a name="38928"></a>
abstract class Point {
<a name="38929"></a>	int x, y;
<a name="38930"></a>	public abstract String toString();
<a name="38945"></a>	protected String objString() { return super.toString(); }
<a name="38931"></a>}
<a name="38933"></a>
class ColoredPoint extends Point {
<a name="38934"></a>	int color;
<a name="38935"></a>	public String toString() {
<a name="38936"></a>		return objString() + ": color " + color;														// correct
<a name="229125"></a>	}
<a name="229126"></a>}
</pre><a name="229128"></a>
<h4>8.4.3.2    static Methods</h4>
<a name="39431"></a>
A method that is declared <code>static</code> is called a <i>class method</i>. A class method is 
always invoked without reference to a particular object. An attempt to reference 
the current object using the keyword <code>this</code> or the keyword <code>super</code> in the body of a 
class method results in a compile time error. It is a compile-time error for a 
<code>static</code> method to be declared <code>abstract</code>.
<p><a name="39033"></a>
A method that is not declared <code>static</code> is called an <i>instance method,</i> and sometimes called a non-<code>static</code> method). An instance method is always invoked with respect to an object, which becomes the current object to which the keywords <code>this</code> and <code>super</code> refer during execution of the method body.<p>
<a name="11246"></a>
<h4>8.4.3.3    final Methods</h4>
<a name="30456"></a>
A method can be declared <code>final</code> to prevent subclasses from overriding or hiding 
it. It is a compile-time error to attempt to override or hide a <code>final</code> method.
<p><a name="38958"></a>
A <code>private</code> method and all methods declared in a <code>final</code> class <a href="8.doc.html#54727">(&#167;8.1.2.2)</a> are implicitly <code>final</code>, because it is impossible to override them. It is permitted but not required for the declarations of such methods to redundantly include the <code>final</code> keyword. <p>
<a name="38950"></a>
It is a compile-time error for a <code>final</code> method to be declared <code>abstract</code>.<p>
<a name="14844"></a>
At run-time, a machine-code generator or optimizer can easily and safely "inline" the body of a <code>final</code> method, replacing an invocation of the method with the code in its body, as in the example:<p>
<pre><a name="36655"></a>
final class Point {
<a name="36656"></a>	int x, y;
<a name="36657"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<a name="36658"></a>}
<br><a name="36659"></a>
class Test {
<a name="36660"></a>	public static void main(String[] args) {
<a name="36661"></a>		Point[] p = new Point[100];
<a name="36662"></a>		for (int i = 0; i &lt; p.length; i++) {
<a name="25669"></a>			p[i] = new Point();
<a name="36663"></a>			p[i].move(i, p.length-1-i);
<a name="25670"></a>		}
<a name="36664"></a>	}
<a name="36665"></a>}
</pre><a name="36666"></a>
Here, inlining the method <code>move</code> of class <code>Point</code> in method <code>main</code> would transform 
the <code>for</code> loop to the form:
<p><pre><a name="36667"></a>
		for (int i = 0; i &lt; p.length; i++) {
<a name="25671"></a>			p[i] = new Point();
<a name="36668"></a>			Point pi = p[i];
<a name="36669"></a>			pi.x += i;
<a name="36670"></a>			pi.y += p.length-1-i;
<a name="36671"></a>		}
</pre><a name="31122"></a>
The loop might then be subject to further optimizations.
<p><a name="31123"></a>
Such inlining cannot be done at compile time unless it can be guaranteed that <code>Test</code> and <code>Point</code> will always be recompiled together, so that whenever <code>Point</code>-and specifically its <code>move</code> method-changes, the code for <code>Test.main</code> will also be updated.<p>
<a name="31125"></a>
<h4>8.4.3.4    native Methods</h4>
<a name="30468"></a>
A method that is <code>native</code> is implemented in platform-dependent code, typically 
written in another programming language such as C, C++, FORTRAN, or assembly 
language. The body of a <code>native</code> method is given as a semicolon only, indicating 
that the implementation is omitted, instead of a block.
<p><a name="38981"></a>
A compile-time error occurs if a <code>native</code> method is declared <code>abstract</code>.<p>
<a name="38035"></a>
For example, the class <code>RandomAccessFile</code> of the standard package <code>java.io</code> might declare the following <code>native</code> methods:<p>
<pre><br><a name="14929"></a>package java.io;
<br></pre><pre><a name="229136"></a>
public class RandomAccessFile<br>
	implements DataOutput, DataInput
<a name="14948"></a>{	. . .
<a name="14949"></a>	public native void open(String name, boolean writeable)
<a name="14930"></a>		throws IOException;
<a name="14931"></a>	public native int readBytes(byte[] b, int off, int len)
<a name="14932"></a>		throws IOException;
<a name="14933"></a>	public native void writeBytes(byte[] b, int off, int len)
<a name="14934"></a>		throws IOException;
<a name="14935"></a>	public native long getFilePointer() throws IOException;
<a name="14944"></a>	public native void seek(long pos) throws IOException;
<a name="14940"></a>	public native long length() throws IOException;
<a name="27670"></a>	public native void close() throws IOException;
<a name="14950"></a>}
</pre><a name="55408"></a>
<h4>8.4.3.5    synchronized Methods</h4>
<a name="30531"></a>
A <code>synchronized</code> method acquires a lock <a href="17.doc.html#28287">(&#167;17.1)</a> before it executes. For a class 
(<code>static)</code> method, the lock associated with the <code>Class</code> object <a href="javalang.doc2.html#14342">(&#167;20.3)</a> for the 
method's class is used. For an instance method, the lock associated with <code>this</code> (the 
object for which the method was invoked) is used. These are the same locks that 
can be used by the <code>synchronized</code> statement <a href="14.doc.html#79287">(&#167;14.17)</a>; thus, the code:
<p><pre><a name="39079"></a>
class Test {
<a name="39082"></a>	int count;
<a name="39085"></a>	synchronized void bump() { count++; }
<a name="39095"></a>	static int classCount;
<a name="39087"></a>	static synchronized void classBump() {
<a name="39107"></a>		classCount++;
<a name="39108"></a>	}
<a name="39080"></a>}
</pre><a name="39096"></a>
has exactly the same effect as:
<p><pre><a name="39099"></a>
class BumpTest {
<a name="39100"></a>	int count;
<a name="39101"></a>	void bump() {
<a name="227909"></a>		synchronized (this) {
<a name="227908"></a>			count++;
<a name="227910"></a>		}
<a name="227911"></a>	}
<a name="39102"></a>	static int classCount;
<a name="39103"></a>	static void classBump() {
<a name="229768"></a>		try {
<a name="39119"></a>			synchronized (Class.forName("BumpTest")) {
<a name="39114"></a>				classCount++;
<a name="229774"></a>			}
<a name="229769"></a>		} catch (ClassNotFoundException e) {
<a name="229770"></a>				...
<a name="229771"></a>		}
<a name="39115"></a>	}
<a name="39104"></a>}
</pre><a name="39078"></a>
The more elaborate example:
<p><pre><a name="30532"></a>
public class Box {
<br><a name="30533"></a>	private Object boxContents;
<br><a name="30534"></a>
	public synchronized Object get() {
<a name="30535"></a>		Object contents = boxContents;
<a name="30536"></a>		boxContents = null;
<a name="30537"></a>		return contents;
<a name="30538"></a>	}
<br><a name="30539"></a>
	public synchronized boolean put(Object contents) {
<a name="30540"></a>		if (boxContents != null)
<a name="30541"></a>			return false;
<a name="30542"></a>		boxContents = contents;
<a name="30543"></a>		return true;
<a name="30544"></a>	}
<br><a name="30545"></a>}
</pre><a name="30546"></a>
defines a class which is designed for concurrent use. Each instance of the class 
<code>Box</code> has an instance variable <code>contents</code> that can hold a reference to any object. 
You can put an object in a <code>Box</code> by invoking <code>put</code>, which returns <code>false</code> if the box is 
already full. You can get something out of a <code>Box</code> by invoking <code>get</code>, which returns a 
null reference if the <code>box</code> is empty.
<p><a name="39151"></a>
If <code>put</code> and <code>get</code> were not <code>synchronized</code>, and two threads were executing methods for the same instance of <code>Box</code> at the same time, then the code could misbehave. It might, for example, lose track of an object because two invocations to <code>put</code> occurred at the same time.<p>
<a name="39159"></a>
See <a href="17.doc.html#26250">&#167;17</a> for more discussion of threads and locks.<p>
<a name="78323"></a>
<h3>8.4.4    Method Throws</h3>
<a name="41401"></a>
A <i>throws clause</i> is used to declare any checked exceptions <a href="11.doc.html#44121">(&#167;11.2)</a> that can result 
from the execution of a method or constructor:
<p><ul><pre>
<i>Throws:<br>
</i><code>	throws </code><i>ClassTypeList
</i>
<i>ClassTypeList:<br>
</i>	<i>ClassType<br>
</i>	<i>ClassTypeList</i><code> , </code><i>ClassType
</i></pre></ul><a name="39173"></a>
A compile-time error occurs if any <i>ClassType</i> mentioned in a <code>throws</code> clause is not 
the class <code>Throwable</code> <a href="javalang.doc20.html#46198">(&#167;20.22)</a> or a subclass of <code>Throwable</code>. It is permitted but not 
required to mention other (unchecked) exceptions in a <code>throws</code> clause.
<p><a name="39177"></a>
For each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless that exception type or a superclass of that exception type is mentioned in a <code>throws</code> clause in the declaration of the method or constructor.<p>
<a name="24551"></a>
The requirement to declare checked exceptions allows the compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions will normally result in a compile-time error because of the lack of a proper exception type in a <code>throws</code> clause. Java thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.<p>
<a name="55271"></a>
The predefined exceptions that are not checked in this way are those for which declaring every possible occurrence would be unimaginably inconvenient:<p>
<ul><a name="41434"></a>
<li>Exceptions that are represented by the subclasses of class <code>Error</code>, for example <code>OutOfMemoryError</code>, are thrown due to a failure in or of the virtual machine. Many of these are the result of linkage failures and can occur at unpredictable points in the execution of a Java program. Sophisticated programs may yet wish to catch and attempt to recover from some of these conditions.
<a name="41435"></a>
<li>The exceptions that are represented by the subclasses of the class <code>RuntimeException</code>, &#32;for example <code>NullPointerException</code>, result from runtime &#32;integrity checks and are thrown either directly from the Java program or in library routines. It is beyond the scope of the Java language, and perhaps beyond the state of the art, to include sufficient information in the program to reduce to a manageable number the places where these can be proven not to occur.
</ul><a name="230101"></a>
A method that overrides or hides another method <a href="8.doc.html#228745">(&#167;8.4.6)</a>, including methods that implement <code>abstract</code> methods defined in interfaces, may not be declared to throw more checked exceptions than the overridden or hidden method.<p>
<a name="230102"></a>
More precisely, suppose that <i>B</i><i></i> is a class or interface, and <i>A</i><i></i> is a superclass or superinterface of <i>B</i>, and a method declaration <i>n</i> in <i>B</i> overrides or hides a method declaration <i>m</i> in <i>A</i><i></i>. If <i>n</i><i></i> has a <code>throws</code> clause that mentions any checked exception types, then <i>m</i> must have a <code>throws</code> clause, and for every checked exception type listed in the <code>throws</code> clause of <i>n</i>, that same exception class or one of its superclasses must occur in the <code>throws</code> clause of <i>m</i>; otherwise, a compile-time error occurs.<p>
<a name="24563"></a>
See <a href="11.doc.html#44043">&#167;11</a> for more information about exceptions and a large example.<p>
<a name="37316"></a>
<h3>8.4.5    Method Body</h3>
<a name="32175"></a>
A <i>method body</i> is either a block of code that implements the method or simply a 
semicolon, indicating the lack of an implementation. The body of a method must 
be a semicolon if and only if the method is either <code>abstract</code> <a href="8.doc.html#34484">(&#167;8.4.3.1)</a> or <code>native</code> 
<a href="8.doc.html#31125">(&#167;8.4.3.4)</a>.
<p><ul><pre>
<i>MethodBody:<br>
	Block</i> <br>
	<code>;
</code></pre></ul><a name="38770"></a>
A compile-time error occurs if a method declaration is either <code>abstract</code> or 
<code>native</code> and has a block for its body. A compile-time error occurs if a method declaration
is neither <code>abstract</code> nor <code>native</code> and has a semicolon for its body.
<p><a name="39311"></a>
If an implementation is to be provided for a method but the implementation requires no executable code, the method body should be written as a block that contains no statements: "<code>{ }</code>".<p>
<a name="228178"></a>
If a method is declared <code>void</code>, then its body must not contain any <code>return</code> statement <a href="14.doc.html#6767">(&#167;14.15)</a> that has an <i>Expression</i>.<p>
<a name="244552"></a>
If a method is declared to have a return type, then every <code>return</code> statement <a href="14.doc.html#6767">(&#167;14.15)</a> in its body must have an <i>Expression</i>. A compile-time error occurs if the body of the method can complete normally <a href="14.doc.html#5894">(&#167;14.1)</a>. In other words, a method with a return type must return only by using a return statement that provides a value return; it is not allowed to "drop off the end of its body."<p>
<a name="228370"></a>
Note that it is possible for a method to have a declared return type and yet contain no return statements. Here is one example:<p>
<pre><a name="228742"></a>class DizzyDean {<br>
	int pitch() { throw new RuntimeException("90 mph?!"); }<br>
}
</pre><a name="228745"></a>
<h3>8.4.6    Inheritance, Overriding, and Hiding</h3>
<a name="227926"></a>
A class <i>inherits</i> from its direct superclass and direct superinterfaces all the methods
(whether <code>abstract</code> or not) of the superclass and superinterfaces that are 
accessible to code in the class and are neither overridden <a href="8.doc.html#227927">(&#167;8.4.6.1)</a> nor hidden 
<a href="8.doc.html#227928">(&#167;8.4.6.2)</a> by a declaration in the class.
<p><a name="227927"></a>
<h4>8.4.6.1    Overriding (By Instance Methods)</h4>
<a name="39521"></a>
If a class declares an instance method, then the declaration of that method is said 
to <i>override</i> any and all methods with the same signature in the superclasses and 
superinterfaces of the class that would otherwise be accessible to code in the class. 
Moreover, if the method declared in the class is not <code>abstract</code>, then the declaration
of that method is said to <i>implement</i> any and all declarations of <code>abstract</code> 
methods with the same signature in the superclasses and superinterfaces of the 
class that would otherwise be accessible to code in the class.
<p><a name="227929"></a>
A compile-time error occurs if an instance method overrides a <code>static</code> method. In this respect, overriding of methods differs from hiding of fields <a href="8.doc.html#40898">(&#167;8.3)</a>, for it is permissible for an instance variable to hide a <code>static</code> variable.<p>
<a name="227988"></a>
An overridden method can be accessed by using a method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a> that contains the keyword <code>super</code>. Note that a qualified name or a cast to a superclass type is not effective in attempting to access an overridden method; in this respect, overriding of methods differs from hiding of fields. See <a href="15.doc.html#239751">&#167;15.11.4.10</a> for discussion and examples of this point.<p>
<a name="227928"></a>
<h4>8.4.6.2    Hiding (By Class Methods)</h4>
<a name="227961"></a>
If a class declares a <code>static</code> method, then the declaration of that method is said to 
<i>hide</i> any and all methods with the same signature in the superclasses and superinterfaces
of the class that would otherwise be accessible to code in the class. A 
compile-time error occurs if a <code>static</code> method hides an instance method. In this 
respect, hiding of methods differs from hiding of fields <a href="8.doc.html#40898">(&#167;8.3)</a>, for it is permissible 
for a <code>static</code> variable to hide an instance variable.
<p><a name="227976"></a>
A hidden method can be accessed by using a qualified name or by using a method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a> that contains the keyword <code>super</code> or a cast to a superclass type. In this respect, hiding of methods is similar to hiding of fields.<p>
<a name="227965"></a>
<h4>8.4.6.3    Requirements in Overriding and Hiding</h4>
<a name="227966"></a>
If a method declaration overrides or hides the declaration of another method, then 
a compile-time error occurs if they have different return types or if one has a 
return type and the other is <code>void</code>. Moreover, a method declaration must not have a 
<code>throws</code> clause that conflicts <a href="8.doc.html#78323">(&#167;8.4.4)</a> with that of any method that it overrides or 
hides; otherwise, &#32;a compile-time error occurs. In these respects, overriding of 
methods differs from hiding of fields <a href="8.doc.html#40898">(&#167;8.3)</a>, for it is permissible for a field to hide 
a field of another type.
<p><a name="39548"></a>
The access modifier <a href="6.doc.html#33916">(&#167;6.6)</a> of an overriding or hiding method must provide at least as much access as the overridden or hidden method, or a compile-time error occurs. In more detail:<p>
<ul><a name="39549"></a>
<li>If the overridden or hidden method is <code>public</code>, then the overriding or hiding method must be <code>public</code>; otherwise, a compile-time error occurs.
<a name="39550"></a>
<li>If the overridden or hidden method is <code>protected</code>, then the overriding or hiding method must be <code>protected</code> or <code>public</code>; otherwise, a compile-time error occurs.
<a name="39551"></a>
<li>If the overridden or hidden method has default (package) access, then the overriding or hiding method must not be <code>private</code>; otherwise, a compile-time error occurs.
</ul><a name="39552"></a>
Note that a <code>private</code> method is never accessible to subclasses and so cannot be 
hidden or overridden in the technical sense of those terms. This means that a subclass
can declare a method with the same signature as a <code>private</code> method in one of 
its superclasses, and there is no requirement that the return type or <code>throws</code> clause 
of such a method bear any relationship to those of the <code>private</code> method in the 
superclass.
<p><a name="227941"></a>
<h4>8.4.6.4    Inheriting Methods with the Same Signature</h4>
<a name="39557"></a>
It is possible for a class to inherit more than one method with the same signature 
<a href="8.doc.html#227941">(&#167;8.4.6.4)</a>. Such a situation does not in itself cause a compile-time error. There are 
then two possible cases:
<p><ul><a name="39561"></a>
<li>If one of the inherited methods is not <code>abstract</code>, then there are two subcases:
<ul>
<a name="39562"></a>
<li>If the method that is not <code>abstract</code> is <code>static</code>, a compile-time error occurs.
<a name="39563"></a>
<li>Otherwise, the method that is not <code>abstract</code> is considered to override, and therefore to implement, all the other methods on behalf of the class that inherits it. A compile-time error occurs if, comparing the method that is not <code>abstract</code> with each of the other of the inherited methods, for any such pair, either they have different return types or one has a return type and the other is <code>void</code>. Moreover, a compile-time error occurs if the inherited method that is not <code>abstract</code> has a <code>throws</code> clause that conflicts <a href="8.doc.html#78323">(&#167;8.4.4)</a> with that of any other of the inherited methods.
</ul>
<a name="39567"></a>
<li>If none of the inherited methods is not <code>abstract</code>, then the class is necessarily an <code>abstract</code> class and is considered to inherit all the <code>abstract</code> methods. A compile-time error occurs if, for any two such inherited methods, either they have different return types or one has a return type and the other is <code>void</code>. (The <code>throws</code> clauses do not cause errors in this case.)
</ul><a name="39568"></a>
It is not possible for two or more inherited methods with the same signature not to 
be <code>abstract</code>, because methods that are not <code>abstract</code> are inherited only from the 
direct superclass, not from superinterfaces.
<p><a name="39569"></a>
There might be several paths by which the same method declaration might be inherited from an interface. This fact causes no difficulty and never, of itself, results in a compile-time error.<p>
<a name="227768"></a>
<h3>8.4.7    Overloading</h3>
<a name="39587"></a>
If two methods of a class (whether both declared in the same class, or both inherited
by a class, or one declared and one inherited) have the same name but different
signatures, then the method name is said to be <i>overloaded</i>. This fact causes no 
difficulty and never of itself results in a compile-time error. There is no required 
relationship between the return types or between the <code>throws</code> clauses of two methods
with the same name but different signatures.
<p><a name="39909"></a>
Methods are overridden on a signature-by-signature basis. If, for example, a class declares two <code>public</code> methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, Java differs from C++.<p>
<a name="39591"></a>
When a method is invoked <a href="15.doc.html#20448">(&#167;15.11)</a>, the number of actual arguments and the compile-time types of the arguments are used, at compile time, to determine the signature of the method that will be invoked <a href="15.doc.html#21693">(&#167;15.11.2)</a>. If the method that is to be invoked is an instance method, the actual method to be invoked will be determined at run time, using dynamic method lookup <a href="15.doc.html#45677">(&#167;15.11.4)</a>.<p>
<a name="39598"></a>
<h3>8.4.8    Examples of Method Declarations</h3>
<a name="39599"></a>
The following examples illustrate some (possibly subtle) points about method 
declarations.
<p><a name="39600"></a>
<h4>8.4.8.1    Example: Overriding</h4>
<a name="39601"></a>
In the example:
<p><pre><a name="39602"></a>
class Point {
<br><a name="39603"></a>	int x = 0, y = 0;
<br><br><a name="39604"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><a name="39605"></a>}
<br><a name="39606"></a>
class SlowPoint extends Point {
<br><a name="39607"></a>	int xLimit, yLimit;
<br><a name="39608"></a>
	void move(int dx, int dy) {
<a name="39609"></a>		super.move(limit(dx, xLimit), limit(dy, yLimit));
<a name="39610"></a>	}
<br><a name="39611"></a>
	static int limit(int d, int limit) {
<a name="39612"></a>		return d &gt; limit ? limit : d &lt; -limit ? -limit : d;
<a name="39613"></a>	}
<br><a name="39614"></a>}
</pre><a name="39615"></a>
the class <code>SlowPoint</code> overrides the declarations of method <code>move</code> of class <code>Point</code> 
with its own <code>move</code> method, which limits the distance that the point can move on 
each invocation of the method. When the <code>move</code> method is invoked for an instance 
of class <code>SlowPoint</code>, the overriding definition in class <code>SlowPoint</code> will always be 
called, even if the reference to the <code>SlowPoint</code> object is taken from a variable 
whose type is <code>Point</code>.
<p><a name="39617"></a>
<h4>8.4.8.2    Example: Overloading, Overriding, and Hiding</h4>
<a name="39618"></a>
In the example:
<p><pre><a name="39619"></a>
class Point {
<br><a name="39620"></a>	int x = 0, y = 0;
<br><br><a name="39621"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><br><a name="39622"></a>	int color;
<br><a name="39623"></a>}
<br><a name="39624"></a>
class RealPoint extends Point {
<br><a name="39625"></a>	float x = 0.0f, y = 0.0f;
<br><br><a name="39626"></a>	void move(int dx, int dy) { move((float)dx, (float)dy); }
<br><br><a name="39627"></a>	void move(float dx, float dy) { x += dx; y += dy; }
<br><a name="39628"></a>}
</pre><a name="39629"></a>
the class <code>RealPoint</code> hides the declarations of the <code>int</code> instance variables <code>x</code> and <code>y</code> 
of class <code>Point</code> with its own <code>float</code> instance variables <code>x</code> and <code>y</code>, and overrides the 
method <code>move</code> of class <code>Point</code> with its own <code>move</code> method. It also overloads the name 
<code>move</code> with another method with a different signature <a href="8.doc.html#38649">(&#167;8.4.2)</a>.
<p><a name="39633"></a>
In this example, the members of the class <code>RealPoint</code> include the instance variable <code>color</code> inherited from the class <code>Point</code>, the <code>float</code> instance variables <code>x</code> and <code>y</code> declared in <code>RealPoint</code>, and the two <code>move</code> methods declared in <code>RealPoint</code>.<p>
<a name="39634"></a>
Which of these overloaded <code>move</code> methods of class <code>RealPoint</code> will be chosen for any particular method invocation will be determined at compile time by the overloading resolution procedure described in <a href="15.doc.html#20448">&#167;15.11</a>.<p>
<a name="39638"></a>
<h4>8.4.8.3    Example: Incorrect Overriding</h4>
<a name="39639"></a>
This example is an extended variation of that in the preceding section:
<p><pre><a name="39640"></a>
class Point {
<br><a name="39641"></a>	int x = 0, y = 0, color;
<br><br><a name="39642"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><br><a name="39643"></a>	int getX() { return x; }
<br><br><a name="39644"></a>	int getY() { return y; }
<br><a name="39646"></a>}
<br><a name="39647"></a>
class RealPoint extends Point {
<br><a name="39648"></a>	float x = 0.0f, y = 0.0f;
<br><br><a name="39649"></a>	void move(int dx, int dy) { move((float)dx, (float)dy); }
<br><br><a name="39650"></a>	void move(float dx, float dy) { x += dx; y += dy; }
<br><br><a name="39651"></a>	float getX() { return x; }
<br><br><a name="39652"></a>	float getY() { return y; }
<br><a name="39653"></a>}
</pre><a name="39654"></a>
Here the class <code>Point</code> provides methods <code>getX</code> and <code>getY</code> that return the values of its 
fields <code>x</code> and <code>y</code>; the class <code>RealPoint</code> then overrides these methods by declaring 
methods with the same signature. The result is two errors at compile time, one for 
each method, because the return types do not match; the methods in class <code>Point</code> 
return values of type <code>int</code>, but the wanna-be overriding methods in class 
<code>RealPoint</code> return values of type <code>float</code>.
<p><a name="39655"></a>
<h4>8.4.8.4    Example: Overriding versus Hiding</h4>
<a name="39656"></a>
This example corrects the errors of the example in the preceding section:
<p><pre><a name="39657"></a>
class Point {
<br><a name="39658"></a>	int x = 0, y = 0;
<br><br><a name="39659"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<br><br><a name="39660"></a>	int getX() { return x; }
<br><br><a name="39661"></a>	int getY() { return y; }
<br><br><a name="39662"></a>	int color;
<br><a name="39663"></a>}
<br><a name="39664"></a>
class RealPoint extends Point {
<br><a name="39665"></a>	float x = 0.0f, y = 0.0f;
<br><br><a name="39666"></a>	void move(int dx, int dy) { move((float)dx, (float)dy); }
<br><br><a name="39667"></a>	void move(float dx, float dy) { x += dx; y += dy; }
<br><br><a name="39668"></a>	int getX() { return (int)Math.floor(x); }
<br><br><a name="39669"></a>	int getY() { return (int)Math.floor(y); }
<br><a name="39670"></a>}
</pre><a name="39671"></a>
Here the overriding methods <code>getX</code> and <code>getY</code> in class <code>RealPoint</code> have the same 
return types as the methods of class <code>Point</code> that they override, so this code can be 
successfully compiled.
<p><a name="39672"></a>
Consider, then, this test program:<p>
<pre><a name="39673"></a>
class Test {
<a name="39674"></a>
	public static void main(String[] args) {
<a name="39675"></a>		RealPoint rp = new RealPoint();
<a name="39676"></a>		Point p = rp;
<a name="39677"></a>		rp.move(1.71828f, 4.14159f);
<a name="39678"></a>		p.move(1, -1);
<a name="39679"></a>		show(p.x, p.y);
<a name="39680"></a>		show(rp.x, rp.y);
<a name="39681"></a>		show(p.getX(), p.getY());
<a name="39682"></a>		show(rp.getX(), rp.getY());
<a name="39683"></a>	}
<br><a name="39684"></a>
	static void show(int x, int y) {
<a name="39685"></a>		System.out.println("(" + x + ", " + y + ")");
<a name="39686"></a>	}
<br><a name="39687"></a>
	static void show(float x, float y) {
<a name="39688"></a>		System.out.println("(" + x + ", " + y + ")");
<a name="39689"></a>	}
<br><a name="39690"></a>}
</pre><a name="39691"></a>
The output from this program is:
<p><pre><a name="39692"></a>
(0, 0)
<a name="39693"></a>(2.7182798, 3.14159)
<a name="39694"></a>(2, 3)
<a name="39695"></a>(2, 3)
</pre><a name="39696"></a>
The first line of output illustrates the fact that an instance of <code>RealPoint</code> actually contains the two integer fields declared in class <code>Point</code>; it is just that their names are hidden from code that occurs within the declaration of class <code>RealPoint</code> (and those of any subclasses it might have). When a reference to an instance of class <code>RealPoint</code> in a variable of type <code>Point</code> is used to access the field <code>x</code>, the integer field <code>x</code> declared in class <code>Point</code> is accessed. The fact that its value is zero indicates that the method invocation <code>p.move(1,</code> <code>-1)</code> did not invoke the method <code>move</code> of class <code>Point</code>; instead, it invoked the overriding method <code>move</code> of class <code>RealPoint</code>.<p>
<a name="39697"></a>
The second line of output shows that the field access <code>rp.x</code> refers to the field <code>x</code> declared in class <code>RealPoint</code>. This field is of type <code>float</code>, and this second line of output accordingly displays floating-point values. Incidentally, this also illustrates the fact that the method name <code>show</code> is overloaded; the types of the arguments in the method invocation dictate which of the two definitions will be invoked.<p>
<a name="230120"></a>
The last two lines of output show that the method invocations <code>p.getX()</code> and <code>rp.getX()</code> each invoke the <code>getX</code> method declared in class <code>RealPoint</code>. Indeed, there is no way to invoke the <code>getX</code> method of class <code>Point</code> for an instance of class <code>RealPoint</code> from outside the body of <code>RealPoint</code>, no matter what the type of the variable we may use to hold the reference to the object. Thus, we see that fields and methods behave differently: hiding is different from overriding.<p>
<a name="229207"></a>
<h4>8.4.8.5    Example: Invocation of Hidden Class Methods</h4>
<a name="229208"></a>
A hidden class (<code>static</code>) method can be invoked by using a reference whose type 
is the class that actually contains the declaration of the method. In this respect, 
hiding of static methods is different from overriding of instance methods. The 
example:
<p><a name="229226"></a>
<p>
<a name="229227"></a>
<p>
<a name="229228"></a>
<p>
<pre><a name="229209"></a>
class Super {
<a name="229210"></a>	static String greeting() { return "Goodnight"; }
<a name="229211"></a>	String name() { return "Richard"; }
<a name="229212"></a>}
<br><a name="229213"></a>
class Sub extends Super {
<a name="229214"></a>	static String greeting() { return "Hello"; }
<a name="229215"></a>	String name() { return "Dick"; }
<a name="229216"></a>}
<br><a name="229217"></a>
class Test {
<a name="229218"></a>	public static void main(String[] args) {
<a name="229219"></a>		Super s = new Sub();
<a name="229220"></a>		System.out.println(s.greeting() + ", " + s.name());
<a name="229221"></a>	}
<a name="229222"></a>}
</pre><a name="229223"></a>
produces the output:
<p><pre><a name="229224"></a>Goodnight, Dick
</pre><a name="229225"></a>
because the invocation of <code>greeting</code> uses the type of <code>s</code>, namely <code>Super</code>, to figure 
out, at compile time, which class method to invoke, whereas the invocation of 
<code>name</code> uses the class of <code>s</code>, namely <code>Sub</code>, to figure out, at run time, which instance 
method to invoke.
<p><a name="229149"></a>
<h4>8.4.8.6    Large Example of Overriding</h4>
<a name="229150"></a>
Overriding makes it easy for subclasses to extend the behavior of an existing 
class, as shown in this example:
<p><pre><br><a name="229151"></a>import java.io.OutputStream;
<br><br><a name="229152"></a>import java.io.IOException;
<br></pre><pre><a name="229153"></a>
class BufferOutput {
<br><a name="229154"></a>	private OutputStream o;
<br><br><a name="229155"></a>	BufferOutput(OutputStream o) { this.o = o; }
<br><br><a name="229156"></a>	protected byte[] buf = new byte[512];
<br><br><a name="229157"></a>	protected int pos = 0;
<br><a name="229158"></a>
	public void putchar(char c) throws IOException {
<a name="229159"></a>		if (pos == buf.length)
<a name="229160"></a>			flush();
<a name="229161"></a>		buf[pos++] = (byte)c;
<a name="229162"></a>	}
<br></pre><pre><a name="229163"></a>
	public void putstr(String s) throws IOException {
<a name="229164"></a>		for (int i = 0; i &lt; s.length(); i++)
<a name="229165"></a>			putchar(s.charAt(i));
<a name="229166"></a>	}
<br><a name="229167"></a>
	public void flush() throws IOException {
<a name="229168"></a>		o.write(buf, 0, pos);
<a name="229169"></a>		pos = 0;
<a name="229170"></a>	}
<br><a name="229171"></a>}
<br><a name="229172"></a>
class LineBufferOutput extends BufferOutput {
<br><a name="229173"></a>	LineBufferOutput(OutputStream o) { super(o); }
<br><a name="229174"></a>
	public void putchar(char c) throws IOException {
<a name="229175"></a>		super.putchar(c);
<a name="229176"></a>		if (c == '\n')
<a name="229177"></a>			flush();
<a name="229178"></a>	}
<br><a name="229179"></a>}
<br><a name="229180"></a>
class Test {
<a name="229181"></a>	public static void main(String[] args)<br>
		throws IOException<br>
	{
<a name="229182"></a>		LineBufferOutput lbo =<br>
			new LineBufferOutput(System.out);
<a name="229183"></a>		lbo.putstr("lbo\nlbo");
<a name="229184"></a>		System.out.print("print\n");
<a name="229185"></a>		lbo.putstr("\n");
<a name="229186"></a>	}
<a name="229187"></a>}
</pre><a name="229188"></a>
This example produces the output:
<p><pre><a name="229189"></a>
lbo
<a name="229190"></a>print
<a name="229191"></a>lbo
</pre><a name="229192"></a>
The class <code>BufferOutput</code> implements a very simple buffered version of an <code>OutputStream</code>, flushing the output when the buffer is full or <code>flush</code> is invoked. The subclass <code>LineBufferOutput</code> declares only a constructor and a single method <code>putchar</code>, which overrides the method <code>putchar</code> of <code>BufferOutput</code>. It inherits the methods <code>putstr</code> and <code>flush</code> from class <code>Buffer</code>.<p>
<a name="229193"></a>
In the <code>putchar</code> method of a <code>LineBufferOutput</code> object, if the character argument is a newline, then it invokes the <code>flush</code> method. The critical point about overriding in this example is that the method <code>putstr</code>, which is declared in class <code>BufferOutput</code>, invokes the <code>putchar</code> method defined by the current object <code>this</code>, which is not necessarily the <code>putchar</code> method declared in class <code>BufferOutput</code>.<p>
<a name="229194"></a>
Thus, when <code>putstr</code> is invoked in <code>main</code> using the <code>LineBufferOutput</code> object <code>lbo</code>, the invocation of <code>putchar</code> in the body of the <code>putstr</code> method is an invocation of the <code>putchar</code> of the object <code>lbo</code>, the overriding declaration of <code>putchar</code> that checks for a newline. This allows a subclass of <code>BufferOutput</code> to change the behavior of the <code>putstr</code> method without redefining it.<p>
<a name="229195"></a>
Documentation for a class such as <code>BufferOutput</code>, which is designed to be extended, should clearly indicate what is the contract between the class and its subclasses, and should clearly indicate that subclasses may override the <code>putchar</code> method in this way. The implementor of the <code>BufferOutput</code> class would not, therefore, want to change the implementation of <code>putstr</code> in a future implementation of <code>BufferOutput</code> not to use the method <code>putchar</code>, because this would break the preexisting contract with subclasses. See the further discussion of binary compatibility in <a href="13.doc.html#44871">&#167;13</a>, especially <a href="13.doc.html#44952">&#167;13.2</a>.<p>
<a name="229203"></a>
<h4>8.4.8.7    Example: Incorrect Overriding because of Throws</h4>
<a name="39701"></a>
This example uses the usual and conventional form for declaring a new exception 
type, in its declaration of the class <code>BadPointException</code>:
<p><pre><a name="39702"></a>
class BadPointException extends Exception {
<a name="39703"></a>	BadPointException() { super(); }
<a name="39704"></a>	BadPointException(String s) { super(s); }
<a name="39705"></a>}
<a name="39707"></a>
class Point {
<a name="39708"></a>	int x, y;
<a name="39709"></a>	void move(int dx, int dy) { x += dx; y += dy; }
<a name="39710"></a>}
<br><a name="39711"></a>
class CheckedPoint extends Point {
<a name="39712"></a>	void move(int dx, int dy) throws BadPointException {
<a name="39713"></a>		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
<a name="39714"></a>			throw new BadPointException();
<a name="39715"></a>		x += dx; y += dy;
<a name="39716"></a>	}
<a name="39717"></a>}
</pre><a name="39718"></a>
This example results in a compile-time error, because the override of method 
<code>move</code> in class <code>CheckedPoint</code> declares that it will throw a checked exception that 
the <code>move</code> in class <code>Point</code> has not declared. If this were not considered an error, an 
invoker of the method <code>move</code> on a reference of type <code>Point</code> could find the contract 
between it and <code>Point</code> broken if this exception were thrown.
<p><a name="39725"></a>
Removing the <code>throws</code> clause does not help:<p>
<pre><a name="39726"></a>
class CheckedPoint extends Point {
<a name="39727"></a>	void move(int dx, int dy) {
<a name="39728"></a>		if ((x + dx) &lt; 0 || (y + dy) &lt; 0)
<a name="39729"></a>			throw new BadPointException();
<a name="39730"></a>		x += dx; y += dy;
<a name="39731"></a>	}
<a name="39732"></a>}
</pre><a name="41194"></a>
A different compile-time error now occurs, because the body of the method <code>move</code> 
cannot throw a checked exception, namely <code>BadPointException</code>, that does not 
appear in the <code>throws</code> clause for <code>move</code>.
<p><a name="39245"></a>
<h2>8.5    Static Initializers</h2>
<a name="39251"></a>
Any <i>static initializers </i>declared in a class are executed when the class is initialized 
and, together with any field initializers <a href="8.doc.html#24510">(&#167;8.3.2)</a> for class variables, may be used to 
initialize the class variables of the class <a href="12.doc.html#44557">(&#167;12.4)</a>.
<p><ul><pre>
<i>StaticInitializer:<br>
</i>	<code>static </code><i>Block
</i></pre></ul><a name="41620"></a>
It is a compile-time error for a static initializer to be able to complete abruptly (<a href="14.doc.html#5894">&#167;14.1</a>, <a href="15.doc.html#79448">&#167;15.5</a>) with a checked exception <a href="11.doc.html#44121">(&#167;11.2)</a>.<p>
<a name="16723"></a>
The static initializers and class variable initializers are executed in textual order and may not refer to class variables declared in the class whose declarations appear textually after the use, even though these class variables are in scope. This restriction is designed to catch, at compile time, circular or otherwise malformed initializations. Thus, both:<p>
<pre><a name="24644"></a>
class Z {
<a name="24645"></a>	static int i = j + 2; 
<a name="24646"></a>	static int j = 4;
<a name="24647"></a>}
</pre><a name="24648"></a>
and:
<p><pre><a name="24649"></a>
class Z {
<a name="24651"></a>	static { i = j + 2; }
<a name="229866"></a>	static int i, j;
<a name="24652"></a>	static { j = 4; }
<a name="24653"></a>}
</pre><a name="24654"></a>
result in compile-time errors. 
<p><a name="229805"></a>
Accesses to class variables by methods are not checked in this way, so:
<p><pre><a name="45892"></a>
class Z {
<a name="25680"></a>	static int peek() { return j; }<br>
	static int i = peek();
<a name="41686"></a>	static int j = 1;
<a name="41687"></a>}
<br><a name="41688"></a>
class Test {
<a name="25681"></a>	public static void main(String[] args) {
<a name="41689"></a>		System.out.println(Z.i);
<a name="41690"></a>	}<br>
}
</pre><a name="41691"></a>
produces the output:
<p><pre><a name="41692"></a>0
</pre><a name="41693"></a>
because the variable initializer for <code>i</code> uses the class method <code>peek</code> to access the 
value of the variable <code>j</code> before <code>j</code> has been initialized by its variable initializer, at 
which point it still has its default value <a href="4.doc.html#10931">(&#167;4.5.4)</a>.
<p><a name="41700"></a>
If a <code>return</code> statement <a href="14.doc.html#6767">(&#167;14.15)</a> appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="39966"></a>
If the keyword <code>this</code> <a href="15.doc.html#31980">(&#167;15.7.2)</a> or the keyword <code>super</code> (<a href="15.doc.html#41267">&#167;15.10</a>, <a href="15.doc.html#20448">&#167;15.11</a>) appears anywhere within a static initializer, then a compile-time error occurs.<p>
<a name="41652"></a>
<h2>8.6    Constructor Declarations</h2>
<a name="78391"></a>
A <i>constructor</i> is used in the creation of an object that is an instance of a class:
<p><ul><pre>
<i>ConstructorDeclaration:<br>
	ConstructorModifiers</i><sub><i>opt</i></sub><code>&#32;</code><i>ConstructorDeclarator<br>
</i>		<i>Throws</i><sub><i>opt</i></sub><code>&#32;</code><i>ConstructorBody
</i>
<i>ConstructorDeclarator:<br>
</i><code>	</code><i>SimpleTypeName</i><code> ( </code><i>FormalParameterList</i><sub><i>opt</i></sub><code> )
</code></pre></ul><a name="30689"></a>
The <i>SimpleTypeName </i>in the <i>ConstructorDeclarator</i> must be the simple name of 
the class that contains the constructor declaration; otherwise a compile-time error 
occurs. In all other respects, the constructor declaration looks just like a method 
declaration that has no result type.
<p><a name="229249"></a>
Here is a simple example:<p>
<pre><a name="30690"></a>
class Point {
<a name="30691"></a>	int x, y;
<a name="30692"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="30693"></a>}
</pre><a name="41721"></a>
Constructors are invoked by class instance creation expressions <a href="15.doc.html#41147">(&#167;15.8)</a>, by the <code>newInstance</code> method of class <code>Class</code> <a href="javalang.doc2.html#14342">(&#167;20.3)</a>, by the conversions and concatenations caused by the string concatenation operator + <a href="15.doc.html#39990">(&#167;15.17.1)</a>, and by explicit constructor invocations from other constructors <a href="8.doc.html#78435">(&#167;8.6.5)</a>. Constructors are never invoked by method invocation expressions <a href="15.doc.html#20448">(&#167;15.11)</a>. <p>
<a name="29483"></a>
Access to constructors is governed by access modifiers <a href="6.doc.html#33916">(&#167;6.6)</a>. This is useful, for example, in preventing instantiation by declaring an inaccessible constructor <a href="8.doc.html#16830">(&#167;8.6.8)</a>.<p>
<a name="39897"></a>
Constructor declarations are not members. They are never inherited and therefore are not subject to hiding or overriding.<p>
<a name="29488"></a>
<h3>8.6.1    Formal Parameters</h3>
<a name="41970"></a>
The formal parameters of a constructor are identical in structure and behavior to 
the formal parameters of a method <a href="8.doc.html#38698">(&#167;8.4.1)</a>.
<p><a name="41990"></a>
<h3>8.6.2    Constructor Signature</h3>
<a name="41996"></a>
The signature of a constructor is identical in structure and behavior to the signature
of a method <a href="8.doc.html#38649">(&#167;8.4.2)</a>.
<p><a name="42018"></a>
<h3>8.6.3    Constructor Modifiers</h3>
<ul><pre>
<i>ConstructorModifiers:<br>
	ConstructorModifier<br>
	ConstructorModifiers</i><code> </code><i>ConstructorModifier
</i>
<i>ConstructorModifier: one of<br>
	</i><code>public&#32;protected&#32;private
</code></pre></ul><a name="36010"></a>
The access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> are discussed in <a href="6.doc.html#33916">&#167;6.6</a>. 
A &#32;compile-time error occurs if the same modifier appears more than once in a 
constructor declaration, or if a constructor declaration has more than one of the 
access modifiers <code>public</code>, <code>protected</code>, and <code>private</code>.
<p><a name="244609"></a>
Unlike methods, a constructor cannot be <code>abstract</code>, <code>static</code>, <code>final</code>, <code>native</code>, or <code>synchronized</code>. A constructor is not inherited, so there is no need to declare it <code>final</code> and an <code>abstract</code> constructor could never be implemented. A constructor is always invoked with respect to an object, so it makes no sense for a constructor to be <code>static</code>. There is no practical need for a constructor to be <code>synchronized</code>, because it would lock the object under construction, which is normally not made available to other threads until all constructors for the object have completed their work. The lack of <code>native</code> constructors is an arbitrary language design choice that makes it easy for an implementation of the Java Virtual Machine to verify that superclass constructors are always properly invoked during object creation.<p>
<a name="244611"></a>
<h3>8.6.4    Constructor Throws</h3>
<a name="244612"></a>
The <code>throws</code> clause for a constructor is identical in structure and behavior to the 
<code>throws</code> clause for a method <a href="8.doc.html#78323">(&#167;8.4.4)</a>.
<p><a name="78435"></a>
<h3>8.6.5    Constructor Body</h3>
<a name="42051"></a>
The first statement of a constructor body may be an explicit invocation of another 
constructor of the same class, written as <code>this</code> followed by a parenthesized argument
list, or an explicit invocation of a constructor of the direct superclass, written 
as <code>super</code> followed by a parenthesized argument list.
<p><ul><pre>
<i>ConstructorBody:<br>
</i>	<code>{ </code><i>ExplicitConstructorInvocation</i><sub><i>opt</i></sub><code> </code><i>BlockStatements</i><sub><i>opt</i></sub><code> }
</code>
<i>ExplicitConstructorInvocation:<br>
	</i><code>this ( </code><i>ArgumentList</i><sub><i>opt</i></sub><code> ) ;<br>
	super ( </code><i>ArgumentList</i><sub><i>opt</i></sub><code> ) ;
</code></pre></ul><a name="230283"></a>
It is a compile-time error for a constructor to directly or indirectly invoke itself through a series of one or more explicit constructor invocations involving <code>this</code>.<p>
<a name="229836"></a>
If a constructor body does not begin with an explicit constructor invocation and the constructor being declared is not part of the primordial class <code>Object</code>, then the constructor body is implicitly assumed by the compiler to begin with a superclass constructor invocation "<code>super();</code>", an invocation of the constructor of its direct superclass that takes no arguments.<p>
<a name="30734"></a>
Except for the possibility of explicit constructor invocations, the body of a constructor is like the body of a method <a href="8.doc.html#37316">(&#167;8.4.5)</a>. A <code>return</code> statement <a href="14.doc.html#6767">(&#167;14.15)</a> may be used in the body of a constructor if it does not include an expression.<p>
<a name="42056"></a>
In the example:<p>
<pre><a name="42057"></a>
class Point {
<br><a name="16855"></a>	int x, y;
<br><br><a name="40008"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<br><a name="16859"></a>}
<br><a name="16860"></a>
class ColoredPoint extends Point {
<br><a name="16863"></a>	static final int WHITE = 0, BLACK = 1;
<br><br><a name="16861"></a>	int color;
<br><a name="16862"></a>
	ColoredPoint(int x, int y) {
<a name="16868"></a>		this(x, y, WHITE);
<a name="16869"></a>	}
<br><a name="16866"></a>
	ColoredPoint(int x, int y, int color) {
<a name="16867"></a>		super(x, y);<br>
		this.color = color;<br>
	}
<br><a name="16870"></a>}
</pre><a name="16871"></a>
the first constructor of <code>ColoredPoint</code> invokes the second, providing an additional 
argument; the second constructor of <code>ColoredPoint</code> invokes the constructor of its 
superclass <code>Point</code>, passing along the coordinates.
<p><a name="42065"></a>
An explicit constructor invocation statement may not refer to any instance variables or instance methods declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs. For example, if the first constructor of <code>ColoredPoint</code> in the example above were changed to:<p>
<pre><a name="16892"></a>
	ColoredPoint(int x, int y) {
<a name="16893"></a>		this(x, y, color);
<a name="16894"></a>	}
</pre><a name="16895"></a>
then a compile-time error would occur, because an instance variable cannot be 
used within a superclass constructor invocation.
<p><a name="229257"></a>
An invocation of the constructor of the direct superclass, whether it actually appears as an explicit constructor invocation statement or is provided automatically <a href="8.doc.html#16823">(&#167;8.6.7)</a>, performs an additional implicit action after a normal return of control from the constructor: all instance variables that have initializers are initialized at that time, in the textual order in which they appear in the class declaration. An invocation of another constructor in the same class using the keyword <code>this</code> does not perform this additional implicit action.<p>
<a name="229264"></a>
<a href="12.doc.html#44670">&#167;12.5</a> describes the creation and initialization of new class instances.<p>
<a name="229266"></a>
<h3>8.6.6    Constructor Overloading</h3>
<a name="16815"></a>
Overloading of constructors is identical in behavior to overloading of methods. 
The overloading is resolved at compile time by each class instance creation 
expression <a href="15.doc.html#41147">(&#167;15.8)</a>.
<p><a name="16823"></a>
<h3>8.6.7    Default Constructor</h3>
<a name="229830"></a>
If a class contains no constructor declarations, then a <i>default constructor</i> that 
takes no parameters is automatically provided:
<p><ul><a name="229831"></a>
<li>If the class being declared is the primordial class <code>Object</code>, then the default constructor has an empty body.
<a name="229832"></a>
<li>Otherwise, the default constructor takes no parameters and simply invokes the superclass constructor with no arguments.
</ul><a name="16772"></a>
A compile-time error occurs if a default constructor is provided by the compiler but the superclass does not have a constructor that takes no arguments.<p>
<a name="16773"></a>
If the class is declared <code>public</code>, then the default constructor is implicitly given the access modifier <code>public</code> <a href="6.doc.html#33916">(&#167;6.6)</a>; otherwise, the default constructor has the default access implied by no access modifier. Thus, the example:<p>
<pre><a name="16778"></a>
public class Point {
<a name="16779"></a>	int x, y;
<a name="16780"></a>}
</pre><a name="16781"></a>
is equivalent to the declaration:
<p><pre><a name="16782"></a>
public class Point {
<a name="16783"></a>	int x, y;
<a name="16784"></a>	public Point() { super(); }
<a name="16785"></a>}
</pre><a name="16786"></a>
where the default constructor is <code>public</code> because the class <code>Point</code> is <code>public</code>.
<p><a name="16830"></a>
<h3>8.6.8    Preventing Instantiation of a Class</h3>
<a name="16831"></a>
A class can be designed to prevent code outside the class declaration from creating
instances of the class by declaring at least one constructor, to prevent the creation
of an implicit constructor, and declaring all constructors to be <code>private</code>. A 
<code>public</code> class can likewise prevent the creation of instances outside its package by 
declaring at least one constructor, to prevent creation of a default constructor with 
<code>public</code> access, and declaring no constructor that is <code>public</code>.
<p><a name="16833"></a>
Thus, in the example:<p>
<pre><a name="16834"></a>
class ClassOnly {
<a name="16835"></a>	private ClassOnly() { }
<a name="16836"></a>	static String just = "only the lonely";
<a name="16837"></a>}
</pre><a name="16838"></a>
the class <code>ClassOnly</code> cannot be instantiated, while in the example:
<p><pre><br><a name="16839"></a>package just;
<br></pre><pre><a name="16840"></a>
public class PackageOnly {
<a name="16841"></a>	PackageOnly() { }
<a name="16842"></a>	String[] justDesserts = { "cheesecake", "ice cream" };
<a name="16843"></a>}
</pre><a name="16844"></a>
the class <code>PackageOnly</code> can be instantiated only within the package <code>just</code>, in 
which it is declared.
<p><a name="244627"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="7.doc.html">Prev</a> | <a href="9.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>