<html>
<head>
<title>The Java Language Specification
 Binary Compatibility</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="12.doc.html">Prev</a> | <a href="14.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="44871"></a>
<p><strong>
CHAPTER
 13 </strong></p>
<a name="44872"></a>
<h1>Binary Compatibility</h1>
<hr><p>
<a name="44874"></a>
Java development tools should support automatic recompilation as necessary 
whenever source code is available. Particular implementations of Java may also 
store the source and binary of types in a versioning database and implement a 
<code>ClassLoader</code> <a href="javalang.doc13.html#14462">(&#167;20.14)</a> that uses integrity mechanisms of the database to prevent 
linkage errors by providing binary-compatible versions of types to clients.
<p><a name="44878"></a>
Developers of packages and classes that are to be widely distributed face a different set of problems. In the Internet, which is our favorite example of a widely distributed system, it is often impractical or impossible to automatically recompile the pre-existing binaries that directly or indirectly depend on a type that is to be changed. Instead, Java defines a set of changes that developers are permitted to make to a package or to a class or interface type while preserving (not breaking) compatibility with existing binaries.<p>
<a name="44879"></a>
The paper quoted above appears in <i>Proceedings of OOPSLA '95</i>, published as <i>ACM SIGPLAN Notices</i>, Volume 30, Number 10, October 1995, pages 426-438. Within the framework of that paper, Java binaries are binary (release-to-release) compatible under all relevant transformations that the authors identify. Using their scheme, here is a list of some important binary compatible changes that Java supports:<p>
<ul><a name="44880"></a>
<li>Reimplementing existing methods, constructors, and initializers to improve performance.
<a name="44881"></a>
<li>Changing methods or constructors to return values on inputs for which they previously either threw exceptions that normally should not occur or failed by going into an infinite loop or causing a deadlock.
<a name="44882"></a>
<li>Adding new fields, methods, or constructors to an existing class or interface.
<a name="44883"></a>
<li>Deleting <code>private</code> fields, methods, or constructors of a class or interface.
<a name="44884"></a>
<li>When an entire package is updated, deleting default (package-only) access fields, methods, or constructors of classes and interfaces in the package.
<a name="44885"></a>
<li>Reordering the fields, methods, or constructors in an existing type declaration.
<a name="44886"></a>
<li>Moving a method upward in the class hierarchy, provided a forwarding method is left in its place.
<a name="44887"></a>
<li>Reordering the list of direct superinterfaces of a class or interface.
<a name="44888"></a>
<li>Inserting new class or interface types in the type hierarchy.
</ul><a name="44889"></a>
This chapter specifies minimum standards for binary compatibility guaranteed by all Java implementations. Java guarantees compatibility when binaries of classes and interfaces are mixed that are not known to be from compatible sources, but whose sources have been modified in the compatible ways described here.<p>
<a name="44891"></a>
We encourage Java development systems to provide facilities that alert developers to the impact of changes on pre-existing binaries that cannot be recompiled.<p>
<a name="44892"></a>
This chapter first specifies some properties that any Java binary format must have <a href="13.doc.html#44909">(&#167;13.1)</a>. It next defines binary compatibility, explaining what it is and what it is not <a href="13.doc.html#44952">(&#167;13.2)</a>. It finally enumerates a large set of possible changes to packages <a href="13.doc.html#47338">(&#167;13.3)</a>, classes <a href="13.doc.html#44977">(&#167;13.4)</a> and interfaces <a href="13.doc.html#45337">(&#167;13.5)</a>, specifying which changes are guaranteed to preserve binary compatibility and which are not.<p>
<a name="44909"></a>
<h2>13.1    The Form of a Java Binary</h2>
<a name="44910"></a>
While many Java binary files are likely to be in exactly the <code>class</code> file format specified
by the <i>The Java Virtual Machine Specification</i>, this specification does not 
mandate the use of any specific binary file format. Rather, it specifies properties 
that any binary format for compiled types must obey. A number of these properties
are specifically chosen to support source code transformations that preserve 
binary compatibility.
<p><a name="44911"></a>
The requirements are:<p>
<ul><a name="44912"></a>
<li>Binary formats for Java programs must be defined and processed to respect the specifications of loading <a href="12.doc.html#44459">(&#167;12.2)</a>, linking <a href="12.doc.html#44487">(&#167;12.3)</a> and initialization <a href="12.doc.html#44557">(&#167;12.4)</a> of class and interface types.
<a name="44922"></a>
<li>A reference to another class or interface type must be symbolic, using the fully qualified name of the type as determined at compile time.
<a name="44923"></a>
<li>A reference to a field of another class or interface must be resolved at compile time to a symbolic reference to the class or interface in which the field is declared, plus the simple name of the field. (Including the exact class or interface in which the field is declared makes the binaries more robust, since adding another field with the same name, even in a subclass, cannot cause confusion at link time. This rule does mean, however, that moving a field to a superclass is not a binary compatible change; see <a href="13.doc.html#45037">&#167;13.4.5</a> for a discussion.) The reference must also include a symbolic reference to the declared type of the field so that the verifier can check that the type is as expected. References to fields that are <code>static</code>, <code>final</code>, and initialized with compile-time constant expressions are resolved at compile time to the constant value that is denoted. No reference to such a constant field should be present in the code in a binary file (except in the class or interface containing the constant field, which will have code to initialize it), and such constant fields must always appear to have been initialized; the default initial value for the type of such a field must never be observed. See <a href="13.doc.html#45139">&#167;13.4.8</a> for a discussion.
<a name="44930"></a>
<li>A reference to a method or constructor must be resolved at compile time to a symbolic reference to the class or interface in which the denoted method or constructor is declared, plus the signature of the method or constructor. (As for fields, this makes the binaries more robust, with the caveat that such a method cannot be moved to a superclass without leaving a forwarding method behind; see <a href="13.doc.html#45037">&#167;13.4.5</a> for a discussion.) A reference to a method must also include either a symbolic reference to the return type of the denoted method or an indication that the denoted method is declared <code>void</code> and does not return a value. The signature of a method must include all of the following:
<ul>
<a name="44937"></a>
<li>The simple name of the method
<a name="46201"></a>
<li>The number of parameters to the method 
<a name="46202"></a>
<li>A symbolic reference to the type of each parameter
</ul>
</ul><ul><a name="46994"></a>
<br><br>The signature of a constructor must include both:
<ul>
<a name="46995"></a>
<li>The number of parameters to the constructor
<a name="46996"></a>
<li>A symbolic reference to the type of each parameter
</ul>
</ul><a name="46203"></a>
A Java binary representation for a class or interface must also contain all of the 
following:
<p><ul><a name="44941"></a>
<li>If it is a class and is not class <code>java.lang.Object</code>, then a symbolic reference to the direct superclass of this class
<a name="44942"></a>
<li>A symbolic reference to each direct superinterface, if any
<a name="44943"></a>
<li>A specification of each field that is not <code>private</code> declared in the class or interface, given as the simple name of the field and a symbolic reference to the type of the field
<a name="44944"></a>
<li>If it is a class, then the signature of each constructor, as described above
<a name="44945"></a>
<li>For each method that is not <code>private</code> declared in the class or interface, its signature and return type, as described above
<a name="44946"></a>
<li>The code needed to implement the class or interface:
<ul>
<a name="44947"></a>
<li>For an interface, code for the field initializers
<a name="44948"></a>
<li>For a class, code for the field initializers, the static initializers, and the implementation of each method or constructor that is not declared <code>private</code>
</ul>
</ul><a name="44949"></a>
If a Java system defines a binary format that represents a group of classes and interfaces comprised by an entire package, then this binary format need not expose information about fields, methods, or constructors that are declared with default (package) access.<p>
<a name="44950"></a>
The following sections specify the changes that may be made to class and interface type declarations without breaking compatibility with pre-existing binaries. The Java Virtual Machine and its standard <code>class</code> file format support these changes; other Java binary formats are required to support these changes as well.<p>
<a name="44952"></a>
<h2>13.2    What Binary Compatibility Is and Is Not</h2>
<a name="44953"></a>
A change to a type is <i>binary compatible</i> <i>with</i> (equivalently, does not<i> break binary 
compatibility </i>with) preexisting binaries if preexisting binaries that previously 
linked without error will continue to link without error.
<p><a name="44957"></a>
As described in <a href="13.doc.html#44909">&#167;13.1</a>, symbolic references to methods and fields name the exact class or interface in which the method or field is declared. This means that binaries are compiled to rely on the accessible members and constructors of other classes and interfaces. To preserve binary compatibility, a class or interface should treat these accessible members and constructors, their existence and behavior, as a <i>contract</i> with users of the class or interface.<p>
<a name="44958"></a>
Java is designed to prevent additions to contracts and accidental name collisions from breaking binary compatibility; specifically:<p>
<ul><a name="44959"></a>
<li>Introducing a new field with the same name as an existing field, in a subclass of the class containing the existing field declaration, does not break compatibility with preexisting binaries. See the example at the beginning of <a href="13.doc.html#45037">&#167;13.4.5</a>.
<a name="44963"></a>
<li>Addition of more methods overloading a particular method name does not break compatibility with preexisting binaries. The method signature that the preexisting binary will use for method lookup is chosen by Java's method overload resolution algorithm at compile time <a href="15.doc.html#21693">(&#167;15.11.2)</a>. (If Java had been designed so that the particular method to be executed was chosen at run time, then such an ambiguity might be detected at run time. Such a rule would imply that adding an additional overloaded method so as to make ambiguity possible at a call site became possible could break compatibility with an unknown number of preexisting binaries. See <a href="13.doc.html#45274">&#167;13.4.22</a> for more discussion.)
</ul><a name="44967"></a>
Binary compatibility is not the same as source compatibility. In particular, the example in <a href="13.doc.html#45037">&#167;13.4.5</a> shows that a set of compatible binaries can be produced from sources that will not compile all together. This example is typical: a new declaration is added, changing the meaning of a name in an unchanged part of the source code, while the preexisting binary for that unchanged part of the source code retains the fully-qualified, previous meaning of the name. Producing a consistent set of source code requires providing a qualified name or field access expression corresponding to the previous meaning.<p>
<a name="47335"></a>
We hope to make some improvements to future versions of Java to better support both source and binary compatible evolution of types. In particular, we are considering a mechanism to allow a class to implement two interfaces that have methods with the same signature but are to be considered different or have different return types. We welcome suggestions and proposals that would help us to make additional improvements, either in managing name and signature conflicts or other sources of incompatibility.<p>
<a name="47338"></a>
<h2>13.3    Evolution of Packages</h2>
<a name="44974"></a>
A new class or interface type may be added to a package without breaking compatibility
with pre-existing binaries, provided the new type does not reuse a name 
previously given to an unrelated type. If a new type reuses a name previously 
given to an unrelated type, then a conflict may result, since binaries for both types 
could not be loaded by the same class loader.
<p><a name="44975"></a>
Changes in class and interface types that are not <code>public</code> and that are not a superclass or superinterface, respectively, of a <code>public</code> type, affect only types within the package in which they are declared. Such types may be deleted or otherwise changed, even if incompatibilities are otherwise described here, provided that the affected binaries of that package are updated together.<p>
<a name="44977"></a>
<h2>13.4    Evolution of Classes</h2>
<a name="44978"></a>
This section describes the effects of changes to the declaration of a class and its 
members and constructors on pre-existing binaries.
<p><a name="44980"></a>
<h3>13.4.1    <code>abstract</code> Classes</h3>
<a name="44981"></a>
If a class that was not <code>abstract</code> is changed to be declared <code>abstract</code>, then pre-
existing binaries that attempt to create new instances of that class will throw either 
an <code>InstantiationError</code> at link time, or an <code>InstantiationException</code> at run 
time (if the method <code>newInstance</code> <a href="javalang.doc2.html#15088">(&#167;20.3.6)</a> of class <code>Class</code> is used); such a change 
is therefore not recommended for widely distributed classes.
<p><a name="44985"></a>
Changing a class that was declared <code>abstract</code> to no longer be declared <code>abstract</code> does not break compatibility with pre-existing binaries.<p>
<a name="44987"></a>
<h3>13.4.2    <code>final</code> <code></code>Classes</h3>
<a name="44988"></a>
If a class that was not declared <code>final</code> is changed to be declared <code>final</code>, then a 
<code>VerifyError</code> is thrown if a binary of a pre-existing subclass of this class is 
loaded, because <code>final</code> classes can have no subclasses; such a change is not recommended
for widely distributed classes.
<p><a name="44989"></a>
Changing a class that was declared <code>final</code> to no longer be declared <code>final </code>does not break compatibility with pre-existing binaries.<p>
<a name="44990"></a>
<h3>13.4.3    <code>public</code> <code></code>Classes</h3>
<a name="44991"></a>
Changing a class that was not declared <code>public</code> to be declared <code>public</code> does not 
break compatibility with pre-existing binaries.
<p><a name="44992"></a>
If a class that was declared <code>public</code> is changed to not be declared <code>public</code>, then an <code>IllegalAccessError</code> is thrown if a pre-existing binary is linked that needs but no longer has access to the class type; such a change is not recommended for widely distributed classes.<p>
<a name="44994"></a>
<h3>13.4.4    Superclasses and Superinterfaces</h3>
<a name="44995"></a>
A <code>ClassCircularityError</code> is thrown at load time if a class would be a superclass
of itself. Changes to the class hierarchy that could result in such a circularity 
when newly compiled binaries are loaded with pre-existing binaries are not recommended
for widely distributed classes.
<p><a name="44996"></a>
Changing the direct superclass or the set of direct superinterfaces of a class type will not break compatibility with pre-existing binaries, provided that the total set of superclasses or superinterfaces, respectively, of the class type loses no members.<p>
<a name="44997"></a>
Changes to the set of superclasses of a class will not break compatibility with pre-existing binaries simply because of uses of class variables and class methods. This is because uses of class variables and class methods are resolved at compile time to symbolic references to the name of the class that declares them. Such uses therefore depend only on the continuing existence of the class declaring the variable or method, not on the shape of the class hierarchy.<p>
<a name="44998"></a>
If a change to the direct superclass or the set of direct superinterfaces results in any class or interface no longer being a superclass or superinterface, respectively, then link-time errors may result if pre-existing binaries are loaded with the binary of the modified class. Such changes are not recommended for widely distributed classes. The resulting errors are detected by the verifier of the Java Virtual Machine when an operation that previously compiled would violate the type system. For example, suppose that the following test program:<p>
<pre><a name="44999"></a>class Hyper { char h = 'h'; } 
<a name="45000"></a>class Super extends Hyper { char s = 's'; }
<a name="45001"></a>class Test extends Super {
<a name="45002"></a>    public static void main(String[] args) {
<a name="45003"></a>        Hyper h = new Super();
<a name="45004"></a>        System.out.println(h.h);
<a name="45005"></a>    }
<a name="45006"></a>}
</pre><a name="45007"></a>
is compiled and executed, producing the output:
<p><pre><a name="45008"></a>h
</pre><a name="47239"></a>
Suppose that a new version of class <code>Super</code> is then compiled:
<p><pre><a name="47240"></a>class Super { char s = 's'; }
</pre><a name="47241"></a>
This version of class <code>Super</code> is not a subclass of <code>Hyper</code>. If we then run the existing 
binaries of <code>Hyper</code> and <code>Test</code> with the new version of <code>Super</code>, then a <code>VerifyError</code> 
is thrown at link time. The verifier objects because the result of <code>new</code> <code>Super()</code> 
cannot &#32;be assigned to a variable of type <code>Hyper</code>, because <code>Super</code> is not a subclass of 
<code>Hyper</code>.
<p><a name="45012"></a>
It is instructive to consider what might happen without the verification step: the program might run and print:<p>
<pre><a name="45013"></a>s
</pre><a name="45014"></a>
This demonstrates that without the verifier the type system could be defeated by 
linking inconsistent binary files, even though each was produced by a correct Java 
compiler.
<p><a name="45015"></a>
As a further example, here is an implementation of a cast from a reference type to <code>int</code>, which could be made to run in certain implementations of Java if they failed to perform the verification process. Assume an implementation that uses method dispatch tables and whose linker assigns offsets into those tables in a sequential and straightforward manner. Then suppose that the following Java code is compiled:<p>
<pre><a name="45016"></a>class Hyper { int zero(Object o) { return 0; } }
<a name="45017"></a>class Super extends Hyper { int peek(int i) { return i; }  }
</pre><pre><a name="45018"></a>
class Test extends Super {
<a name="45019"></a>	public static void main(String[] args) throws Throwable {
<a name="45020"></a>		Super as = new Super();
<a name="45021"></a>		System.out.println(as);
<a name="45022"></a>		System.out.println(Integer.toHexString(as.zero(as)));
<a name="45023"></a>	}
<a name="45024"></a>}
</pre><a name="45025"></a>
The assumed implementation determines that the class <code>Super</code> has two methods: 
the first is method <code>zero</code> inherited from class <code>Hyper</code>, and the second is the method 
<code>peek</code>. Any subclass of <code>Super</code> would also have these same two methods in the first 
two entries of its method table. (Actually, all these methods would be preceded in 
the method tables by all the methods inherited from class <code>Object</code> but, to simplify 
the discussion, we ignore that here.) For the method invocation <code>as.zero(as)</code>, the 
compiler specifies that the first method of the method table should be invoked; this 
is always correct if type safety is preserved.
<p><a name="45026"></a>
If the compiled code is then executed, it prints something like:<p>
<pre><a name="45027"></a>
Super@ee300858
<a name="45028"></a>0
</pre><a name="45029"></a>
which is the correct output. But if a new version of <code>Super</code> is compiled, which is 
the same except for the <code>extends</code> clause:
<p><pre><a name="47244"></a>class Super { int peek(int i) { return i; }  }
</pre><a name="45031"></a>
then the first method in the method table for <code>Super</code> will now be <code>peek</code>, not <code>zero</code>. 
Using the new binary code for <code>Super</code> with the old binary code for <code>Hyper</code> and 
<code>Test</code> will cause the method invocation <code>as.zero(as)</code> to dispatch to the method 
<code>peek</code> in <code>Super</code>, rather than the method <code>zero</code> in <code>Hyper</code>. This is a type violation, of 
course; the argument is of type <code>Super</code> but the parameter is of type <code>int</code>. With a few 
plausible assumptions about internal data representations and the consequences of 
the type violation, execution of this incorrect program might produce the output:
<p><pre><a name="45032"></a>
Super@ee300848
<a name="45033"></a>ee300848
</pre><a name="45034"></a>
A <code>poke</code> method, capable of altering any location in memory, could be concocted 
in a similar manner. This is left as an exercise for the reader.
<p><a name="45035"></a>
The lesson is that a implementation of Java that lacks a verifier or fails to use it will not maintain type safety and is, therefore, not a valid Java implementation. <p>
<a name="45037"></a>
<h3>13.4.5    Class Body and Member Declarations</h3>
<a name="45038"></a>
No incompatibility with pre-existing binaries is caused by adding a class member 
that has the same name (for fields) or same name, signature, and return type (for 
methods) as a member of a superclass or subclass. References to the original field 
or method were resolved at compile time to a symbolic reference containing the 
name of the class in which they were declared. This makes compiled Java code 
more robust against changes than it might otherwise be. No error occurs even if 
the set of classes being linked would encounter a compile-time error. As an example,
if the program:
<p><pre><a name="45039"></a>class Hyper { String h = "Hyper"; }
<a name="45040"></a>class Super extends Hyper { }
<a name="45041"></a>class Test extends Super {
<a name="45042"></a>	public static void main(String[] args) {
<a name="45043"></a>		String s = new Test().h;
<a name="45044"></a>		System.out.println(s);
<a name="45045"></a>	}
<a name="45046"></a>}
</pre><a name="45047"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45048"></a>Hyper
</pre><a name="45049"></a>
Suppose that a new version of class <code>Super</code> is then compiled:
<p><pre><a name="45050"></a>class Super extends Hyper { char h = 'h'; }
</pre><a name="45051"></a>
If the resulting binary is used with the existing binaries for <code>Hyper</code> and <code>Test</code>, then 
the output is still:
<p><pre><a name="45052"></a>Hyper
</pre><a name="45053"></a>
even though compiling the source for these binaries:
<p><pre><a name="45054"></a>class Hyper { String h = "Hyper"; }
<a name="45055"></a>class Super extends Hyper { char h = 'h'; }
<a name="45056"></a>class Test extends Super {
<a name="45057"></a>	public static void main(String[] args) {
<a name="45058"></a>		String s = new Test().h;
<a name="45059"></a>		System.out.println(s);
<a name="45060"></a>	}
<a name="45061"></a>}
</pre><a name="45062"></a>
would result in a compile-time error, because the <code>h</code> in the source code for <code>main</code> 
would now be construed as referring to the <code>char</code> field declared in <code>Super</code>, and a 
<code>char</code> value can't be assigned to a <code>String</code>.
<p><a name="45063"></a>
Deleting a class member or constructor that is not declared <code>private</code> may cause a linkage error if the member or constructor is used by a pre-existing binary, even if the member was an instance method that was overriding a superclass method. This is because, during resolution, the linker looks only in the class that was identified at compile time. Thus, if the program:<p>
<pre><a name="45064"></a>
class Hyper {
<a name="45065"></a>	void hello() { System.out.println("hello from Hyper"); }
<a name="45066"></a>}
<a name="45067"></a>
class Super extends Hyper {
<a name="45068"></a>	void hello() { System.out.println("hello from Super"); }
<a name="45069"></a>}
<a name="45070"></a>
class Test {
<a name="45071"></a>	public static void main(String[] args) {
<a name="45072"></a>		new Super().hello();
<a name="45073"></a>	}
<a name="45074"></a>}
</pre><a name="45075"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45076"></a>hello from Super
</pre><a name="45077"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45078"></a>class Super extends Hyper { }
</pre><a name="45079"></a>
If <code>Super</code> and <code>Hyper</code> are recompiled but not <code>Test</code>, then a <code>NoSuchMethodError</code> 
will result at link time, because the method <code>hello</code> is no longer declared in class 
<code>Super</code>.
<p><a name="45080"></a>
To preserve binary compatibility, methods should not be deleted; instead, "forwarding methods" should be used. In our example, replacing the declaration of <code>Super</code> with:<p>
<pre><a name="45081"></a>
class Super extends Hyper {
<a name="45082"></a>	void hello() { super.hello(); }
<a name="45083"></a>}
</pre><a name="45084"></a>
then recompiling <code>Super</code> and <code>Hyper</code> and executing these new binaries with the 
original binary for <code>Test</code>, produces the output:
<p><pre><a name="45085"></a>hello from Hyper
</pre><a name="45086"></a>
as might have naively been expected from the previous example.
<p><a name="45087"></a>
The <code>super</code> keyword can be used to access a method declared in a superclass, bypassing any methods declared in the current class. The expression:<p>
<pre><a name="45088"></a><code>super.</code><i>Identifier
</i></pre><a name="45089"></a>
is resolved, at compile time, to a method <i>M</i> declared in a particular superclass <i>S</i>. 
The method <i>M</i> must still be declared in that class at run time or a linkage error will 
result. If the method <i>M</i> is an instance method, then the method <i>MR</i> invoked at run 
time is the method with the same signature as <i>M</i> that is a member of the direct 
superclass of the class containing the expression involving <code>super</code>. Thus, if the 
program:
<p><pre><a name="45090"></a>
class Hyper {
<a name="45091"></a>	void hello() { System.out.println("hello from Hyper"); }
<a name="45092"></a>}
<a name="45093"></a>class Super extends Hyper { }
<a name="45094"></a>class Test extends Super {
<a name="45095"></a>
	public static void main(String[] args) {
<a name="45096"></a>		new Test().hello();
<a name="45097"></a>	}
<a name="45098"></a>
	void hello() {
<a name="45099"></a>		super.hello();
<a name="45100"></a>	}
<a name="45101"></a>}
</pre><a name="45102"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45103"></a>hello from Hyper
</pre><a name="45104"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45105"></a>
class Super extends Hyper {
<a name="45106"></a>	void hello() { System.out.println("hello from Super"); }
<a name="45107"></a>}
</pre><a name="45108"></a>
If <code>Super</code> and <code>Hyper</code> are recompiled but not <code>Test</code>, then running the new binaries 
with the existing binary of <code>Test</code> produces the output:
<p><pre><a name="45109"></a>hello from Super
</pre><a name="45110"></a>
as you might expect. (A flaw in some early versions of Java caused them to print:
<p><pre><a name="45111"></a>hello from Hyper
</pre><a name="45114"></a>
incorrectly.)
<p><a name="47259"></a>
<h3>13.4.6    Access to Members and Constructors</h3>
<a name="45115"></a>
Changing the declared access of a member or constructor to permit less access 
may break compatibility with pre-existing binaries, causing a linkage error to be 
thrown when these binaries are resolved. Less access is permitted if the access 
modifier is changed from default access to <code>private</code> access; from <code>protected</code> 
access to default or <code>private</code> access; or from <code>public</code> access to <code>protected</code>, 
default, or <code>private</code> access. Changing a member or constructor to permit less 
access is therefore not recommended for widely distributed classes.
<p><a name="45116"></a>
Perhaps surprisingly, Java is defined so that changing a member or constructor to be more accessible does not cause a linkage error when a subclass (already) defines a method to have less access. So, for example, if the package <code>points</code> defines the class <code>Point</code>:<p>
<pre><a name="45715"></a><code>package points;
</code></pre><pre><a name="45716"></a>
<code>public class Point {
</code><a name="45721"></a>	public int x, y;
<a name="45722"></a>	protected void print() {
<a name="45723"></a>		System.out.println("(" + x + "," + y + ")");
<a name="45724"></a>	}
<a name="45725"></a>}
</pre><a name="45726"></a>
used by the <code>Test</code> program:
<p><pre><a name="45727"></a>
class Test extends points.Point {
<a name="45733"></a>	protected void print() { System.out.println("Test"); }
<a name="45728"></a>	public static void main(String[] args) {
<a name="45730"></a>		Test t = new Test();
<a name="45729"></a>		t.print();
<a name="45731"></a>	}
<a name="45732"></a>}
</pre><a name="45734"></a>
then these classes compile and <code>Test</code> executes to produce the output:
<p><pre><a name="45735"></a>Test
</pre><a name="45736"></a>
If the method <code>print</code> in class <code>Point</code> is changed to be <code>public</code>, and then only the 
<code>Point</code> class is recompiled, and then executed with the previously existing binary 
for <code>Test</code> then no linkage error occurs, even though it is improper, at compile time, 
for a <code>public</code> method to be overridden by a <code>protected</code> method (as shown by the 
fact that the class <code>Test</code> could not be recompiled using this new <code>Point</code> class unless 
print were changed to be <code>public</code>.)
<p><a name="47725"></a>
Allowing superclasses to change <code>protected</code> methods to be <code>public</code> without breaking binaries of preexisting subclasses helps make Java binaries less fragile. The alternative, where such a change would cause a linkage error, would create additional binary incompatibilities with no apparent benefit.<p>
<a name="45118"></a>
<h3>13.4.7    Field Declarations</h3>
<a name="45119"></a>
Adding a field to a class will not break compatibility with any pre-existing binaries
that are not recompiled, even in the case where a class could no longer be 
recompiled because a field access previously referenced a field of a superclass 
with an incompatible type. The previously compiled class with such a reference 
will continue to reference the field declared in a superclass. Thus compiling and 
executing the code:
<p><pre><a name="45120"></a>class Hyper { String h = "hyper"; }
<a name="45121"></a>class Super extends Hyper { String s = "super"; }
<a name="45122"></a>class Test {
<a name="45123"></a>	public static void main(String[] args) {
<a name="45124"></a>		System.out.println(new Super().h);
<a name="45125"></a>	}
<a name="45126"></a>}
</pre><a name="45127"></a>
produces the output:
<p><pre><a name="45128"></a>hyper
</pre><a name="47307"></a>
Changing <code>Super</code> to be defined as:
<p><pre><a name="45130"></a>
class Super extends Hyper {
<a name="45131"></a>	String s = "super";
<a name="45132"></a>	int h = 0;
<a name="45133"></a>}
</pre><a name="45134"></a>
recompiling <code>Hyper</code> and <code>Super</code>, and executing the resulting new binaries with the 
old binary of <code>Test</code> produces the output:
<p><pre><a name="45135"></a>hyper
</pre><a name="45136"></a>
The field <code>h</code> of <code>Hyper</code> is output by the original binary of <code>main</code> no matter what type 
field <code>h</code> is declared in <code>Super</code>. While this may seem surprising at first, it serves to 
reduce the number of incompatibilities that occur at run time. (In an ideal world, 
all source files that needed recompilation would be recompiled whenever any one 
of them changed, eliminating such surprises. But such a mass recompilation is 
often impractical or impossible, especially in the Internet. And, as was previously 
noted, such recompilation would sometimes require further changes to the source 
code.)
<p><a name="45137"></a>
Deleting a field from a class will break compatibility with any pre-existing binaries that reference this field, and a <code>NoSuchFieldError</code> will be thrown when such a reference from a pre-existing binary is linked. Only <code>private</code> fields may be safely deleted from a widely distributed class.<p>
<a name="45139"></a>
<h3>13.4.8    <code>final</code> Fields and Constants</h3>
<a name="45140"></a>
If a field that was not <code>final</code> is changed to be <code>final</code>, then it can break compatibility
with pre-existing binaries that attempt to assign new values to the field. For 
example, if the program:
<p><pre><a name="45141"></a>class Super { static char s; }
</pre><pre><a name="45142"></a>
class Test extends Super {
<a name="45143"></a>	public static void main(String[] args) {
<a name="45144"></a>		s = 'a';
<a name="45145"></a>		System.out.println(s);
<a name="45146"></a>	}
<a name="45147"></a>}
</pre><a name="45148"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45149"></a>a
</pre><a name="47429"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="47321"></a>class Super { static char s; }
</pre><a name="45152"></a>
If <code>Super</code> is recompiled but not <code>Test</code>, then running the new binary with the existing
binary of <code>Test</code> results in a <code>IncompatibleClassChangeError</code>. (In certain 
early implementations of Java this example would run without error, because of a 
flaw in the implementation.)
<p><a name="45153"></a>
We call a field that is <code>static</code>, <code>final</code>, and initialized with a compile-time constant expression a <i>primitive</i> <i>constant</i>. Note that all fields in interfaces are implicitly <code>static</code> and <code>final</code>, and they are often, but not always, constants.<p>
<a name="45154"></a>
If a field is not a primitive constant, then deleting the keyword <code>final</code> or changing the value to which the field is initialized does not break compatibility with existing binaries.<p>
<a name="45155"></a>
If a field is a primitive constant, then deleting the keyword <code>final</code> or changing its value will not break compatibility with pre-existing binaries by causing them not to run, but they will not see any new value for the constant unless they are recompiled. If the example:<p>
<pre><a name="45156"></a>class Flags { final static boolean debug = true; }
</pre><pre><a name="45157"></a>
class Test {
<a name="45158"></a>	public static void main(String[] args) {
<a name="45159"></a>		if (Flags.debug)
<a name="45160"></a>			System.out.println("debug is true");
<a name="45161"></a>	}
<a name="45162"></a>}
</pre><a name="45163"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45164"></a>debug is true
</pre><a name="45165"></a>
Suppose that a new version of class <code>Flags</code> is produced:
<p><pre><a name="45166"></a>class Flags { final static boolean debug = false; }
</pre><a name="45167"></a>
If <code>Flags</code> is recompiled but not <code>Test</code>, then running the new binary with the existing
binary of <code>Test</code> produces the output:
<p><pre><a name="45168"></a>debug is true
</pre><a name="45169"></a>
because the value of <code>debug</code> was a compile-time primitive constant, and could have 
been used in compiling <code>Test</code> without making a reference to the class <code>Flags</code>.
<p><a name="47322"></a>
This result is a side-effect of the decision to support conditional compilation, as discussed at the end of <a href="14.doc.html#236365">&#167;14.19</a>.<p>
<a name="47435"></a>
This behavior would not change if <code>Flags</code> were changed to be an interface, as in the modified example:<p>
<pre><a name="45170"></a>interface Flags { boolean debug = true; }
<a name="45171"></a>class Test {
<a name="45172"></a>	public static void main(String[] args) {
<a name="45173"></a>		if (Flags.debug)
<a name="45174"></a>			System.out.println("debug is true");
<a name="45175"></a>	}
<a name="45176"></a>}
</pre><a name="45177"></a>
(One reason for requiring inlining of primitive constants is that Java <code>switch</code> statements
require constants on each <code>case</code>, and no two such constant values may be 
the same. Java checks for duplicate constant values in a <code>switch</code> statement at compile
time; the <code>class</code> file format does not do symbolic linkage of <code>case</code> values.)
<p><a name="45178"></a>
The best way to avoid problems with "inconstant constants" in widely-distributed code is to declare as primitive constants only values which truly are unlikely ever to change. Many primitive constants in interfaces are small integer values replacing enumerated types, which Java does not support; these small values can be chosen arbitrarily, and should not need to be changed. Other than for true mathematical constants, we recommend that Java code make very sparing use of class variables that are declared <code>static</code> and <code>final</code>. If the read-only nature of <code>final</code> is required, a better choice is to declare a <code>private</code> <code>static</code> variable and a suitable accessor method to get its value. Thus we recommend:<p>
<pre><a name="45179"></a>private static int N;
<a name="45180"></a>public static int getN() { return N; }
</pre><a name="45181"></a>
rather than:
<p><pre><a name="45182"></a>public static final int N = ...;
</pre><a name="45183"></a>
There is no problem with:
<p><pre><a name="45184"></a>public static int N = ...;
</pre><a name="45185"></a>
if <code>N</code> need not be read-only. We also recommend, as a general rule, that only truly 
constant values be declared in interfaces. We note, but do not recommend, that if a 
field of primitive type of an interface may change, its value may be expressed idiomatically
as in:
<p><pre><a name="45186"></a>
interface Flags {
<a name="45187"></a>	boolean debug = new Boolean(true).booleanValue();
<a name="45188"></a>}
</pre><a name="47644"></a>
insuring that this value is not a constant. Similar idioms exist for the other primitive
types.
<p><a name="47645"></a>
One other thing to note is that <code>static</code> <code>final</code> fields that have constant values (whether of primitive or <code>String</code> type) must never appear to have the default initial value for their type <a href="4.doc.html#10931">(&#167;4.5.4)</a>. This means that all such fields appear to be initialized first during class initialization (<a href="8.doc.html#38010">&#167;8.3.2.1</a>, <a href="9.doc.html#40720">&#167;9.3.1</a>, <a href="12.doc.html#44630">&#167;12.4.2</a>).<p>
<a name="45190"></a>
<h3>13.4.9    <code>static</code> Fields</h3>
<a name="45191"></a>
If a field that is not declared <code>private</code> was not declared <code>static</code> and is changed to 
be declared <code>static</code>, or vice versa, then a linkage time error, specifically an 
<code>IncompatibleClassChangeError</code>, will result if the field is used by a preexisting 
binary which expected a field of the other kind. Such changes are not recommended
in code that has been widely distributed.
<p><a name="45192"></a>
<h3>13.4.10    <code>transient</code> Fields</h3>
<a name="45193"></a>
Adding or deleting a <code>transient</code> modifier of a field does not break compatibility 
with pre-existing binaries.
<p><a name="45194"></a>
<h3>13.4.11    <code>volatile</code> Fields</h3>
<a name="45195"></a>
If a field that is not declared <code>private</code> was not declared <code>volatile</code> and is changed 
to be declared <code>volatile</code>, or vice versa, then a linkage time error, specifically an 
<code>IncompatibleClassChangeError</code>, may result if the field is used by a preexisting 
binary that expected a field of the opposite volatility. Such changes are not recommended
in code that has been widely distributed.
<p><a name="45197"></a>
<h3>13.4.12    Method and Constructor Declarations</h3>
<a name="45198"></a>
Adding a method or constructor declaration to a class will not break compatibility 
with any pre-existing binaries, even in the case where a type could no longer be 
recompiled because a method invocation previously referenced a method of a 
superclass with an incompatible type. The previously compiled class with such a 
reference will continue to reference the method declared in a superclass.
<p><a name="45199"></a>
Deleting a method or constructor from a class will break compatibility with any pre-existing binary that referenced this method or constructor; a <code>NoSuchMethodError</code> &#32;will be thrown when such a reference from a pre-existing binary is linked. Only <code>private</code> methods or constructors may be safely deleted from a widely distributed class.<p>
<a name="45200"></a>
If the source code for a class contains no declared constructors, the Java compiler automatically supplies a constructor with no parameters. Adding one or more constructor declarations to the source code of such a class will prevent this default constructor from being supplied automatically, effectively deleting a constructor, unless one of the new constructors also has no parameters, thus replacing the default constructor. The automatically supplied constructor with no parameters is given the same access modifier as the class of its declaration, so any replacement should have as much or more access if compatibility with pre-existing binaries is to be preserved.<p>
<a name="45202"></a>
<h3>13.4.13    Method and Constructor Parameters</h3>
<a name="45203"></a>
Changing the name of a formal parameter of a method or constructor does not 
impact pre-existing binaries. Changing the name of a method, the type of a formal 
parameter to a method or constructor, or adding a parameter to or deleting a 
parameter from a method or constructor declaration creates a method or constructor
with a new signature, and has the combined effect of deleting the method or 
constructor with the old signature and adding a method or constructor with the 
new signature (see <a href="13.doc.html#45197">&#167;13.4.12</a>).
<p><a name="45208"></a>
<h3>13.4.14    Method Result Type</h3>
<a name="45209"></a>
Changing the result type of a method, replacing a result type with <code>void</code>, or replacing
<code>void</code> with a result type has the combined effect of deleting the old method or 
constructor and adding a new method or constructor with the new result type or 
newly <code>void</code> result (see <a href="13.doc.html#45197">&#167;13.4.12</a>).
<p><a name="45214"></a>
<h3>13.4.15    <code>abstract</code> Methods</h3>
<a name="45215"></a>
Changing a method that is declared <code>abstract</code> to no longer be declared <code>abstract</code> 
does not break compatibility with pre-existing binaries.
<p><a name="45216"></a>
Changing a method that is not declared <code>abstract</code> to be declared <code>abstract</code> will break compatibility with pre-existing binaries that previously invoked the method, causing an <code>AbstractMethodError</code>. If the example program:<p>
<pre><a name="45217"></a>
class Super { void out() { System.out.println("Out"); } }
<a name="45220"></a>
class Test extends Super {
<a name="45221"></a>	public static void main(String[] args) {
<a name="45222"></a>		Test t = new Test();
<a name="45223"></a>		System.out.println("Way ");
<a name="45224"></a>		t.out();
<a name="45225"></a>	}
<a name="45226"></a>}
</pre><a name="45227"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45228"></a>
Way
<a name="45229"></a>Out
</pre><a name="45230"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45231"></a>
abstract class Super {
<a name="45232"></a>	abstract void out();
<a name="45233"></a>}
</pre><a name="45234"></a>
If <code>Super</code> is recompiled but not <code>Test</code>, then running the new binary with the existing
binary of <code>Test</code> results in a <code>AbstractMethodError</code>, because class <code>Test</code> has no 
implementation of the method <code>out</code>, and is therefore is (or should be) abstract. (An 
early version of Java incorrectly produced the output:
<p><pre><a name="45235"></a>Way
</pre><a name="45236"></a>
before encountering an <code>AbstractMethodError</code> while invoking the method <code>out</code>, 
incorrectly allowing the class <code>Test</code> to be prepared even though it has an <code>abstract</code> 
method and is not declared <code>abstract</code>.)
<p><a name="45238"></a>
<h3>13.4.16    <code>final</code> Methods</h3>
<a name="45239"></a>
Changing an instance method that is not <code>final</code> to be <code>final</code> may break compatibility
with existing binaries that depend on the ability to override the method. If 
the test program:
<p><pre><a name="45240"></a>class Super { void out() { System.out.println("out"); } }
<a name="45241"></a>class Test extends Super {
</pre><pre><a name="45242"></a>
	public static void main(String[] args) {
<a name="45243"></a>		Test t = new Test();
<a name="45244"></a>		t.out();
<a name="45245"></a>	}
<a name="45246"></a>	void out() { super.out(); }
<a name="45247"></a>}
</pre><a name="45248"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45249"></a>out
</pre><a name="45250"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45251"></a>class Super { final void out() { System.out.println("!"); } }
</pre><a name="45252"></a>
If <code>Super</code> is recompiled but not <code>Test</code>, then running the new binary with the existing
binary of <code>Test</code> results in a <code>VerifyError</code> because the class <code>Test</code> improperly 
tries to override the instance method <code>out</code>.
<p><a name="45253"></a>
Changing a class (<code>static</code>) method that is not <code>final</code> to be <code>final</code> does not break compatibility with existing binaries, because the class of the actual method to be invoked is resolved at compile time.<p>
<a name="45254"></a>
Removing the <code>final</code> modifier from a method does not break compatibility with pre-existing binaries.<p>
<a name="45255"></a>
<h3>13.4.17    <code>native</code> Methods</h3>
<a name="45256"></a>
Adding or deleting a <code>native</code> modifier of a method does not break compatibility 
with pre-existing binaries.
<p><a name="46194"></a>
The impact of changes to Java types on preexisting <code>native</code> methods that are not recompiled is beyond the scope of this specification and should be provided with the description of an implementation of Java. Implementations are encouraged, but not required, to implement <code>native</code> methods in a way that limits such impact.<p>
<a name="45257"></a>
<h3>13.4.18    <code>static</code> Methods</h3>
<a name="45258"></a>
If a method that is not declared <code>private</code> was declared <code>static</code> (that is, a class 
method) and is changed to not be declared <code>static</code> (that is, to an instance method), 
or vice versa, then compatibility with pre-existing binaries may be broken, resulting
in a linkage time error, namely an <code>IncompatibleClassChangeError</code>, if these 
methods are used by the pre-existing binaries. Such changes are not recommended 
in code that has been widely distributed.
<p><a name="45259"></a>
<h3>13.4.19    <code>synchronized</code> Methods</h3>
<a name="45260"></a>
Adding or deleting a <code>synchronized</code> modifier of a method does not break compatibility
with existing binaries.
<p><a name="45262"></a>
<h3>13.4.20    Method and Constructor Throws</h3>
<a name="45263"></a>
Changes to the <code>throws</code> clause of methods or constructors do not break compatibility
with existing binaries; these clauses are checked only at compile time.
<p><a name="45264"></a>
We are considering whether a future version of the Java language should require more rigorous checking of <code>throws</code> clauses when classes are verified.<p>
<a name="45265"></a>
<h3>13.4.21    Method and Constructor Body</h3>
<a name="45266"></a>
Changes to the body of a method or constructor do not break compatibility with 
pre-existing binaries.
<p><a name="45267"></a>
We note that a compiler cannot inline expand a method at compile time unless, for example, either:<p>
<ul><a name="45268"></a>
<li>the method is <code>private</code> to its class
<a name="45269"></a>
<li>an entire package is guaranteed to be kept together and the method is accessible only within that package
<a name="45270"></a>
<li>a set of Java code is being compiled to a special binary format where the specified method is available only within a binary or set of binaries which are being kept together.
</ul><a name="45271"></a>
The keyword <code>final</code> on a method does not mean that the method can be safely 
inlined; it only means that the method cannot be overridden. Unless the compiler 
has extraordinary knowledge, it is still possible that a new version of that method 
will be provided at link time.
<p><a name="45272"></a>
In general we suggest that Java implementations use late-bound (run-time) code generation and optimization.<p>
<a name="45274"></a>
<h3>13.4.22    Method and Constructor Overloading</h3>
<a name="45275"></a>
Adding new methods that overload existing method names does not break compatibility
with pre-existing binaries. The method signature to be used for each 
method invocation was determined when these existing binaries were compiled; 
therefore newly added methods will not be used, even if their signatures are both 
applicable and more specific than the method signature originally chosen.
<p><a name="45276"></a>
While adding a new overloaded method or constructor may cause a compile-time error the next time a class or interface is compiled because there is no method or constructor that is most specific <a href="15.doc.html#18428">(&#167;15.11.2.2)</a>, no such error occurs when a Java program is executed, because no overload resolution is done at execution time.<p>
<a name="45280"></a>
If the example program:<p>
<pre><a name="45281"></a>
class Super {
<a name="45282"></a>	static void out(float f) { System.out.println("float"); }
<a name="45283"></a>}
<a name="45284"></a>
class Test {
<a name="45285"></a>	public static void main(String[] args) {
<a name="45286"></a>		Super.out(2);
<a name="45287"></a>	}
<a name="45288"></a>}
</pre><a name="45289"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45290"></a>float
</pre><a name="45291"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45292"></a>
class Super {
<a name="45293"></a>	static void out(float f) { System.out.println("float"); }
<a name="45294"></a>	static void out(int i) { System.out.println("int"); }
<a name="45295"></a>}
</pre><a name="45296"></a>
If <code>Super</code> is recompiled but not <code>Test</code>, then running the new binary with the existing
binary of <code>Test</code> still produces the output:
<p><pre><a name="45297"></a>float
</pre><a name="45298"></a>
However, if <code>Test</code> is then recompiled, using this new <code>Super</code>, the output is then:
<p><pre><a name="45299"></a>int
</pre><a name="45300"></a>
as might have been naively expected in the previous case.
<p><a name="45301"></a>
<h3>13.4.23    Method Overriding</h3>
<a name="45302"></a>
If an instance method is added to a subclass and it overrides a method in a superclass,
then the subclass method will be found by method invocations in pre-existing
binaries, and these binaries are not impacted. If a class method is added to a 
class, then this method will not be found, because the invocation of a class method 
is resolved at compile time to use the fully qualified name of the class where the 
method is declared. Thus if the example:
<p><pre><a name="45303"></a>
class Hyper {
<a name="45304"></a>	void hello() { System.out.print("Hello, "); }
<a name="45305"></a>	static void world() { System.out.println("world!"); }
<a name="45306"></a>}
<a name="45307"></a>class Super extends Hyper { }
<a name="45308"></a>
class Test {
<a name="45309"></a>	public static void main(String[] args) {
<a name="45310"></a>		Super s = new Super();
<a name="45311"></a>		s.hello();
<a name="45312"></a>		s.world();
<a name="45313"></a>	}
<a name="45314"></a>}
</pre><a name="45315"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45316"></a>Hello, world!
</pre><a name="45317"></a>
Suppose that a new version of class <code>Super</code> is produced:
<p><pre><a name="45318"></a>
class Super extends Hyper {
<a name="45319"></a>	void hello() { System.out.print("Goodbye, cruel "); }
<a name="45320"></a>	static void world() { System.out.println("earth!"); }
<a name="45321"></a>}
</pre><a name="45322"></a>
If <code>Super</code> is recompiled but not <code>Hyper</code> or <code>Test</code>, then running the new binary with 
the existing binaries for <code>Hyper</code> and <code>Test</code> will produce the output:
<p><pre><a name="45323"></a>Goodbye, cruel world!
</pre><a name="45324"></a>
This example demonstrates that the invocation in:
<p><pre><a name="45325"></a>s.world();
</pre><a name="45326"></a>
in the method <code>main</code> is resolved, at compile time, to a symbolic reference to the 
class containing the class method <code>world</code>, as though it had been written:
<p><pre><a name="45327"></a>Hyper.world();
</pre><a name="45328"></a>
This is why the <code>world</code> method of <code>Hyper</code> rather than <code>Super</code> is invoked in this 
example. Of course, recompiling all the classes to produce new binaries will allow 
the output:
<p><pre><a name="45329"></a>Goodbye, cruel earth!
</pre><a name="45330"></a>
to be produced.
<p><a name="45331"></a>
<h3>13.4.24    Static Initializers</h3>
<a name="45335"></a>
Adding, deleting, or changing a static initializer <a href="8.doc.html#39245">(&#167;8.5)</a> of a class does not impact 
pre-existing binaries.
<p><a name="45337"></a>
<h2>13.5    Evolution of Interfaces</h2>
<a name="45338"></a>
This section describes the impact of changes to the declaration of an interface and 
its members on pre-existing binaries.
<p><a name="45339"></a>
<h3>13.5.1    <code>public</code> Interfaces</h3>
<a name="45340"></a>
Changing an interface that is not declared <code>public</code> to be declared <code>public</code> does not 
break compatibility with pre-existing binaries.
<p><a name="45341"></a>
If an interface that is declared <code>public</code> is changed to not be declared <code>public</code>, then an <code>IllegalAccessError</code> is thrown if a pre-existing binary is linked that needs but no longer has access to the interface type, so such a change is not recommended for widely distributed interfaces.<p>
<a name="45342"></a>
<h3>13.5.2    Superinterfaces</h3>
<a name="45343"></a>
Changes to the interface hierarchy cause errors in the same way that changes to 
the class hierarchy do, as described in <a href="13.doc.html#44994">&#167;13.4.4</a>. In particular, changes that result in 
any previous superinterface of a class no longer being a superinterface can break 
compatibility with pre-existing binaries, resulting in a <code>VerifyError</code>.
<p><a name="45347"></a>
<h3>13.5.3    The Interface Members</h3>
<a name="45348"></a>
Adding a member to an interface does not break compatibility with pre-existing 
binaries.
<p><a name="45349"></a>
Deleting a member from an interface may cause linkage errors in pre-existing binaries. If the example program:<p>
<pre><a name="45350"></a>interface I { void hello(); }
<a name="45351"></a>class Test implements I {
</pre><pre><a name="45352"></a>
	public static void main(String[] args) {
<a name="45353"></a>		I anI = new Test();
<a name="45354"></a>		anI.hello();
<a name="45355"></a>	}
<a name="45356"></a>	public void hello() { System.out.println("hello"); }
<a name="45357"></a>}
</pre><a name="45358"></a>
is compiled and executed, it produces the output:
<p><pre><a name="45359"></a>hello
</pre><a name="45360"></a>
Suppose that a new version of interface <code>I</code> is compiled:
<p><pre><a name="45361"></a>interface I { }
</pre><a name="45362"></a>
If <code>I</code> is recompiled but not <code>Test</code>, then running the new binary with the existing 
binary for <code>Test</code> will result in a <code>NoSuchMethodError</code>. (In some early implementations
of Java this program still executed; the fact that the method <code>hello</code> no longer 
exists in interface <code>I</code> was not correctly detected.)
<p><a name="45363"></a>
<h3>13.5.4    Field Declarations</h3>
<a name="45364"></a>
The considerations for changing field declarations in interfaces are the same as 
those for <code>static</code> <code>final</code> fields in classes, as described in <a href="13.doc.html#45118">&#167;13.4.7</a> and <a href="13.doc.html#45139">&#167;13.4.8</a>.
<p><a name="45371"></a>
<h3>13.5.5    Abstract Method Declarations</h3>
<a name="46514"></a>
The considerations for changing abstract method declarations in interfaces are the 
same as those for <code>abstract</code> methods in classes, as described in <a href="13.doc.html#45202">&#167;13.4.13</a>, 
<a href="13.doc.html#45208">&#167;13.4.14</a>, <a href="13.doc.html#45262">&#167;13.4.20</a>, and <a href="13.doc.html#45274">&#167;13.4.22</a>.
<p><a name="55303"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="12.doc.html">Prev</a> | <a href="14.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>