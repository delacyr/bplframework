<html>
<head>
<title>The Java Language Specification
 Types, Values, and Variables</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="3.doc.html">Prev</a> | <a href="5.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="95843"></a>
<p><strong>
CHAPTER
 4 </strong></p>
<a name="95845"></a>
<h1>Types, Values, and Variables</h1>
<hr><p>
<a name="45200"></a>
Java is a <i>strongly typed</i> language, which means that every variable and every 
expression has a type that is known at compile time. Types limit the values that a 
variable <a href="4.doc.html#18470">(&#167;4.5)</a> can hold or that an expression can produce, limit the operations 
supported on those values, and determine the meaning of the operations. Strong 
typing helps detect errors at compile time.
<p><a name="50743"></a>
The types of the Java language are divided into two categories: primitive types and reference types. The primitive types <a href="4.doc.html#85587">(&#167;4.2)</a> are the <code>boolean</code> type and the numeric types. The numeric types are the integral types <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>char</code>, and the floating-point types <code>float</code> and <code>double</code>. The reference types <a href="4.doc.html#9317">(&#167;4.3)</a> are class types, interface types, and array types. There is also a special null type. An object <a href="4.doc.html#12028">(&#167;4.3.1)</a> in Java is a dynamically created instance of a class type or a dynamically created array. The values of a reference type are references to objects. All objects, including arrays, support the methods of class <code>Object</code> <a href="4.doc.html#11055">(&#167;4.3.2)</a>. String literals are represented by <code>String</code> objects <a href="4.doc.html#26992">(&#167;4.3.3)</a>.<p>
<a name="50838"></a>
Types are the same <a href="4.doc.html#52197">(&#167;4.3.4)</a> if they have the same fully qualified names and are loaded by the same class loader. Names of types are used <a href="4.doc.html#25948">(&#167;4.4)</a> in declarations, in casts, in class instance creation expressions, in array creation expressions, and in <code>instanceof</code> operator expressions.<p>
<a name="50800"></a>
A variable <a href="4.doc.html#18470">(&#167;4.5)</a> is a storage location. A variable of a primitive type always holds a value of that exact type. A variable of a class type <i>T</i><em></em> can hold a null reference or a reference to an instance of class <i>T</i><em></em> or of any class that is a subclass of <i>T</i>. A variable of an interface type can hold a null reference or a reference to any instance of any class that implements the interface. If <i>T</i> is a primitive type, then a variable of type "array of <i>T</i><em></em>" can hold a null reference or a reference to any array of type "array of <i>T</i><em></em>"; if <i>T</i> is a reference type, then a variable of type "array of <i>T</i><em></em>" can hold a null reference or a reference to any array of type "array of <i>S</i><em></em>" such that type <i>S</i><em></em> is assignable <a href="5.doc.html#170768">(&#167;5.2)</a> to type <i>T</i><em></em>. A variable of type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array.<p>
<a name="11128"></a>
<h2>4.1    The Kinds of Types and Values</h2>
<a name="10737"></a>
There are two kinds of <i>types</i> in Java: primitive types <a href="4.doc.html#85587">(&#167;4.2)</a> and reference types 
<a href="4.doc.html#9317">(&#167;4.3)</a>. There are, correspondingly, two kinds of data values that can be stored in 
variables, passed as arguments, returned by methods, and operated on: primitive 
values <a href="4.doc.html#85587">(&#167;4.2)</a> and reference values <a href="4.doc.html#9317">(&#167;4.3)</a>.
<p><ul><pre>
<i>Type:<br>
</i>	<i>PrimitiveType<br>
	ReferenceType
</i></pre></ul><a name="23953"></a>
There is also a special <i>null type</i>, the type of the expression <code>null</code>, which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be cast to any reference type. In practice, the Java programmer can ignore the null type and just pretend that <code>null</code> is merely a special literal that can be of any reference type.<p>
<a name="85587"></a>
<h2>4.2    Primitive Types and Values</h2>
<a name="9122"></a>
A <i>primitive type</i> is predefined by the Java language and named by its reserved 
keyword <a href="3.doc.html#229308">(&#167;3.9)</a>:
<p><ul><pre>
<i>PrimitiveType:<br>
	NumericType<br>
	</i><code>boolean
</code>
<i>NumericType:<br>
	IntegralType<br>
	FloatingPointType
</i>
<i>IntegralType:</i> <i>one</i> <i>of<br>
</i>	<code>byte short int long char
</code>
<i>FloatingPointType:</i> <i>one</i> <i>of<br>
</i><code>	float double
</code></pre></ul><a name="50919"></a>
Primitive values do not share state with other primitive values. A variable whose type is a primitive type always holds a primitive value of that same type. The value of a variable of primitive type can be changed only by assignment operations on that variable.<p>
<a name="9137"></a>
The <i>numeric types</i> are the integral types and the floating-point types. <p>
<a name="88061"></a>
The <i>integral types</i> are <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code>, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two's-complement integers, respectively, and <code>char</code>, whose values are 16-bit unsigned integers representing Unicode characters.<p>
<a name="88062"></a>
The <i>floating-point types</i> are <code>float</code>, whose values are 32-bit IEEE 754 floating-point numbers, and <code>double</code>, whose values are 64-bit IEEE 754 floating-point numbers.<p>
<a name="50913"></a>
The <code>boolean</code> type has exactly two values: <code>true</code> and <code>false.</code><p>
<a name="9151"></a>
<h3>4.2.1    Integral Types and Values</h3>
<a name="50950"></a>
The values of the integral types are integers in the following ranges:
<p><ul><a name="9163"></a>
<li>For <code>byte</code>, from -128 to 127, inclusive
<a name="9164"></a>
<li>For <code>short</code>, from -32768 to 32767, inclusive
<a name="9165"></a>
<li>For <code>int</code>, from -2147483648 to 2147483647, inclusive
<a name="9166"></a>
<li>For <code>long</code>, from -9223372036854775808 to 9223372036854775807, inclusive
<a name="51034"></a>
<li>For <code>char</code>, from <code>'\u0000'</code> to <code>'\uffff'</code> inclusive, that is, from 0 to 65535
</ul><a name="51035"></a>
<h3>4.2.2    Integer Operations</h3>
<a name="29775"></a>
Java provides a number of operators that act on integral values:
<p><ul><a name="10358"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="9181"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="15.doc.html#153654">(&#167;15.19.1)</a>
<a name="17601"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="15.doc.html#5198">(&#167;15.20.1)</a>
</ul>
<a name="10365"></a>
<li>The numerical operators, which result in a value of type <code>int</code> or <code>long</code>:
<ul>
<a name="18334"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="15.doc.html#24924">&#167;15.14.3</a>, <a href="15.doc.html#236345">&#167;15.14.4</a>)
<a name="17539"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="15.doc.html#239829">(&#167;15.16)</a>
<a name="19482"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="15.doc.html#13510">(&#167;15.17.2)</a>
<a name="24026"></a>
<li>The increment operator <code>++</code>, both prefix <a href="15.doc.html#39547">(&#167;15.14.1)</a> and postfix <a href="15.doc.html#39438">(&#167;15.13.2)</a>
<a name="24036"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="15.doc.html#239136">(&#167;15.14.2)</a> and postfix <a href="15.doc.html#4987">(&#167;15.13.3)</a>
<a name="19496"></a>
<li>The signed and unsigned shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> <a href="15.doc.html#5121">(&#167;15.18)</a>
<a name="51061"></a>
<li>The bitwise complement operator <code>~</code> <a href="15.doc.html#5017">(&#167;15.14.5)</a>
<a name="17770"></a>
<li>The integer bitwise operators <code>&amp;</code>, <code>|</code>, and <code>^</code> <a href="15.doc.html#5233">(&#167;15.21.1)</a>
</ul>
<a name="19469"></a>
<li>The conditional operator <code>? :</code> <a href="15.doc.html#5257">(&#167;15.24)</a>
<a name="18373"></a>
<li>The cast operator, which can convert from an integral value to a value of any specified numeric type (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>)
<a name="17774"></a>
<li>The string concatenation operator <code>+</code> <a href="15.doc.html#39990">(&#167;15.17.1)</a>, which, when given a <code>String</code> operand and an integral operand, will convert the integral operand to a <code>String</code> representing its value in decimal form, and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="51025"></a>
Other useful constructors, methods, and constants are predefined in the classes 
<code>Integer</code> <a href="javalang.doc6.html#14348">(&#167;20.7)</a>, <code>Long</code> <a href="javalang.doc7.html#46750">(&#167;20.8)</a>, and <code>Character</code> <a href="javalang.doc4.html#14345">(&#167;20.5)</a>.
<p><a name="28057"></a>
If an integer operator other than a shift operator has at least one operand of type <code>long</code>, then the operation is carried out using 64-bit precision, and the result of the numerical operator is of type <code>long</code>. If the other operand is not <code>long</code>, it is first widened <a href="5.doc.html#25222">(&#167;5.1.2)</a> to type <code>long</code> by numeric promotion <a href="5.doc.html#26917">(&#167;5.6)</a>. Otherwise, the operation is carried out using 32-bit precision, and the result of the numerical operator is of type <code>int</code>. If either operand is not an <code>int</code>, it is first widened to type <code>int</code> by numeric promotion.<p>
<a name="9194"></a>
The built-in integer operators do not indicate overflow or underflow in any way. The only numeric operators that can throw an exception <a href="11.doc.html#44043">(&#167;11)</a> are the integer divide operator <code>/</code> <a href="15.doc.html#5047">(&#167;15.16.2)</a> and the integer remainder operator <code>%</code> <a href="15.doc.html#24956">(&#167;15.16.3)</a>, which throw an <code>ArithmeticException</code> if the right-hand operand is zero. <p>
<a name="86654"></a>
The example:<p>
<pre><a name="51117"></a>
class Test {
<a name="51118"></a>	public static void main(String[] args) {
<a name="51119"></a>		int i = 1000000;
<a name="51254"></a>		System.out.println(i * i);
<a name="51216"></a>		long l = i;
<a name="86535"></a>		System.out.println(l * l);
<a name="86536"></a>		System.out.println(20296 / (l - i));
<a name="86537"></a>	}
<a name="86538"></a>}
</pre><a name="51131"></a>
produces the output:
<p><pre><a name="51149"></a>
-727379968
<a name="51133"></a>1000000000000
</pre><a name="51199"></a>
and then encounters an <code>ArithmeticException</code> in the division by <code>l</code> <code>-</code> <code>i</code>, because 
<code>l</code> <code>-</code> <code>i</code> is zero. The first multiplication is performed in 32-bit precision, whereas the 
second multiplication is a <code>long</code> multiplication. The value <code>-727379968</code> is the decimal
value of the low 32 bits of the mathematical result, <code>1000000000000</code>, which is 
a value too large for type <code>int</code>.
<p><a name="51203"></a>
Any value of any integral type may be cast to or from any numeric type. There are no casts between integral types and the type <code>boolean</code>.<p>
<a name="9208"></a>
<h3>4.2.3    Floating-Point Types and Values</h3>
<a name="87606"></a>
The floating-point types are <code>float</code> and <code>double</code>, representing the single-precision 
32-bit and double-precision 64-bit format IEEE 754 values and operations as 
specified in <i>IEEE Standard for Binary Floating-Point Arithmetic</i>, ANSI/IEEE 
Standard 754-1985 (IEEE, New York).
<p><a name="88071"></a>
The IEEE 754 standard includes not only positive and negative sign-magnitude numbers, but also positive and negative zeros, positive and negative <i>infinities</i>, and a special <i>Not-a-Number </i>(hereafter abbreviated NaN). The NaN value is used to represent the result of certain operations such as dividing zero by zero. NaN constants of both <code>float</code> and <code>double</code> type are predefined as <code>Float.NaN</code> <a href="javalang.doc8.html#1411">(&#167;20.9.5)</a> and <code>Double.NaN</code> <a href="javalang.doc9.html#13844">(&#167;20.10.5)</a>.<p>
<a name="9219"></a>
The finite nonzero values of type <code>float</code> are of the form <img src="4.doc.anc.gif">, where <i>s</i> is +1 or -1, <i>m</i> is a positive integer less than <img src="4.doc.anc2.gif">, and <i>e</i> is an integer between -149 and 104, inclusive. Values of that form such that <i>m</i> is positive but less than <img src="4.doc.anc5.gif"> and <i>e</i> is equal to -149 are said to be <i>denormalized</i>.<p>
<a name="9223"></a>
The finite nonzero values of type <code>double</code> are of the form <img src="4.doc.anc1.gif">, where <i>s</i> is +1 or -1, <i>m</i> is a positive integer less than <img src="4.doc.anc3.gif">, and <i>e</i> is an integer between -1075 and 970, inclusive. Values of that form such that <i>m</i> is positive but less than <img src="4.doc.anc6.gif"> and <i>e</i> is equal to -1075 are said to be <i>denormalized</i>.<p>
<a name="86665"></a>
Except for NaN, floating-point values are <i>ordered</i>; arranged from smallest to largest, they are negative infinity, negative finite nonzero values, negative zero, positive zero, positive finite nonzero values, and positive infinity.<p>
<a name="86666"></a>
Positive zero and negative zero compare equal; thus the result of the expression <code>0.0==-0.0</code> is <code>true</code> and the result of <code>0.0&gt;-0.0</code> is <code>false</code>. But other operations can distinguish positive and negative zero; for example, <code>1.0/0.0</code> has the value positive infinity, while the value of <code>1.0/-0.0</code> is negative infinity. The operations <code>Math.min</code> and <code>Math.max</code> also distinguish positive zero and negative zero.<p>
<a name="16083"></a>
NaN is <i>unordered</i>, so the numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> return <code>false</code> if either or both operands are NaN <a href="15.doc.html#153654">(&#167;15.19.1)</a>. The equality operator <code>==</code> returns <code>false</code> if either operand is NaN, and the inequality operator <code>!=</code> returns <code>true</code> if either operand is NaN <a href="15.doc.html#5198">(&#167;15.20.1)</a>. In particular, <code>x!=x</code> is <code>true</code> if and only if <code>x</code> is NaN, and <code>(x&lt;y)</code> <code>==</code> <code>!(x&gt;=y)</code> will be <code>false</code> if <code>x</code> or <code>y</code> is NaN.<p>
<a name="16093"></a>
Any value of a floating-point type may be cast to or from any numeric type. There are no casts between floating-point types and the type <code>boolean</code>.<p>
<a name="9249"></a>
<h3>4.2.4    Floating-Point Operations</h3>
<a name="9981"></a>
Java provides a number of operators that act on floating-point values:
<p><ul><a name="52058"></a>
<li>The comparison operators, which result in a value of type <code>boolean</code>:
<ul>
<a name="52062"></a>
<li>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> <a href="15.doc.html#153654">(&#167;15.19.1)</a>
<a name="52066"></a>
<li>The numerical equality operators <code>==</code> and <code>!=</code> <a href="15.doc.html#5198">(&#167;15.20.1)</a>
</ul>
<a name="52069"></a>
<li>The numerical operators, which result in a value of type <code>float</code> or <code>double</code>:
<ul>
<a name="52076"></a>
<li>The unary plus and minus operators <code>+</code> and <code>-</code> (<a href="15.doc.html#24924">&#167;15.14.3</a>, <a href="15.doc.html#236345">&#167;15.14.4</a>)
<a name="24115"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> <a href="15.doc.html#239829">(&#167;15.16)</a>
<a name="24119"></a>
<li>The additive operators <code>+</code> and <code>-</code> <a href="15.doc.html#13510">(&#167;15.17.2)</a>
<a name="24126"></a>
<li>The increment operator <code>++</code>, both prefix <a href="15.doc.html#39547">(&#167;15.14.1)</a> and postfix <a href="15.doc.html#39438">(&#167;15.13.2)</a>
<a name="24107"></a>
<li>The decrement operator <code>--</code>, both prefix <a href="15.doc.html#239136">(&#167;15.14.2)</a> and postfix <a href="15.doc.html#4987">(&#167;15.13.3)</a>
</ul>
<a name="19446"></a>
<li>The conditional operator <code>? :</code> <a href="15.doc.html#5257">(&#167;15.24)</a>
<a name="11998"></a>
<li>The cast operator, which can convert from a floating-point value to a value of any specified numeric type (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>)
<a name="21842"></a>
<li>The string concatenation operator <code>+</code> <a href="15.doc.html#39990">(&#167;15.17.1)</a>, which, when given a <code>String</code> operand and a floating-point operand, will convert the floating-point operand to a <code>String</code> representing its value in decimal form (without information loss), and then produce a newly created <code>String</code> by concatenating the two strings
</ul><a name="12009"></a>
Other useful constructors, methods, and constants are predefined in the classes 
<code>Float</code> <a href="javalang.doc8.html#14394">(&#167;20.9)</a>, <code>Double</code> <a href="javalang.doc9.html#14390">(&#167;20.10)</a>, and <code>Math</code> <a href="javalang.doc10.html#47547">(&#167;20.11)</a>.
<p><a name="12005"></a>
If at least one of the operands to a binary operator is of floating-point type, then the operation is a floating-point operation, even if the other is integral.<p>
<a name="51262"></a>
If at least one of the operands to a numerical operator is of type <code>double</code>, then the operation is carried out using 64-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>double</code>. (If the other operand is not a <code>double</code>, it is first widened to type <code>double</code> by numeric promotion <a href="5.doc.html#26917">(&#167;5.6)</a>.) Otherwise, the operation is carried out using 32-bit floating-point arithmetic, and the result of the numerical operator is a value of type <code>float. </code>If the other operand is not a <code>float</code>, it is first widened to type <code>float</code> by numeric promotion.<p>
<a name="9265"></a>
Operators on floating-point numbers behave exactly as specified by IEEE 754. In particular, Java requires support of IEEE 754 <i>denormalized</i> floating-point numbers and <i>gradual underflow</i>, which make it easier to prove desirable properties of particular numerical algorithms. Floating-point operations in Java do not "flush to zero" if the calculated result is a denormalized number.<p>
<a name="9274"></a>
Java requires that floating-point arithmetic behave as if every floating-point operator rounded its floating-point result to the result precision. <i>Inexact</i> results must be rounded to the representable value nearest to the infinitely precise result; if the two nearest representable values are equally near, the one with its least significant bit zero is chosen. This is the IEEE 754 standard's default rounding mode known as <i>round to nearest</i>.<p>
<a name="10346"></a>
Java uses <i>round toward zero</i> when converting a floating value to an integer <a href="5.doc.html#175672">(&#167;5.1.3)</a>, which acts, in this case, as though the number were truncated, discarding the mantissa bits. Rounding toward zero chooses at its result the format's value closest to and no greater in magnitude than the infinitely precise result.<p>
<a name="9290"></a>
Java floating-point operators produce no exceptions <a href="11.doc.html#44043">(&#167;11)</a>. An operation that overflows produces a signed infinity, an operation that underflows produces a signed zero, and an operation that has no mathematically definite result produces NaN. All numeric operations with NaN as an operand produce NaN as a result. As has already been described, NaN is unordered, so a numeric comparison operation involving one or two NaNs returns <code>false</code> and any <code>!=</code> comparison involving NaN returns <code>true</code>, including <code>x!=x</code> when <code>x</code> is NaN.<p>
<a name="9291"></a>
The example program:<p>
<pre><a name="9292"></a>
class Test {
<a name="45603"></a>
	public static void main(String[] args) {
<a name="49672"></a>
		// An example of overflow:
<a name="49673"></a>		double d = 1e308;
<a name="86539"></a>		System.out.print("overflow produces infinity: ");
<a name="86540"></a>		System.out.println(d + "*10==" + d*10);
<a name="86541"></a>
		// An example of gradual underflow:
<a name="49678"></a>		d = 1e-305 * Math.PI;
<a name="85624"></a>		System.out.print("gradual underflow: " + d + "\n &#32; &#32; &#32;");
<a name="49679"></a>		for (int i = 0; i &lt; 4; i++)
<a name="49680"></a>			System.out.print(" " + (d /= 100000));
<a name="49755"></a>		System.out.println();
<a name="49756"></a>
		// An example of NaN:
<a name="49757"></a>		System.out.print("0.0/0.0 is Not-a-Number: ");
<a name="49685"></a>		d = 0.0/0.0;
<a name="85896"></a>		System.out.println(d);
<a name="49698"></a>
		// An example of inexact results and rounding:
<a name="49701"></a>		System.out.print("inexact results with float:");
<a name="49702"></a>		for (int i = 0; i &lt; 100; i++) {
<a name="49703"></a>			float z = 1.0f / i;
<a name="49704"></a>			if (z * i != 1.0f)
<a name="49705"></a>				System.out.print(" " + i);
<a name="49706"></a>		}
<a name="20012"></a>		System.out.println();
<a name="85847"></a>
		// Another example of inexact results and rounding:
<a name="49707"></a>		System.out.print("inexact results with double:");
<a name="49708"></a>		for (int i = 0; i &lt; 100; i++) {
<a name="49709"></a>			double z = 1.0 / i;
<a name="49710"></a>			if (z * i != 1.0)
<a name="49711"></a>				System.out.print(" " + i);
<a name="49712"></a>		}
<a name="49713"></a>		System.out.println();
<a name="10212"></a>
		// An example of cast to integer rounding:
<a name="49718"></a>		System.out.print("cast to int rounds toward 0: ");
<a name="49719"></a>		d = 12345.6;
<a name="49720"></a>		System.out.println((int)d + " " + (int)(-d));
<a name="49721"></a>	}
<a name="49722"></a>}
</pre><a name="23297"></a>
produces the output:
<p><pre><a name="23314"></a>
overflow produces infinity: 1.0e+308*10==Infinity
<a name="23315"></a>gradual underflow: 3.141592653589793E-305
<a name="85613"></a>	3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
<a name="23316"></a>0.0/0.0 is Not-a-Number: NaN
<a name="23317"></a>inexact results with float: 0 41 47 55 61 82 83 94 97
<a name="23318"></a>inexact results with double: 0 49 98
<a name="23303"></a>cast to int rounds toward 0: 12345 -12345
</pre><a name="22309"></a>
This example demonstrates, among other things, that gradual underflow can result in a gradual loss of precision.<p>
<a name="11717"></a>
The inexact results when <code>i</code> is <code>0</code> involve division by zero, so that <code>z</code> becomes positive infinity, and <code>z</code> <code>*</code> <code>0</code> is NaN, which is not equal to <code>1.0</code>.<p>
<a name="11527"></a>
<h3>4.2.5    The <code>boolean</code> Type and <code>boolean</code> Values</h3>
<a name="9295"></a>
The <code>boolean</code> type represents a logical quantity with two possible values, indicated
by the literals <code>true</code> and <code>false</code> <a href="3.doc.html#49652">(&#167;3.10.3)</a>. The boolean operators are:
<p><ul><a name="17733"></a>
<li>The relational operators <code>==</code> and <code>!=</code> <a href="15.doc.html#54508">(&#167;15.20.2)</a>
<a name="17734"></a>
<li>The logical-complement operator <code>!</code> <a href="15.doc.html#13350">(&#167;15.14.6)</a>
<a name="17736"></a>
<li>The logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code> <a href="15.doc.html#5242">(&#167;15.21.2)</a>
<a name="17737"></a>
<li>The conditional-and and conditional-or operators <code>&amp;&amp;</code> <a href="15.doc.html#5247">(&#167;15.22)</a> and <code>||</code> <a href="15.doc.html#54532">(&#167;15.23)</a>
<a name="19467"></a>
<li>The conditional operator <code>? :</code> <a href="15.doc.html#5257">(&#167;15.24)</a>
<a name="21871"></a>
<li>The string concatenation operator <code>+</code> <a href="15.doc.html#39990">(&#167;15.17.1)</a>, which, when given a <code>String</code> operand and a boolean operand, will convert the boolean operand to a <code>String</code> (either <code>"true"</code> or <code>"false"</code>), and then produce a newly created <code>String</code> that is the concatenation of the two strings
</ul><a name="17738"></a>
Boolean expressions determine the control flow in several kinds of statements:
<p><ul><a name="17742"></a>
<li>The <code>if</code> statement <a href="14.doc.html#5991">(&#167;14.8)</a>
<a name="17743"></a>
<li>The <code>while</code> statement <a href="14.doc.html#237277">(&#167;14.10)</a>
<a name="17745"></a>
<li>The <code>do</code> statement <a href="14.doc.html#6045">(&#167;14.11)</a>
<a name="17747"></a>
<li>The <code>for</code> statement <a href="14.doc.html#24588">(&#167;14.12)</a>
</ul><a name="48454"></a>
A <code>boolean</code> expression also determines which subexpression is evaluated in the 
conditional <code>?&#32;:</code> operator <a href="15.doc.html#5257">(&#167;15.24)</a>.
<p><a name="48458"></a>
Only <code>boolean</code> expressions can be used in control flow statements and as the first operand of the conditional operator <code>?&#32;:</code>. An integer <code>x</code> can be converted to a <code>boolean</code>, following the C language convention that any nonzero value is <code>true</code>, by the expression <code>x!=0</code>. An object reference <code>obj</code> can be converted to a <code>boolean</code>, following &#32;the C language convention that any reference other than <code>null</code> is <code>true</code>, by the expression <code>obj!=null</code>.<p>
<a name="9299"></a>
A cast of a <code>boolean</code> value to type <code>boolean</code> is allowed <a href="5.doc.html#25209">(&#167;5.1.1)</a>; no other casts on type <code>boolean</code> are allowed. A <code>boolean</code> can be converted to a string by string conversion <a href="5.doc.html#176921">(&#167;5.4)</a>.<p>
<a name="9317"></a>
<h2>4.3    Reference Types and Values</h2>
<a name="9664"></a>
There are three kinds of <i>reference types</i>: class types <a href="8.doc.html#3857">(&#167;8)</a>, interface types <a href="9.doc.html#238678">(&#167;9)</a>, and 
array types <a href="10.doc.html#27803">(&#167;10)</a>.
<p><ul><pre>
<i>ReferenceType:<br>
	ClassOrInterfaceType<br>
	ArrayType
</i>
<i>ClassOrInterfaceType:<br>
	ClassType<br>
	InterfaceType
</i>
<i>ClassType:<br>
	TypeName
</i>
<i>InterfaceType:<br>
	TypeName
</i>
<i>ArrayType:<br>
</i>	<i>Type</i><code> [ ]
</code></pre></ul><a name="9678"></a>
Names are described in <a href="6.doc.html#48086">&#167;6</a>; type names in <a href="6.doc.html#20569">&#167;6.5</a> and, specifically, <a href="6.doc.html#21721">&#167;6.5.4</a>.
<p><a name="87599"></a>
The sample code:<p>
<pre><br><a name="10435"></a>class Point { int[] metrics; }
<br><a name="10414"></a>interface Move { void move(int deltax, int deltay); }
</pre><a name="11032"></a>
declares a class type <code>Point</code>, an interface type <code>Move</code>, and uses an array type <code>int[]</code> 
(an array of <code>int</code>) to declare the field <code>metrics</code> of the class <code>Point</code>.
<p><a name="12028"></a>
<h3>4.3.1    Objects</h3>
<a name="86707"></a>
An <i>object</i> is a <i>class</i> <i>instance</i> or an array.
<p><a name="86710"></a>
The reference values (often just <i>references</i>) are <i>pointers </i>to these objects, and a special null reference, which refers to no object.<p>
<a name="49853"></a>
A class instance is explicitly created by a class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a>, or by invoking the <code>newInstance</code> method of class <code>Class</code> <a href="javalang.doc2.html#28532">(&#167;20.3.8)</a>. An array is explicitly created by an array creation expression <a href="15.doc.html#41147">(&#167;15.8)</a>.<p>
<a name="49899"></a>
A new class instance is implicitly created when the string concatenation operator + <a href="15.doc.html#39990">(&#167;15.17.1)</a> is used in an expression, resulting in a new object of type <code>String</code> (<a href="4.doc.html#26992">&#167;4.3.3</a>, <a href="javalang.doc11.html#14460">&#167;20.12</a>). A new array object is implicitly created when an array initializer expression <a href="10.doc.html#11358">(&#167;10.6)</a> is evaluated; this can occur when a class or interface is initialized <a href="12.doc.html#44557">(&#167;12.4)</a>, when a new instance of a class is created <a href="15.doc.html#41147">(&#167;15.8)</a>, or when a local variable declaration statement is executed <a href="14.doc.html#5920">(&#167;14.3)</a>.<p>
<a name="49960"></a>
Many of these cases are illustrated in the following example:<p>
<pre><a name="49961"></a>
class Point {
<a name="51683"></a>	int x, y;
<a name="86692"></a>	Point() { System.out.println("default"); }
<a name="86696"></a>	Point(int x, int y) { this.x = x; this.y = y; }
<a name="51733"></a>
	// A Point instance is explicitly created at class initialization time:
<a name="51732"></a>	static Point origin = new Point(0,0);
<a name="51734"></a>
	// A String can be implicitly created by a + operator:
<a name="51682"></a>	public String toString() {<br>
		return "(" + x + "," + y + ")";<br>
	}
<a name="51684"></a>}
<br><a name="51685"></a>
class Test {
<a name="51686"></a>	public static void main(String[] args) {
<a name="51735"></a>		// A Point is explicitly created using newInstance:
<a name="23341"></a>		Point p = null;
<a name="23324"></a>		try {
<a name="51687"></a>			p = (Point)Class.forName("Point").newInstance();
<a name="23327"></a>		} catch (Exception e) {
<a name="23350"></a>			System.out.println(e);
<a name="23351"></a>		}
<br><a name="51738"></a>
		// An array is implicitly created by an array constructor:
<a name="51688"></a>		Point a[] = { new Point(0,0), new Point(1,1) };
<br><a name="51757"></a>
		// Strings are implicitly created by + operators:
<a name="51689"></a>		System.out.println("p: " + p);
<a name="51690"></a>		System.out.println("a: { " + a[0] + ", "<br>
										  &#32;+ a[1] + " }");
<br><a name="51745"></a>
		// An array is explicitly created by an array creation expression:
<a name="51693"></a>		String sa[] = new String[2];
<a name="51697"></a>		sa[0] = "he"; sa[1] = "llo";
<a name="51698"></a>		System.out.println(sa[0] + sa[1]);
<a name="51699"></a>	}
<a name="49976"></a>}
</pre><a name="87328"></a>
which produces the output:
<p><pre><a name="87331"></a>
default
<a name="87332"></a>p: (0,0)
<a name="87333"></a>a: { (0,0), (1,1) }
<a name="87329"></a>hello
</pre><a name="49965"></a>
The operators on references to objects are:<p>
<ul><a name="31321"></a>
<li>Field access, using either a qualified name <a href="6.doc.html#33916">(&#167;6.6)</a> or a field access expression <a href="15.doc.html#41267">(&#167;15.10)</a>
<a name="31328"></a>
<li>Method invocation <a href="15.doc.html#20448">(&#167;15.11)</a>
<a name="31378"></a>
<li>The cast operator (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>)
<a name="31345"></a>
<li>The string concatenation operator <code>+</code> <a href="15.doc.html#39990">(&#167;15.17.1)</a>, which, when given a <code>String</code> operand and a reference, will convert the reference to a <code>String</code> by invoking the <code>toString</code> method <a href="javalang.doc1.html#1152">(&#167;20.1.2)</a> of the referenced object (using <code>"null"</code> if either the reference or the result of <code>toString</code> is a null reference), and then will produce a newly created <code>String</code> that is the concatenation of the two strings
<a name="31399"></a>
<li>The <code>instanceof</code> operator <a href="15.doc.html#80289">(&#167;15.19.2)</a>
<a name="31306"></a>
<li>The reference equality operators <code>==</code> and <code>!=</code> <a href="15.doc.html#236163">(&#167;15.20.3)</a>
<a name="19595"></a>
<li>The conditional operator <code>?&#32;:</code> <a href="15.doc.html#5257">(&#167;15.24)</a>.
</ul><a name="28239"></a>
There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable's reference to the object, and then the altered state can be observed through the reference in the other variable.<p>
<a name="87600"></a>
The example program:<p>
<pre><a name="11036"></a>class Value { int val; }
</pre><pre><a name="87412"></a>
class Test {
<a name="87413"></a>	public static void main(String[] args) {
<a name="87414"></a>		int i1 = 3;
<a name="52134"></a>		int i2 = i1;
<a name="52135"></a>		i2 = 4;
<a name="50355"></a>		System.out.print("i1==" + i1);
<a name="50357"></a>		System.out.println(" but i2==" + i2);
<a name="50359"></a>		Value v1 = new Value();
<a name="50361"></a>		v1.val = 5;
<a name="52142"></a>		Value v2 = v1;
<a name="52143"></a>		v2.val = 6;
<a name="50363"></a>		System.out.print("v1.val==" + v1.val);
<a name="50365"></a>		System.out.println(" and v2.val==" + v2.val);
<a name="50367"></a>	}
<a name="50369"></a>}
</pre><a name="11050"></a>
produces the output:
<p><pre><a name="11051"></a>
i1==3 but i2==4
<a name="45608"></a>v1.val==6 and v2.val==6
</pre><a name="11053"></a>
because <code>v1.val</code> and <code>v2.val</code> reference the same instance variable <a href="4.doc.html#28536">(&#167;4.5.3)</a> in the 
one <code>Value</code> object created by the only <code>new</code> expression, while <code>i1</code> and <code>i2</code> are different
variables.
<p><a name="17783"></a>
See <a href="10.doc.html#27803">&#167;10</a> and <a href="15.doc.html#46168">&#167;15.9</a> for examples of the creation and use of arrays.<p>
<a name="17053"></a>
Each object has an associated lock <a href="17.doc.html#28460">(&#167;17.13)</a>, which is used by <code>synchronized</code> methods <a href="8.doc.html#78188">(&#167;8.4.3)</a> and the <code>synchronized</code> statement <a href="14.doc.html#79287">(&#167;14.17)</a> to provide control over concurrent access to state by multiple threads (<a href="17.doc.html#28457">&#167;17.12</a>, <a href="javalang.doc18.html#2658">&#167;20.20</a>).<p>
<a name="11055"></a>
<h3>4.3.2    The Class <code>Object</code></h3>
<a name="26999"></a>
The standard class <code>Object</code> is a superclass <a href="8.doc.html#15372">(&#167;8.1)</a> of all other classes. A variable of 
type <code>Object</code> can hold a reference to any object, whether it is an instance of a class 
or an array <a href="10.doc.html#27803">(&#167;10)</a>. All class and array types inherit the methods of class <code>Object</code>, 
which are summarized here and completely specified in <a href="javalang.doc1.html#46442">&#167;20.1</a>:
<p><pre><a name="12035"></a>package java.lang;
</pre><pre><a name="45609"></a>
public class Object {
<a name="51634"></a>	public final Class getClass() { . . . }
<a name="51635"></a>	public String toString() { . . . }
<a name="51636"></a>	public boolean equals(Object obj) { . . . }
<a name="51637"></a>	public int hashCode() { . . . }
<a name="51638"></a>	protected Object clone()
<a name="86088"></a>		throws CloneNotSupportedException { . . . }
<a name="87378"></a>	public final void wait()<br>
		throws IllegalMonitorStateException,<br>
			InterruptedException { . . . }
<a name="51641"></a>	public final void wait(long millis)
<a name="87381"></a>		throws IllegalMonitorStateException,
<a name="87383"></a>			InterruptedException { . . . }
<a name="51642"></a>	public final void wait(long millis, int nanos) { . . . }
<a name="87385"></a>		throws IllegalMonitorStateException,
<a name="87386"></a>			InterruptedException { . . . }
<a name="87373"></a>	public final void notify() { . . . }
<a name="87374"></a>		throws IllegalMonitorStateException
<a name="87387"></a>	public final void notifyAll() { . . . }
<a name="87389"></a>		throws IllegalMonitorStateException
<a name="51644"></a>	protected void finalize()
<a name="86090"></a>		throws Throwable { . . . }
<a name="51645"></a>}
</pre><a name="45610"></a>
The members of <code>Object</code> are as follows:
<p><ul><a name="12048"></a>
<li>The method <code>getClass</code> returns the <code>Class</code> <a href="javalang.doc2.html#14342">(&#167;20.3)</a> object that represents the class of the object. A <code>Class</code> object exists for each reference type. It can be used, for example, to discover the fully qualified name of a class, its members, its immediate superclass, and any interfaces that it implements. A class method that is declared <code>synchronized</code> <a href="8.doc.html#55408">(&#167;8.4.3.5)</a> synchronizes on the lock associated with the <code>Class</code> object of the class.
<a name="12066"></a>
<li>The method <code>toString</code> returns a <code>String</code> representation of the object.
<a name="12104"></a>
<li>The methods <code>equals</code> and <code>hashCode</code> are declared for the benefit of hashtables such as <code>java.util.Hashtable</code> <a href="javautil.doc6.html#7569">(&#167;21.7)</a>. The method <code>equals</code> defines a notion of object equality, which is based on value, not reference, comparison.
<a name="12115"></a>
<li>The method <code>clone</code> is used to make a duplicate of an object.
<a name="12116"></a>
<li>The methods <code>wait</code>, <code>notify</code>, and <code>notifyAll</code> are used in concurrent programming using threads, as described in <a href="17.doc.html#26250">&#167;17</a>.
<a name="12117"></a>
<li>The method <code>finalize</code> is run just before an object is destroyed and is described in <a href="12.doc.html#44748">&#167;12.6</a>.
</ul><a name="26992"></a>
<h3>4.3.3    The Class <code>String</code></h3>
<a name="27000"></a>
Instances of class <code>String</code> <a href="javalang.doc11.html#14460">(&#167;20.12)</a> represent sequences of Unicode characters. 
A &#32;<code>String</code> object has a constant (unchanging) value. String literals <a href="3.doc.html#101083">(&#167;3.10.5)</a> are 
references to instances of class <code>String</code>.
<p><a name="52188"></a>
The string concatenation operator <code>+</code> <a href="15.doc.html#39990">(&#167;15.17.1)</a> implicitly creates a new <code>String</code> object.<p>
<a name="52197"></a>
<h3>4.3.4    When Reference Types Are the Same</h3>
<a name="22319"></a>
Two reference types the <i>same type</i> if:
<p><ul><a name="86567"></a>
<li>They are both class or both interface types, are loaded by the same class loader, and have the same fully-qualified name <a href="6.doc.html#33916">(&#167;6.6)</a>, in which case they are sometimes said to be the <i>same class</i> or the <i>same interface</i>.
<a name="86576"></a>
<li>They are both array types, and have the same component type <a href="10.doc.html#27803">(&#167;10)</a>.
</ul><a name="25948"></a>
<h2>4.4    Where Types Are Used</h2>
<a name="52309"></a>
Types are used when they appear in declarations or in certain expressions.
<p><a name="85893"></a>
The following code fragment contains one or more instances of each kind of usage of a type:<p>
<pre><br><a name="52319"></a>import java.util.Random;
<br></pre><pre><a name="52320"></a>
class MiscMath {
<br><a name="19644"></a>	int divisor;
<br><a name="85892"></a>
	MiscMath(int divisor) {
<a name="85931"></a>		this.divisor = divisor;
<a name="85932"></a>	}
<br><a name="19646"></a>
	float ratio(long l) {
<a name="52325"></a>		try {
<a name="52326"></a>			l /= divisor;
<a name="52327"></a>		} catch (Exception e) {
<a name="52328"></a>			if (e instanceof ArithmeticException)
<a name="52329"></a>				l = Long.MAX_VALUE;
<a name="52330"></a>			else
<a name="52331"></a>				l = 0;
<a name="52332"></a>		}
<a name="52333"></a>		return (float)l;
<a name="52334"></a>	}
<br><a name="19664"></a>
	double gausser() {
<a name="19665"></a>		Random r = new Random();
<a name="19666"></a>		double[] val = new double[2];
<a name="19667"></a>		val[0] = r.nextGaussian();
<a name="19668"></a>		val[1] = r.nextGaussian();
<a name="19669"></a>		return (val[0] + val[1]) / 2;
<a name="19670"></a>	}
<br><a name="52342"></a>}
</pre><a name="53860"></a>
In this example, types are used in declarations of the following:
<p><ul><a name="53864"></a>
<li>Imported types <a href="7.doc.html#26656">(&#167;7.5)</a>; here the type <code>Random</code>, imported from the type<code> java.util.Random</code> of the package <code>java.util</code>, is declared
<a name="49983"></a>
<li>Fields, which are the class variables and instance variables of classes <a href="8.doc.html#40898">(&#167;8.3)</a>, and constants of interfaces <a href="9.doc.html#78642">(&#167;9.3)</a>; here the field <code>divisor</code> in the class <code>MiscMath</code> &#32;is declared to be of type <code>int</code>
<a name="49990"></a>
<li>Method parameters <a href="8.doc.html#38698">(&#167;8.4.1)</a>; here the parameter <code>l</code> of the method <code>ratio</code> is declared to be of type <code>long</code>
<a name="52378"></a>
<li>Method results <a href="8.doc.html#40420">(&#167;8.4)</a>; here the result of the method <code>ratio</code> is declared to be of type <code>float</code>, and the result of the method <code>gausser</code> is declared to be of type <code>double</code>
<a name="38145"></a>
<li>Constructor parameters <a href="8.doc.html#29488">(&#167;8.6.1)</a>; here the parameter of the constructor for<code> MiscMath</code> is declared to be of type <code>int</code>
<a name="12250"></a>
<li>Local variables (<a href="14.doc.html#5920">&#167;14.3</a>, <a href="14.doc.html#24588">&#167;14.12</a>); the local variables <code>r</code> and <code>val</code> of the method <code>gausser</code> are declared to be of types <code>Random</code> and <code>double[]</code> (array of <code>double</code>)
<a name="52411"></a>
<li>Exception handler parameters <a href="14.doc.html#79311">(&#167;14.18)</a>; here the exception handler parameter <code>e</code> of the <code>catch</code> clause is declared to be of type <code>Exception</code>
</ul><a name="25979"></a>
and in expressions of the following kinds:
<p><ul><a name="52468"></a>
<li>Class instance creations <a href="15.doc.html#41147">(&#167;15.8)</a>; here a local variable <code>r</code> of method <code>gausser</code> is initialized by a class instance creation expression that uses the type <code>Random</code>
<a name="87680"></a>
<li>Array creations <a href="15.doc.html#46168">(&#167;15.9)</a>; here the local variable <code>val</code> of method <code>gausser</code> is initialized by an array creation expression that creates an array of <code>double</code> with size 2
<a name="52427"></a>
<li>Casts <a href="15.doc.html#238146">(&#167;15.15)</a>; here the <code>return</code> statement of the method <code>ratio</code> uses the <code>float</code> type in a cast
<a name="25987"></a>
<li>The <code>instanceof</code> operator <a href="15.doc.html#80289">(&#167;15.19.2)</a>; here the <code>instanceof</code> operator tests whether <code>e</code> is assignment compatible with the type <code>ArithmeticException</code>
</ul><a name="18470"></a>
<h2>4.5    Variables</h2>
<a name="10872"></a>
A variable is a storage location and has an associated type, sometimes called its 
<i>compile-time type</i>, that is either a primitive type <a href="4.doc.html#85587">(&#167;4.2)</a> or a reference type <a href="4.doc.html#9317">(&#167;4.3)</a>. 
A variable always contains a value that is assignment compatible <a href="5.doc.html#170768">(&#167;5.2)</a> with its 
type. A variable's value is changed by an assignment <a href="15.doc.html#5281">(&#167;15.25)</a> or by a prefix or 
postfix <code>++</code> (increment) or <code>--</code> (decrement) operator (<a href="15.doc.html#39438">&#167;15.13.2</a>, <a href="15.doc.html#4987">&#167;15.13.3</a>, <a href="15.doc.html#39547">&#167;15.14.1</a>, 
<a href="15.doc.html#239136">&#167;15.14.2</a>).
<p><a name="24555"></a>
Compatibility of the value of a variable with its type is guaranteed by the design of the Java language. Default values are compatible <a href="4.doc.html#10931">(&#167;4.5.4)</a> and all assignments to a variable are checked for assignment compatibility <a href="5.doc.html#170768">(&#167;5.2)</a>, usually at compile time, but, in a single case involving arrays, a run-time check is made <a href="10.doc.html#11430">(&#167;10.10)</a>.<p>
<a name="28344"></a>
<h3>4.5.1    Variables of Primitive Type</h3>
<a name="17088"></a>
A variable of a primitive type always holds a value of that exact primitive type.
<p><a name="28345"></a>
<h3>4.5.2    Variables of Reference Type</h3>
<a name="10877"></a>
A variable of reference type can hold either of the following:
<p><ul><a name="52494"></a>
<li>A null reference
<a name="52496"></a>
<li>A reference to any object <a href="4.doc.html#9317">(&#167;4.3)</a> whose class <a href="4.doc.html#24887">(&#167;4.5.5)</a> is assignment compatible <a href="5.doc.html#170768">(&#167;5.2)</a> with the type of the variable
</ul><a name="28536"></a>
<h3>4.5.3    Kinds of Variables</h3>
<a name="10883"></a>
There are seven kinds of variables:
<p><ol>
<a name="10884"></a>
<li>A <i>class variable</i> is a field declared using the keyword <code>static</code> within a class declaration <a href="8.doc.html#37544">(&#167;8.3.1.1)</a>, or with or without the keyword <code>static</code> within an interface declaration <a href="9.doc.html#78642">(&#167;9.3)</a>. A class variable is created when its class or interface is loaded <a href="12.doc.html#44459">(&#167;12.2)</a> and is initialized to a default value <a href="4.doc.html#10931">(&#167;4.5.4)</a>. The class variable effectively ceases to exist when its class or interface is unloaded <a href="12.doc.html#44850">(&#167;12.8)</a>, after any necessary finalization of the class or interface <a href="12.doc.html#44748">(&#167;12.6)</a> has been completed.
<a name="51516"></a>
<li>An <i>instance variable</i> is a field declared within a class declaration without using the keyword <code>static</code> <a href="8.doc.html#37544">(&#167;8.3.1.1)</a>. If a class <code>T</code> has a field <i>a</i> that is an instance variable, then a new instance variable <i>a</i> is created and initialized to a default value <a href="4.doc.html#10931">(&#167;4.5.4)</a> as part of each newly created object of class <code>T</code> or of any class that is a subclass of <code>T</code> <a href="8.doc.html#21723">(&#167;8.1.3)</a>. The instance variable effectively ceases to exist when the object of which it is a field is no longer referenced, after any necessary finalization of the object <a href="12.doc.html#44748">(&#167;12.6)</a> has been completed.
<a name="10895"></a>
<li><i>Array components</i> are unnamed variables that are created and initialized to default values <a href="4.doc.html#10931">(&#167;4.5.4)</a> whenever a new object that is an array is created <a href="15.doc.html#46168">(&#167;15.9)</a>. The array components effectively cease to exist when the array is no longer referenced. See <a href="10.doc.html#27803">&#167;10</a> for a description of arrays.
<a name="24632"></a>
<li><i>Method parameters</i> <a href="8.doc.html#38698">(&#167;8.4.1)</a> name argument values passed to a method. For every parameter declared in a method declaration, a new parameter variable is created each time that method is invoked <a href="15.doc.html#20448">(&#167;15.11)</a>. The new variable is initialized with the corresponding argument value from the method invocation. The method parameter effectively ceases to exist when the execution of the body of the method is complete.
<a name="24657"></a>
<li><i>Constructor parameters</i> <a href="8.doc.html#29488">(&#167;8.6.1)</a> name argument values passed to a constructor. For every parameter declared in a constructor declaration, a new parameter variable is created each time a class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a> or explicit constructor invocation <a href="8.doc.html#78435">(&#167;8.6.5)</a> invokes that constructor. The new variable is initialized with the corresponding argument value from the creation expression or constructor invocation. The constructor parameter effectively ceases to exist when the execution of the body of the constructor is complete.
<a name="10903"></a>
<li>An <i>exception-handler parameter</i> is created each time an exception is caught by a <code>catch</code> clause of a <code>try</code> statement <a href="14.doc.html#79311">(&#167;14.18)</a>. The new variable is initialized with the actual object associated with the exception (<a href="11.doc.html#44153">&#167;11.3</a>, <a href="14.doc.html#237350">&#167;14.16</a>). The exception-handler parameter effectively ceases to exist when execution of the block associated with the <code>catch</code> clause is complete.
<a name="24801"></a>
<li><i>Local variables</i> are declared by local variable declaration statements <a href="14.doc.html#5920">(&#167;14.3)</a>. Whenever the flow of control enters a block <a href="14.doc.html#24644">(&#167;14.2)</a> or <code>for</code> statement <a href="14.doc.html#24588">(&#167;14.12)</a>, a new variable is created for each local variable declared in a local variable declaration statement immediately contained within that block or <code>for</code> statement. A local variable declaration statement may contain an expression which initializes the variable. The local variable with an initializing expression is not initialized, however, until the local variable declaration statement that declares it is executed. (The rules of definite assignment <a href="16.doc.html#25979">(&#167;16)</a> prevent the value of a local variable from being used before it has been initialized or otherwise assigned a value.) The local variable effectively ceases to exist when the execution of the block or <code>for</code> statement is complete.
</ol>
<ul><a name="24816"></a>
<br><br>Were it not for one exceptional situation, a local variable could always be regarded as being created when its local variable declaration statement is executed. The exceptional situation involves the <code>switch</code> statement <a href="14.doc.html#35518">(&#167;14.9)</a>, where it is possible for control to enter a block but bypass execution of a local variable declaration statement. Because of the restrictions imposed by the rules of definite assignment <a href="16.doc.html#">(&#167;16)</a>, however, the local variable declared by such a bypassed local variable declaration statement cannot be used before it has been definitely assigned a value by an assignment expression <a href="15.doc.html#5281">(&#167;15.25)</a>.
</ul><a name="24836"></a>
The following example contains several different kinds of variables:<p>
<pre><a name="10918"></a>
class Point {
<a name="45636"></a>	static int numPoints;								// numPoints is a class variable
<a name="50087"></a>	int x, y;								// x and y are instance variables
<a name="50089"></a>	int[] w = new int[10];								// w[0] is an array component
<a name="52523"></a>	int setX(int x) {								// x is a method parameter
<a name="52524"></a>		int oldx = this.x;							// oldx is a local variable
<a name="10925"></a>		this.x = x;
<a name="10926"></a>		return oldx;
<a name="10927"></a>	}
<a name="10928"></a>}
</pre><a name="10931"></a>
<h3>4.5.4    Initial Values of Variables</h3>
<a name="10935"></a>
Every variable in a Java program must have a value before its value is used:
<p><ul><a name="10946"></a>
<li>Each class variable, instance variable, or array component is initialized with a <i>default value</i> when it is created (<a href="15.doc.html#41147">&#167;15.8</a>, <a href="15.doc.html#46168">&#167;15.9</a>, <a href="javalang.doc2.html#15088">&#167;20.3.6</a>):
<ul>
<a name="10947"></a>
<li>For type <code>byte</code>, the default value is zero, that is, the value of <code>(byte)0</code>.
<a name="10948"></a>
<li>For type <code>short</code>, the default value is zero, that is, the value of <code>(short)0</code>.
<a name="10949"></a>
<li>For type <code>int</code>, the default value is zero, that is, <code>0</code>.
<a name="10950"></a>
<li>For type <code>long</code>, the default value is zero, that is, <code>0L</code>.
<a name="10951"></a>
<li>For type <code>float</code>, the default value is positive zero, that is, <code>0.0f</code>.
<a name="46977"></a>
<li>For type <code>double</code>, the default value is positive zero, that is, <code>0.0d</code>.
<a name="46978"></a>
<li>For type <code>char</code>, the default value is the null character, that is, '<code>\u0000</code>'.
<a name="46979"></a>
<li>For type <code>boolean</code>, the default value is <code>false</code>.
<a name="10955"></a>
<li>For all reference types <a href="4.doc.html#9317">(&#167;4.3)</a>, the default value is <code>null</code>.
</ul>
<a name="11353"></a>
<li>Each method parameter <a href="8.doc.html#38698">(&#167;8.4.1)</a> is initialized to the corresponding argument value provided by the invoker of the method <a href="15.doc.html#20448">(&#167;15.11)</a>.
<a name="38160"></a>
<li>Each constructor parameter <a href="8.doc.html#29488">(&#167;8.6.1)</a> is initialized to the corresponding argument value provided by a class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a> or explicit constructor invocation <a href="8.doc.html#78435">(&#167;8.6.5)</a>.
<a name="11354"></a>
<li>An exception-handler parameter <a href="14.doc.html#79311">(&#167;14.18)</a> is initialized to the thrown object representing the exception (<a href="11.doc.html#44153">&#167;11.3</a>, <a href="14.doc.html#237350">&#167;14.16</a>). 
<a name="11569"></a>
<li>A local variable (<a href="14.doc.html#5920">&#167;14.3</a>, <a href="14.doc.html#24588">&#167;14.12</a>) must be explicitly given a value before it is used, by either initialization <a href="14.doc.html#5920">(&#167;14.3)</a> or assignment <a href="15.doc.html#5281">(&#167;15.25)</a>, in a way that can be verified by the compiler using the rules for definite assignment <a href="16.doc.html#25979">(&#167;16)</a>.
</ul><a name="30962"></a>
The example program:
<p><pre><a name="30963"></a>
class Point {
<a name="12302"></a>	static int npoints;
<a name="12303"></a>	int x, y;
<a name="12309"></a>	Point root;
<a name="12307"></a>}
<br><a name="12308"></a>
class Test {
<a name="12310"></a>	public static void main(String[] args) {
<a name="50091"></a>		System.out.println("npoints=" + Point.npoints);
<a name="12326"></a>		Point p = new Point();
<a name="12327"></a>		System.out.println("p.x=" + p.x + ", p.y=" + p.y);
<a name="12328"></a>		System.out.println("p.root=" + p.root);
<a name="12332"></a>	}
<a name="12329"></a>}
</pre><a name="12324"></a>
prints:
<p><pre><a name="12336"></a>
npoints=0
<a name="12337"></a>p.x=0, p.y=0
<a name="12325"></a>p.root=null
</pre><a name="24882"></a>
illustrating the default initialization of <code>npoints</code>, which occurs when the class 
<code>Point</code> is prepared <a href="12.doc.html#47979">(&#167;12.3.2)</a>, and the default initialization of <code>x</code>, <code>y</code>, and <code>root</code>, which 
occurs when a new <code>Point</code> is instantiated. See <a href="12.doc.html#44410">&#167;12</a> for a full description of all 
aspects of loading, linking, and initialization of classes and interfaces, plus a 
description of the instantiation of classes to make new class instances.
<p><a name="24887"></a>
<h3>4.5.5    Variables Have Types, Objects Have Classes</h3>
<a name="24888"></a>
Every object belongs to some particular class: the class that was mentioned in the 
creation expression that produced the object, the class whose class object was 
used to invoke the <code>newInstance</code> method <a href="javalang.doc2.html#15088">(&#167;20.3.6)</a> to produce the object, or the 
<code>String</code> class for objects implicitly created by the string concatenation operator <code>+ 
</code><a href="15.doc.html#39990">(&#167;15.17.1)</a>. This class is called the <i>class of the object</i>. (Arrays also have a class, as 
described at the end of this section.) An object is said to be an instance of its class 
and of all superclasses of its class.
<p><a name="24900"></a>
(Sometimes a variable or expression is said to have a "run-time type" but that is an abuse of terminology; it refers to the class of the object referred to by the value of the variable or expression at run time, assuming that the value is not <code>null</code>. Properly speaking, type is a compile-time notion. A variable or expression has a type; an object or array has no type, but belongs to a class.)<p>
<a name="24901"></a>
The type of a variable is always declared, and the type of an expression can be deduced at compile time. The type limits the possible values that the variable can hold or the expression can produce at run time. If a run-time value is a reference that is not <code>null</code>, it refers to an object or array that has a class (not a type), and that class will necessarily be compatible with the compile-time type.<p>
<a name="24895"></a>
Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces. A variable or expression whose type is an interface type can reference any object whose class implements <a href="8.doc.html#34031">(&#167;8.1.4)</a> that interface.<p>
<a name="24918"></a>
Here is an example of creating new objects and of the distinction between the type of a variable and the class of an object:<p>
<pre><a name="52597"></a>
public interface Colorable {
<a name="24921"></a>	void setColor(byte r, byte g, byte b);
<a name="24922"></a>}
<br><a name="52598"></a>class Point { int x, y; }
<a name="52599"></a>
class ColoredPoint extends Point implements Colorable {
<br><a name="52600"></a>	byte r, g, b;
<br><a name="52601"></a>
	public void setColor(byte rv, byte gv, byte bv) {
<a name="23360"></a>		r = rv; g = gv; b = bv;
<a name="23361"></a>	}
<br><a name="52604"></a>}
<br><a name="52605"></a>
class Test {
<a name="52606"></a>	public static void main(String[] args) {
<a name="52607"></a>		Point p = new Point();
<a name="52608"></a>		ColoredPoint cp = new ColoredPoint();
<a name="52609"></a>		p = cp;
<a name="52610"></a>		Colorable c = cp;
<a name="23366"></a>	}
<a name="52611"></a>}
</pre><a name="52612"></a>
In this example:
<p><ul><a name="52613"></a>
<li>The local variable <code>p</code> of the method <code>main</code> of class <code>Test</code> has type <code>Point</code> and is initially assigned a reference to a new instance of class <code>Point</code>.
<a name="52614"></a>
<li>The local variable <code>cp</code> similarly has as its type <code>ColoredPoint</code>, and is initially assigned a reference to a new instance of class <code>ColoredPoint</code>.
<a name="52615"></a>
<li>The assignment of the value of <code>cp</code> to the variable <code>p</code> causes <code>p</code> to hold a reference to a <code>ColoredPoint</code> object. This is permitted because <code>ColoredPoint</code> is a subclass of <code>Point</code>, so the class <code>ColoredPoint</code> is assignment compatible <a href="5.doc.html#170768">(&#167;5.2)</a> with the type <code>Point</code>. A <code>ColoredPoint</code> object includes support for all the methods of a <code>Point</code>. In addition to its particular fields <code>r</code>, <code>g</code>, and <code>b</code>, it has the fields of class <code>Point</code>, namely <code>x</code> and <code>y</code>.
<a name="52586"></a>
<li>The local variable <code>c</code> has as its type the interface type <code>Colorable</code>, so it can hold a reference to any object whose class implements <code>Colorable</code>; specifically, it can hold a reference to a <code>ColoredPoint</code>.
<a name="24972"></a>
<li>Note that an expression such as "<code>new Colorable()</code>" is not valid because it is not possible to create an instance of an interface, only of a class.
</ul><a name="24976"></a>
Every array also has a class; the method <code>getClass</code> <a href="javalang.doc1.html#13783">(&#167;20.1.1)</a>, when invoked for an array object, will return a class object (of class <code>Class</code>) that represents the class of the array. The classes for arrays have strange names that are not valid Java identifiers; for example, the class for an array of <code>int</code> components has the name "<code>[I</code>" and so the value of the expression:<p>
<pre><a name="24985"></a>new int[10].getClass().getName()
</pre><a name="85679"></a>
is the string <code>"[I"</code>; see <a href="javalang.doc1.html#13783">&#167;20.1.1</a> for details.
<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="3.doc.html">Prev</a> | <a href="5.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>