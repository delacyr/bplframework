<html>
<head>
<title>The Java Language Specification
 Expressions</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="14.doc.html">Prev</a> | <a href="16.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="4709"></a>
<p><strong>
CHAPTER
 15 </strong></p>
<a name="44393"></a>
<h1>Expressions</h1>
<hr><p>
<a name="11757"></a>
Much of the work in a Java program is done by evaluating <i>expressions</i>, either 
for their side effects, such as assignments to variables, or for their values, which 
can be used as arguments or operands in larger expressions, or to affect the execution
sequence in statements, or both.
<p><a name="236101"></a>
This chapter specifies the meanings of Java expressions and the rules for their evaluation.<p>
<a name="228862"></a>
<h2>15.1    Evaluation, Denotation, and Result</h2>
<a name="228864"></a>
When an expression in a Java program is <i>evaluated</i> (<i>executed</i>), the <i>result</i> denotes 
one of three things:
<p><ul><a name="228896"></a>
<li>A variable <a href="4.doc.html#18470">(&#167;4.5)</a> (in C, this would be called an <i>lvalue</i>)
<a name="19788"></a>
<li>A value (<a href="4.doc.html#85587">&#167;4.2</a>, <a href="4.doc.html#9317">&#167;4.3</a>)
<a name="229505"></a>
<li>Nothing (the expression is said to be <code>void</code>)
</ul><a name="233971"></a>
Evaluation of an expression can also produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations.<p>
<a name="229523"></a>
An expression denotes nothing if and only if it is a method invocation <a href="15.doc.html#20448">(&#167;15.11)</a> that invokes a method that does not return a value, that is, a method declared <code>void</code> <a href="8.doc.html#40420">(&#167;8.4)</a>. Such an expression can be used only as an expression statement <a href="14.doc.html#5984">(&#167;14.7)</a>, because every other context in which an expression can appear requires the expression to denote something. An expression statement that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.<p>
<a name="39859"></a>
Each expression occurs in the declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in a constructor declaration, or in the code for a method.<p>
<a name="229188"></a>
<h2>15.2    Variables as Values</h2>
<a name="229204"></a>
If an expression denotes a variable, and a value is required for use in further evaluation,
then the value of that variable is used. In this context, if the expression 
denotes a variable or a value, we may speak simply of the <i>value</i> of the expression.
<p><a name="198550"></a>
<h2>15.3    Type of an Expression</h2>
<a name="229255"></a>
If an expression denotes a variable or a value, then the expression has a type 
known at compile time. The rules for determining the type of an expression are 
explained separately below for each kind of expression.
<p><a name="229277"></a>
The value of an expression is always assignment compatible <a href="5.doc.html#170768">(&#167;5.2)</a> with the type of the expression, just as the value stored in a variable is always compatible with the type of the variable. In other words, the value of an expression whose type is <i>T</i> is always suitable for assignment to a variable of type <i>T</i>.<p>
<a name="79417"></a>
Note that an expression whose type is a class type <i>F</i> that is declared <code>final</code> is guaranteed to have a value that is either a null reference or an object whose class is <i>F</i> itself, because <code>final</code> types have no subclasses.<p>
<a name="233992"></a>
<h2>15.4    Expressions and Run-Time Checks</h2>
<a name="233993"></a>
If the type of an expression is a primitive type, then the value of the expression is 
of that same primitive type. But if the type of an expression is a reference type, 
then the class of the referenced object, or even whether the value is a reference to 
an object rather than <code>null</code>, is not necessarily known at compile time. There are a 
few places in the Java language where the actual class of a referenced object 
affects program execution in a manner that cannot be deduced from the type of the 
expression. They are as follows:
<p><ul><a name="79422"></a>
<li>Method invocation <a href="15.doc.html#20448">(&#167;15.11)</a>. The particular method used for an invocation <code>o.m(</code>...<code>)</code> is chosen based on the methods that are part of the class or interface that is the type of <code>o</code>. For instance methods, the class of the object referenced by the run-time value of <code>o</code> participates because a subclass may override a specific method already declared in a parent class so that this overriding method is invoked. (The overriding method may or may not choose to further invoke the original overridden <code>m</code> method.)
<a name="79436"></a>
<li>The <code>instanceof</code> operator <a href="15.doc.html#80289">(&#167;15.19.2)</a>. An expression whose type is a reference type may be tested using <code>instanceof</code> to find out whether the class of the object referenced by the run-time value of the expression is assignment compatible <a href="5.doc.html#170768">(&#167;5.2)</a> with some other reference type.
<a name="35797"></a>
<li>Casting (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>). The class of the object referenced by the run-time value of the operand expression might not be compatible with the type specified by the cast. For reference types, this may require a run-time check that throws an error if the class of the referenced object, as determined at run time, is not assignment &#32;compatible <a href="5.doc.html#170768">(&#167;5.2)</a> with the target type.
<a name="35800"></a>
<li>Assignment to an array component of reference type (<a href="10.doc.html#11430">&#167;10.10</a>, <a href="15.doc.html#239587">&#167;15.12</a>, <a href="15.doc.html#5295">&#167;15.25.1</a>). The type-checking rules allow the array type <i>S</i><code>[]</code> to be treated as a subtype of <i>T</i><code>[]</code> if <i>S</i> is a subtype of <i>T</i>, but this requires a run-time check for assignment to an army component, similar to the check performed for a cast.
<a name="79438"></a>
<li>Exception handling <a href="14.doc.html#79311">(&#167;14.18)</a>. An exception is caught by a <code>catch</code> clause only if the class of the thrown exception object is an <code>instanceof</code> the type of the formal parameter of the <code>catch</code> clause.
</ul><a name="35847"></a>
The first two of the cases just listed ought never to result in detecting a type error. 
Thus, a Java run-time type error can occur only in these situations:
<p><ul><a name="79443"></a>
<li>In a cast, when the actual class of the object referenced by the value of the operand expression is not compatible with the target type specified by the cast operator (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>); in this case a <code>ClassCastException</code> is thrown.
<a name="79444"></a>
<li>In an assignment to an array component of reference type, when the actual class of the object referenced by the value to be assigned is not compatible with the actual run-time component type of the array (<a href="10.doc.html#11430">&#167;10.10</a>, <a href="15.doc.html#239587">&#167;15.12</a>, <a href="15.doc.html#5295">&#167;15.25.1</a>); in this case an <code>ArrayStoreException</code> is thrown.
<a name="79445"></a>
<li>When an exception is not caught by any <code>catch</code> handler <a href="11.doc.html#44153">(&#167;11.3)</a>; in this case the thread of control that encountered the exception first invokes the method <code>uncaughtException</code> &#32;<a href="javalang.doc19.html#2901">(&#167;20.21.31)</a> for its thread group and then terminates.
</ul><a name="79448"></a>
<h2>15.5    Normal and Abrupt Completion of Evaluation</h2>
<a name="79449"></a>
Every expression has a normal mode of evaluation in which certain computational 
steps are carried out. The following sections describe the normal mode of evaluation
for each kind of expression. If all the steps are carried out without an exception
being thrown, the expression is said to <i>complete normally</i>. 
<p><a name="217304"></a>
If, however, evaluation of an expression throws an exception, then the expression is said to <i>complete abruptly</i>. An abrupt completion always has an associated <i>reason</i>, which is always a <code>throw</code> with a given value.<p>
<a name="217294"></a>
Run-time exceptions are thrown by the predefined operators as follows:<p>
<ul><a name="43791"></a>
<li>A class instance creation expression <a href="15.doc.html#41147">(&#167;15.8)</a>, array creation expression <a href="15.doc.html#46168">(&#167;15.9)</a>, or string concatenation operatior expression <a href="15.doc.html#39990">(&#167;15.17.1)</a> throws an <code>OutOfMemoryError</code> if there is insufficient memory available.
<a name="43795"></a>
<li>An array creation expression throws an <code>ArrayNegativeSizeException</code> if the value of any dimension expression is less than zero <a href="15.doc.html#46168">(&#167;15.9)</a>.
<a name="43780"></a>
<li>A field access <a href="15.doc.html#41267">(&#167;15.10)</a> throws a <code>NullPointerException</code> if the value of the object reference &#32;expression is <code>null</code>.
<a name="43784"></a>
<li>A method invocation expression <a href="15.doc.html#20448">(&#167;15.11)</a> that invokes an instance method throws a <code>NullPointerException</code> if the target reference is <code>null</code>.
<a name="43730"></a>
<li>An array access <a href="15.doc.html#239587">(&#167;15.12)</a> throws a <code>NullPointerException</code> if the value of the array reference &#32;expression is <code>null</code>.
<a name="43758"></a>
<li>An array access <a href="15.doc.html#239587">(&#167;15.12)</a> throws an <code>IndexOutOfBoundsException</code> if the value &#32;of the array index expression is negative or greater than or equal to the <code>length</code> of the array.
<a name="217340"></a>
<li>A cast <a href="15.doc.html#238146">(&#167;15.15)</a> throws a <code>ClassCastException</code> if a cast is found to be impermissible at run time.
<a name="217346"></a>
<li>An integer division <a href="15.doc.html#5047">(&#167;15.16.2)</a> or integer remainder <a href="15.doc.html#24956">(&#167;15.16.3)</a> operator throws an <code>ArithmeticException</code> if the value of the right-hand operand expression is zero.
<a name="234027"></a>
<li>An assignment to an array component of reference type <a href="15.doc.html#5295">(&#167;15.25.1)</a> throws an <code>ArrayStoreException</code> when the value to be assigned is not compatible with the component type of the array.
</ul><a name="21217"></a>
A method invocation expression can also result in an exception being thrown if an 
exception occurs that causes execution of the method body to complete abruptly. 
A class instance creation expression can also result in an exception being thrown 
if an exception occurs that causes execution of the constructor to complete 
abruptly. Various linkage and virtual machine errors may also occur during the 
evaluation of an expression. By their nature, such errors are difficult to predict and 
difficult to handle.
<p><a name="6969"></a>
If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly. The terms "complete normally" and &#32;"complete abruptly" are also applied to the execution of statements <a href="14.doc.html#5894">(&#167;14.1)</a>. A &#32;statement may complete abruptly for a variety of reasons, not just because an exception is thrown.<p>
<a name="79456"></a>
If evaluation of an expression requires evaluation of a subexpression, abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.<p>
<a name="4779"></a>
<h2>15.6    Evaluation Order</h2>
<a name="40055"></a>
Java guarantees that the operands of operators appear to be evaluated in a specific 
<i>evaluation order</i>, namely, from left to right.
<p><a name="18532"></a>
It is recommended that Java code not rely crucially on this specification. Code is usually clearer when each expression contains at most one side effect, as its outermost &#32;operation, and when code does not depend on exactly which exception arises as a consequence of the left-to-right evaluation of expressions.<p>
<a name="18498"></a>
<h3>15.6.1    Evaluate Left-Hand Operand First</h3>
<a name="4781"></a>
The left-hand operand of a binary operator appears to be fully evaluated before 
any part of the right-hand operand is evaluated. For example, if the left-hand operand
contains an assignment to a variable and the right-hand operand contains a 
reference to that same variable, then the value produced by the reference will 
reflect the fact that the assignment occurred first.
<p><a name="18540"></a>
Thus:<p>
<pre><a name="18537"></a>
class Test {
<a name="45395"></a>	public static void main(String[] args) {
<a name="18572"></a>		int i = 2;
<a name="18538"></a>		int j = (i=3) * i;
<a name="18573"></a>		System.out.println(j);
<a name="18574"></a>	}
<a name="18575"></a>}
</pre><a name="18539"></a>
prints:
<p><pre><a name="45398"></a><code>9
</code></pre><a name="35994"></a>
It is not permitted for it to print <code>6</code> instead of <code>9</code>.
<p><a name="240786"></a>
If the operator is a compound-assignment operator <a href="15.doc.html#5304">(&#167;15.25.2)</a>, then evaluation of the left-hand operand includes both remembering the variable that the left-hand operand denotes and fetching and saving that variable's value for use in the implied combining operation. So, for example, the test program:<p>
<pre><a name="18711"></a>
class Test {
<a name="18712"></a>	public static void main(String[] args) {
<a name="18713"></a>		int a = 9;
<a name="18714"></a>		a += (a = 3);									// first example
<a name="18715"></a>		System.out.println(a);
<a name="18716"></a>		int b = 9;
<a name="18717"></a>		b = b + (b = 3);									// second example
<a name="18718"></a>		System.out.println(b);
<a name="18719"></a>	}
<a name="18720"></a>}
</pre><a name="18725"></a>
prints:
<p><pre><a name="18726"></a>
12
<a name="18727"></a>12
</pre><a name="18728"></a>
because the two assignment statements both fetch and remember the value of the 
left-hand operand, which is <code>9</code>, before the right-hand operand of the addition is 
evaluated, thereby setting the variable to <code>3</code>. It is not permitted for either example 
to produce the result <code>6</code>. Note that both of these examples have unspecified behavior
in C, according to the ANSI/ISO standard.
<p><a name="4782"></a>
If evaluation of the left-hand operand of a binary operator completes abruptly, no part of the right-hand operand appears to have been evaluated.<p>
<a name="18857"></a>
Thus, the test program:<p>
<pre><a name="18860"></a>
class Test {
<a name="18861"></a>
	public static void main(String[] args) {
<a name="18877"></a>
		int j = 1;
<a name="18863"></a>
		try {
<a name="18864"></a>			int i = forgetIt() / (j = 2);
<a name="18865"></a>		} catch (Exception e) {
<a name="36034"></a>			System.out.println(e);
<a name="18866"></a>			System.out.println("Now j = " + j);
<a name="18867"></a>		}
<a name="18868"></a>	}
<a name="18869"></a>
	static int forgetIt() throws Exception {
<a name="50187"></a>		throw new Exception("I'm outta here!");
<a name="50189"></a>	}
<a name="18870"></a>}
</pre><a name="18858"></a>
prints:
<p><pre><a name="36046"></a>
java.lang.Exception: I'm outta here!
<a name="36047"></a>Now j = 1
</pre><a name="18885"></a>
because the left-hand operand <code>forgetIt()</code> of the operator <code>/</code> throws an exception 
before the right-hand operand and its embedded assignment of <code>2</code> to <code>j</code> occurs.
<p><a name="18740"></a>
<h3>15.6.2    Evaluate Operands before Operation</h3>
<a name="18749"></a>
Java also guarantees that every operand of an operator (except the conditional 
operators <code>&amp;&amp;</code>, <code>||</code>, and <code>?</code> <code>:</code>) appears to be fully evaluated before any part of the 
operation itself is performed.
<p><a name="32910"></a>
If the binary operator is an integer division <code>/</code> <a href="15.doc.html#5047">(&#167;15.16.2)</a> or integer remainder <code>%</code> <a href="15.doc.html#24956">(&#167;15.16.3)</a>, then its execution may raise an <code>ArithmeticException</code>, but this exception is thrown only after both operands of the binary operator have been evaluated and only if these evaluations completed normally.<p>
<a name="36160"></a>
So, for example, the program:<p>
<pre><a name="36161"></a>
class Test {
<a name="36162"></a>
	public static void main(String[] args) {
<a name="36163"></a>		int divisor = 0;
<a name="36164"></a>		try {
<a name="36165"></a>			int i = 1 / (divisor * loseBig());
<a name="36166"></a>		} catch (Exception e) {
<a name="36167"></a>			System.out.println(e);
<a name="36168"></a>		}
<a name="36169"></a>	}
<br><a name="36170"></a>
	static int loseBig() throws Exception {
<a name="36171"></a>		throw new Exception("Shuffle off to Buffalo!");
<a name="36172"></a>	}
<br><a name="36173"></a>}
</pre><a name="36174"></a>
always prints:
<p><pre><a name="36175"></a>java.lang.Exception: Shuffle off to Buffalo!
</pre><a name="36176"></a>
and not:
<p><pre><a name="36177"></a>java.lang.ArithmeticException: / by zero
</pre><a name="36178"></a>
since no part of the division operation, including signaling of a divide-by-zero 
exception, may appear to occur before the invocation of <code>loseBig</code> completes, even 
though the implementation may be able to detect or infer that the division operation
would certainly result in a divide-by-zero exception.
<p><a name="23213"></a>
<h3>15.6.3    Evaluation Respects Parentheses and Precedence</h3>
<a name="23217"></a>
Java implementations must respect the order of evaluation as indicated explicitly 
by parentheses and implicitly by operator precedence. An implementation may 
not take advantage of algebraic identities such as the associative law to rewrite 
expressions into a more convenient computational order unless it can be proven 
that the replacement expression is equivalent in value and in its observable side 
effects, even in the presence of multiple threads of execution (using the thread 
execution model in <a href="17.doc.html#26250">&#167;17</a>), for all possible computational values that might be 
involved.
<p><a name="23218"></a>
In the case of floating-point calculations, this rule applies also for infinity and not-a-number (NaN) values. For example, <code>!(x&lt;y)</code> may not be rewritten as <code>x&gt;=y</code>, because these expressions have different values if either <code>x</code> or <code>y</code> is NaN.<p>
<a name="23219"></a>
Specifically, floating-point calculations that appear to be mathematically associative are unlikely to be computationally associative. Such computations must not be naively reordered. For example, it is not correct for a Java compiler to rewrite <code>4.0*x*0.5</code> as <code>2.0*x</code>; while roundoff happens not to be an issue here, there are large values of <code>x</code> for which the first expression produces infinity (because of overflow) but the second expression produces a finite result.<p>
<a name="238102"></a>
So, for example, the test program:<p>
<pre><a name="23224"></a>
class Test {
<a name="23225"></a>
	public static void main(String[] args) {
<a name="23226"></a>		double d = 8e+307;
<a name="23227"></a>		System.out.println(4.0 * d * 0.5);
<a name="23228"></a>		System.out.println(2.0 * d);
<a name="23229"></a>	}
<a name="23230"></a>}
</pre><a name="23231"></a>
prints:
<p><pre><a name="23232"></a>
Infinity
<a name="23233"></a>1.6e+308
</pre><a name="23234"></a>
because the first expression overflows and the second does not.
<p><a name="21009"></a>
In contrast, integer addition and multiplication <i>are</i> provably associative in Java; for example <code>a+b+c</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are local variables (this simplifying assumption avoids issues involving multiple threads and <code>volatile</code> variables), will always produce the same answer whether evaluated as <code>(a+b)+c</code> or <code>a+(b+c)</code>; if the expression <code>b+c</code> occurs nearby in the code, a smart compiler may be able to use this common subexpression.<p>
<a name="23789"></a>
<h3>15.6.4    Argument Lists are Evaluated Left-to-Right</h3>
<a name="23790"></a>
In a method or constructor invocation or class instance creation expression, argument
expressions may appear within the parentheses, separated by commas. Each 
argument expression appears to be fully evaluated before any part of any argument 
expression to its right.
<p><a name="23791"></a>
Thus:<p>
<pre><a name="23792"></a>class Test {
</pre><pre><a name="50195"></a>
	public static void main(String[] args) {
<a name="23793"></a>		String s = "going, ";
<a name="23794"></a>		print3(s, s, s = "gone");
<a name="23795"></a>	}
<a name="23796"></a>
	static void print3(String a, String b, String c) {
<a name="23797"></a>		System.out.println(a + b + c);
<a name="23798"></a>	}
<a name="23799"></a>}
</pre><a name="23800"></a>
always prints:
<p><pre><a name="23801"></a>going, going, gone
</pre><a name="23802"></a>
because the assignment of the string <code>"gone"</code> to <code>s</code> occurs after the first two arguments
to <code>print3</code> have been evaluated.
<p><a name="23803"></a>
If evaluation of an argument expression completes abruptly, no part of any argument expression to its right appears to have been evaluated.<p>
<a name="23804"></a>
Thus, the example:<p>
<pre><a name="23805"></a>
class Test {
<a name="23806"></a>	static int id;
<a name="23807"></a>	public static void main(String[] args) {
<a name="23808"></a>		try {
<a name="23809"></a>			test(id = 1, oops(), id = 3);
<a name="23810"></a>		} catch (Exception e) {
<a name="23811"></a>			System.out.println(e + ", id=" + id);
<a name="23812"></a>		}
<a name="23813"></a>	}
<br><a name="23814"></a>	static int oops() throws Exception {
<a name="23815"></a>		throw new Exception("oops");
<a name="23816"></a>	}
<br><a name="23817"></a>	static int test(int a, int b, int c) {
<a name="23818"></a>		return a + b + c;
<a name="23819"></a>	}
<br><a name="23820"></a>}
</pre><a name="23821"></a>
prints:
<p><pre><a name="23822"></a>java.lang.Exception: oops, id=1
</pre><a name="23823"></a>
because the assignment of <code>3</code> to <code>id</code> is not executed.
<p><a name="23451"></a>
<h3>15.6.5    Evaluation Order for Other Expressions</h3>
<a name="23452"></a>
The order of evaluation for some expressions is not completely covered by these 
general rules, because these expressions may raise exceptional conditions at times 
that must be specified. See, specifically, the detailed explanations of evaluation 
order for the following kinds of expressions:
<p><ul><a name="23453"></a>
<li>class instance creation expressions <a href="15.doc.html#23745">(&#167;15.8.1)</a>
<a name="23469"></a>
<li>array creation expressions <a href="15.doc.html#23605">(&#167;15.9.1)</a>
<a name="23454"></a>
<li>method invocation expressions <a href="15.doc.html#45677">(&#167;15.11.4)</a>
<a name="23491"></a>
<li>array access expressions <a href="15.doc.html#23958">(&#167;15.12.1)</a>
<a name="240795"></a>
<li>assignments involving array components <a href="15.doc.html#5281">(&#167;15.25)</a>
</ul><a name="23302"></a>
<h2>15.7    Primary Expressions</h2>
<a name="36225"></a>
Primary expressions include most of the simplest kinds of expressions, from 
which all others are constructed: literals, field accesses, method invocations, and 
array accesses. A parenthesized expression is also treated syntactically as a primary
expression.
<p><ul><pre>
<i>Primary:<br>
</i>	<i>PrimaryNoNewArray<br>
</i>	<i>ArrayCreationExpression
</i>
<i>PrimaryNoNewArray:<br>
</i>	<i>Literal<br>
</i><code>	this<br>
</code>	<code>( </code><i>Expression</i><code> )<br>
</code>	<i>ClassInstanceCreationExpression<br>
</i>	<i>FieldAccess<br>
</i>	<i>MethodInvocation<br>
</i>	<i>ArrayAccess
</i></pre></ul><a name="236508"></a>
As programming language grammars go, this part of the Java grammar is unusual, in two ways. First, one might expect simple names, such as names of local variables and method parameters, to be primary expressions. For technical reasons, names are lumped together with primary expressions a little later when postfix expressions are introduced <a href="15.doc.html#36254">(&#167;15.13)</a>.<p>
<a name="19353"></a>
The technical reasons have to do with allowing left-to-right parsing of Java programs with only one-token lookahead. Consider the expressions <code>(z[3])</code> and <code>(z[])</code>. The first is a parenthesized array access <a href="15.doc.html#239587">(&#167;15.12)</a> and the second is the start of a cast <a href="15.doc.html#238146">(&#167;15.15)</a>. At the point that the look-ahead symbol is <code>[</code>, a left-to-right parse will have reduced the <code>z</code> to the nonterminal <i>Name</i>. In the context of a cast we prefer not to have to reduce the name to a <i>Primary</i>, but if <i>Name</i> were one of the alternatives for <i>Primary</i>, then we could not tell whether to do the reduction (that is, we could not determine whether the current situation would turn out to be a parenthesized array access or a cast) without looking ahead two tokens, to the token following the <code>[</code>. The Java grammar presented here avoids the problem by keeping <i>Name</i> and <i>Primary</i> separate and allowing either in certain other syntax rules (those for <i>MethodInvocation</i>, <i>ArrayAccess</i>, <i>PostfixExpression</i>, but not for <i>FieldAccess,</i> because this is covered by <i>Name</i>). This strategy effectively defers the question of whether a <i>Name</i> should be treated as a <i>Primary</i> until more context can be examined. (Other problems remain with cast expressions; see <a href="19.doc.html#44559">&#167;19.1.5</a>.)<p>
<a name="36318"></a>
The second unusual feature avoids a potential grammatical ambiguity in the expression:<p>
<pre><a name="36319"></a>new int[3][3]
</pre><a name="36320"></a>
which in Java always means a single creation of a multidimensional array, but 
which, without appropriate grammatical finesse, might also be interpreted as 
meaning the same as:
<p><pre><a name="36321"></a>(new int[3])[3]
</pre><a name="36322"></a>
This ambiguity is eliminated by splitting the expected definition of <i>Primary</i> into 
<i>Primary</i> and <i>PrimaryNoNewArray</i>. (This may be compared to the splitting of 
<i>Statement</i> into <i>Statement</i> and <i>StatementNoShortIf</i> <a href="14.doc.html#32584">(&#167;14.4)</a> to avoid the "dangling 
<code>else</code>" problem.)
<p><a name="224125"></a>
<h3>15.7.1    Literals</h3>
<a name="36407"></a>
A literal <a href="3.doc.html#48272">(&#167;3.10)</a> denotes a fixed, unchanging value.
<p><a name="36387"></a>
The following production from <a href="3.doc.html#48272">&#167;3.10</a> is repeated here for convenience:<p>
<ul><pre>
<i>Literal:<br>
	IntegerLiteral<br>
	FloatingPointLiteral<br>
	BooleanLiteral<br>
	CharacterLiteral<br>
	StringLiteral<br>
	NullLiteral
</i></pre></ul><a name="36400"></a>
The type of a literal is determined as follows:<p>
<ul><a name="43814"></a>
<li>The type of an integer literal that ends with <code>L</code> or <code>l</code> is <code>long</code>; the type of any other integer literal is <code>int</code>.
<a name="36413"></a>
<li>The type of a floating-point literal that ends with <code>F</code> or <code>f</code> is <code>float</code>; the type of any other floating-point literal is <code>double</code>.
<a name="36429"></a>
<li>The type of a boolean literal is <code>boolean</code>.
<a name="36436"></a>
<li>The type of a character literal is <code>char</code>.
<a name="36437"></a>
<li>The type of a string literal is <code>String</code>.
<a name="36411"></a>
<li>The type of the null literal <code>null</code> is the null type; its value is the null reference.
</ul><a name="36442"></a>
Evaluation of a literal always completes normally.<p>
<a name="31980"></a>
<h3>15.7.2    <code>this</code> </h3>
<a name="20069"></a>
The keyword <code>this</code> may be used only in the body of an instance method or constructor,
or in the initializer of an instance variable of a class. If it appears anywhere
else, a compile-time error occurs.
<p><a name="31983"></a>
When used as a primary expression, the keyword <code>this</code> denotes a value, that is a reference to the object for which the instance method was invoked <a href="15.doc.html#20448">(&#167;15.11)</a>, or to the object being constructed. The type of <code>this</code> is the class <i>C</i> within which the keyword <code>this</code> occurs. At run time, the class of the actual object referred to may be the class <i>C</i> or any subclass of <i>C</i>.<p>
<a name="31984"></a>
In the example:<p>
<pre><a name="31985"></a>
class IntVector {
<a name="20035"></a>	int[] v;
<a name="20033"></a>	boolean equals(IntVector other) {
<a name="20034"></a>		if (this == other)
<a name="43815"></a>			return true;
<a name="20048"></a>		if (v.length != other.v.length)
<a name="43816"></a>			return false;
<a name="20049"></a>		for (int i = 0; i &lt; v.length; i++)
<a name="20050"></a>			if (v[i] != other.v[i])
<a name="20051"></a>				return false;
<a name="20052"></a>		return true;
<a name="20053"></a>	}
<br><a name="20028"></a>}
</pre><a name="36469"></a>
the class <code>IntVector</code> implements a method <code>equals</code>, which compares two vectors. 
If the <code>other</code> vector is the same vector object as the one for which the <code>equals</code> 
method was invoked, then the check can skip the length and value comparisons. 
The <code>equals</code> method implements this check by comparing the reference to the 
<code>other</code> object to <code>this</code>.
<p><a name="20077"></a>
The keyword <code>this</code> is also used in a special explicit constructor invocation statement, which can appear at the beginning of a constructor body <a href="8.doc.html#78435">(&#167;8.6.5)</a>.<p>
<a name="236822"></a>
<h3>15.7.3    Parenthesized Expressions</h3>
<a name="236823"></a>
A parenthesized expression is a primary expression whose type is the type of the 
contained expression and whose value at run time is the value of the contained 
expression.
<p><a name="41147"></a>
<h2>15.8    Class Instance Creation Expressions</h2>
<a name="36595"></a>
A class instance creation expression is used to create new objects that are 
instances of classes.
<p><ul><pre>
<i>ClassInstanceCreationExpression:<br>
</i>	<code>new </code><i>ClassType</i><code> ( </code><i>ArgumentList</i><sub><i>opt</i></sub><code> )
</code>
<i>ArgumentList:<br>
</i>	<i>Expression<br>
</i>	<i>ArgumentList</i><code> , </code><i>Expression
</i></pre></ul><a name="224294"></a>
In a class instance creation expression, the <i>ClassType </i>must name a class that is not <code>abstract</code>. This class type is the type of the creation expression.<p>
<a name="224300"></a>
The arguments in the argument list, if any, are used to select a constructor declared in the body of the named class type, using the same matching rules as for method invocations <a href="15.doc.html#20448">(&#167;15.11)</a>. As in method invocations, a compile-time method matching error results if there is no unique constructor that is both applicable to the provided arguments and the most specific of all the applicable constructors.<p>
<a name="23745"></a>
<h3>15.8.1    Run-time Evaluation of Class Instance Creation Expressions</h3>
<a name="36655"></a>
At run time, evaluation of a class instance creation expression is as follows.
<p><a name="23746"></a>
First, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an <code>OutOfMemoryError</code> <a href="15.doc.html#36687">(&#167;15.8.2)</a>.<p>
<a name="23753"></a>
The new object contains new instances of all the fields declared in the specified class type and all its superclasses. As each new field instance is created, it is initialized to its standard default value <a href="4.doc.html#10931">(&#167;4.5.4)</a>.<p>
<a name="36584"></a>
Next, the argument list is evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.<p>
<a name="36513"></a>
Next, the selected constructor of the specified class type is invoked. This results in invoking at least one constructor for each superclass of the class type. This process can be directed by explicit constructor invocation statements <a href="8.doc.html#41652">(&#167;8.6)</a> and is described in detail in <a href="12.doc.html#44670">&#167;12.5</a>.<p>
<a name="23747"></a>
The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.<p>
<a name="36687"></a>
<h3>15.8.2    Example: Evaluation Order and Out-of-Memory Detection</h3>
<a name="36695"></a>
If evaluation of a class instance creation expression finds there is insufficient 
memory to perform the creation operation, then an <code>OutOfMemoryError</code> is thrown. 
This check occurs before any argument expressions are evaluated.
<p><a name="36696"></a>
So, for example, the test program:<p>
<pre><a name="36697"></a>
class List {
<a name="36776"></a>	int value;
<a name="36699"></a>	List next;
<a name="36700"></a>	static List head = new List(0);
<a name="36773"></a>	List(int n) { value = n; next = head; head = this; }
<a name="36701"></a>}
<a name="36702"></a>
class Test {
<a name="36703"></a>	public static void main(String[] args) {
<a name="36704"></a>		int id = 0, oldid = 0;
<a name="36706"></a>		try {
<a name="36841"></a>			for (;;) {
<a name="36707"></a>				++id;
<a name="36708"></a>				new List(oldid = id);
<a name="36847"></a>			}
<a name="36709"></a>		} catch (Error e) {
<a name="36710"></a>			System.out.println(e + ", " + (oldid==id));
<a name="36713"></a>		}
<a name="36714"></a>	}
<a name="36715"></a>}
</pre><a name="36716"></a>
prints:
<p><pre><a name="36787"></a>java.lang.OutOfMemoryError: List, false
</pre><a name="36788"></a>
because the out-or-memory condition is detected before the argument expression 
<code>oldid</code> <code>=</code> <code>id</code> is evaluated.
<p><a name="46163"></a>
Compare this to the treatment of array creation expressions <a href="15.doc.html#46168">(&#167;15.9)</a>, for which the out-of-memory condition is detected after evaluation of the dimension expressions <a href="15.doc.html#36736">(&#167;15.9.3)</a>.<p>
<a name="46168"></a>
<h2>15.9    Array Creation Expressions</h2>
<a name="46169"></a>
An array instance creation expression is used to create new arrays <a href="10.doc.html#27803">(&#167;10)</a>.
<p><ul><pre>
<i>ArrayCreationExpression:<br>
</i>	<code>new </code><i>PrimitiveType</i><code> </code><i>DimExprs</i><code> </code><i>Dims</i><sub><i>opt<br>
	</i></sub><code>new </code><i>TypeName</i><code> </code><i>DimExprs</i><code> </code><i>Dims</i><sub><i>opt
</i></sub>
<i>DimExprs:<br>
</i>	<i>DimExpr<br>
</i>	<i>DimExprs</i><code> </code><i>DimExpr
</i>
<i>DimExpr:<br>
</i>	<code>[ </code><i>Expression</i><code> ]
</code>
<i>Dims:<br>
</i>	<code>[ ]<br>
</code>	<i>Dims</i><code> [ ]
</code></pre></ul><a name="224310"></a>
An array creation expression creates an object that is a new array whose elements are of the type specified by the <i>PrimitiveType</i> or <i>TypeName</i>. The <i>TypeName</i> may name any reference type, even an <code>abstract</code> class type <a href="8.doc.html#34944">(&#167;8.1.2.1)</a> or an interface type <a href="9.doc.html#238678">(&#167;9)</a>.<p>
<a name="11508"></a>
The type of the creation expression is an array type that can denoted by a copy of the creation expression from which the <code>new</code> keyword and every <i>DimExpr</i> expression have been deleted; for example, the type of the creation expression:<p>
<pre><a name="224311"></a>new double[3][3][]
</pre><a name="224312"></a>
is:
<p><pre><a name="224313"></a>double[][][]
</pre><a name="23548"></a>
The type of each dimension expression <i>DimExpr</i> must be an integral type, or a compile-time error occurs. Each expression undergoes unary numeric promotion <a href="5.doc.html#170952">(&#167;5.6.1)</a>. The promoted type must be <code>int</code>, or a compile-time error occurs; this means, specifically, that the type of a dimension expression must not be <code>long</code>.<p>
<a name="23605"></a>
<h3>15.9.1    Run-time Evaluation of Array Creation Expressions</h3>
<a name="36668"></a>
At run time, evaluation of an array creation expression behaves as follows.
<p><a name="23552"></a>
First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated.<p>
<a name="23543"></a>
Next, the values of the dimension expressions are checked. If the value of any <i>DimExpr</i> expression is less than zero, then an <code>NegativeArraySizeException</code> is thrown.<p>
<a name="36922"></a>
Next, space is allocated for the new array. If there is insufficient space to allocate the array, evaluation of the array creation expression completes abruptly by throwing an <code>OutOfMemoryError</code>.<p>
<a name="23658"></a>
Then, if a single <i>DimExpr</i> appears, a single-dimensional array is created of the specified length, and each component of the array is initialized to its standard default value <a href="4.doc.html#10931">(&#167;4.5.4)</a>.<p>
<a name="23640"></a>
If an array creation expression contains <i>N</i> <i>DimExpr</i> expressions, then it effectively executes a set of nested loops of depth <img src="15.doc.anc7.gif"> to create the implied arrays of arrays. For example, the declaration:<p>
<pre><a name="23641"></a><code>float[][] matrix = new float[3][3];
</code></pre><a name="23642"></a>
is equivalent in behavior to:
<p><pre><a name="23643"></a>
float[][] matrix = new float[3][];
<a name="23644"></a>for (int <i>d</i> = 0; <i>d</i> &lt; matrix.length; <i>d</i>++)
<a name="50206"></a>	matrix[<i>d</i>] = new float[3];
</pre><a name="23645"></a>
and:
<p><pre><a name="23646"></a>Age[][][][][] Aquarius = new Age[6][10][8][12][];
</pre><a name="23647"></a>
is equivalent to:
<p><pre><a name="23648"></a>
Age[][][][][] Aquarius = new Age[6][][][][];
<a name="23649"></a>for (int <i>d1</i> = 0; <i>d1</i> &lt; Aquarius.length; <i>d1</i>++) {
<a name="237599"></a>	Aquarius[<i>d1</i>] = new Age[8][][][];
<a name="237600"></a>	for (int <i>d2</i> = 0; <i>d2</i> &lt; Aquarius[<i>d1</i>].length; <i>d2</i>++) {
<a name="237601"></a>		Aquarius[<i>d1</i>][<i>d2</i>] = new Age[10][][];
<a name="50214"></a>		for (int <i>d3</i> = 0; <i>d3</i> &lt; Aquarius[<i>d1</i>][<i>d2</i>].length; <i>d3</i>++) {
<a name="50216"></a>			Aquarius[<i>d1</i>][<i>d2</i>][<i>d3</i>] = new Age[12][];
<a name="50218"></a>		}
<a name="50220"></a>	}
<a name="50222"></a>}
</pre><a name="36995"></a>
with <i>d,</i> <i>d1</i>, <i>d2</i> and <i>d3</i> replaced by names that are not already locally declared. 
Thus, a single <code>new</code> expression actually creates one array of length 6, 6 arrays of 
length 10, <img src="15.doc.anc8.gif"> arrays of length 8, and <img src="15.doc.anc9.gif"> arrays of length 
12. This example leaves the fifth dimension, which would be arrays containing the 
actual array elements (references to <code>Age</code> objects), initialized only to null references.
These arrays can be filled in later by other code, such as:
<p><pre><a name="36991"></a>
Age[] Hair = { new Age("quartz"), new Age("topaz") };
<a name="36992"></a>Aquarius[1][9][6][9] = Hair;
</pre><a name="23652"></a>
A multidimensional array need not have arrays of the same length at each level; thus, a triangular matrix may be created by:<p>
<pre><a name="23653"></a>
float triang[][] = new float[100][];
<a name="23654"></a>for (int i = 0; i &lt; triang.length; i++)
<a name="50224"></a>	triang[i] = new float[i+1];
</pre><a name="23655"></a>
There is, however, no way to get this effect with a single creation expression.
<p><a name="23879"></a>
<h3>15.9.2    Example: Array Creation Evaluation Order</h3>
<a name="23883"></a>
In an array creation expression <a href="15.doc.html#46168">(&#167;15.9)</a>, there may be one or more dimension 
expressions, each within brackets. Each dimension expression is fully evaluated 
before any part of any dimension expression to its right.
<p><a name="23510"></a>
Thus:<p>
<pre><a name="23511"></a>
class Test {
<a name="23512"></a>	public static void main(String[] args) {
<a name="23513"></a>		int i = 4;
<a name="23514"></a>		int ia[][] = new int[i][i=3];
<a name="23515"></a>		System.out.println(
<a name="23516"></a>			"[" + ia.length + "," + ia[0].length + "]");
<a name="23517"></a>	}
<a name="23518"></a>}
</pre><a name="23519"></a>
prints:
<p><pre><a name="23520"></a>[4,3]
</pre><a name="23521"></a>
because the first dimension is calculated as <code>4</code> before the second dimension expression
sets <code>i</code> to <code>3</code>.
<p><a name="23522"></a>
If evaluation of a dimension expression completes abruptly, no part of any dimension expression to its right will appear to have been evaluated. Thus, the example: <p>
<pre><a name="23524"></a>
class Test {
<a name="23525"></a>
	public static void main(String[] args) {
<a name="23526"></a>		int[][] a = { { 00, 01 }, { 10, 11 } };
<a name="23527"></a>		int i = 99;
<a name="23528"></a>		try {
<a name="23529"></a>			a[val()][i = 1]++;
<a name="23530"></a>		} catch (Exception e) {
<a name="23531"></a>			System.out.println(e + ", i=" + i);
<a name="23532"></a>		}
<a name="23533"></a>	}
<br><a name="23534"></a>	static int val() throws Exception {
<a name="50226"></a>		throw new Exception("unimplemented");
<a name="50228"></a>	}
<br><a name="23535"></a>}
</pre><a name="23536"></a>
prints:
<p><pre><a name="23537"></a>java.lang.Exception: unimplemented, i=99
</pre><a name="23538"></a>
because the embedded assignment that sets <code>i</code> to <code>1</code> is never executed.
<p><a name="36736"></a>
<h3>15.9.3    Example: Array Creation and Out-of-Memory Detection</h3>
<a name="36885"></a>
If evaluation of an array creation expression finds there is insufficient memory to 
perform the creation operation, then an <code>OutOfMemoryError</code> is thrown. This check 
occurs only after evaluation of all dimension expressions has completed normally.
<p><a name="36744"></a>
So, for example, the test program:<p>
<pre><a name="36800"></a>
class Test {
<a name="36801"></a>	public static void main(String[] args) {
<a name="36802"></a>		int len = 0, oldlen = 0;
<a name="36818"></a>		Object[] a = new Object[0];
<a name="36804"></a>		try {
<a name="238115"></a>			for (;;) {
<a name="238116"></a>				++len;
<a name="238117"></a>				Object[] temp = new Object[oldlen = len];
<a name="238118"></a>				temp[0] = a;
<a name="36823"></a>				a = temp;
<a name="36833"></a>			}
<a name="36807"></a>		} catch (Error e) {
<a name="36808"></a>			System.out.println(e + ", " + (oldlen==len));
<a name="36811"></a>		}
<a name="36812"></a>	}
<a name="36813"></a>}
</pre><a name="36764"></a>
prints:
<p><pre><a name="36765"></a>java.lang.OutOfMemoryError, true
</pre><a name="36901"></a>
because the out-of-memory condition is detected after the argument expression 
<code>oldlen</code> = <code>len</code> is evaluated.
<p><a name="36905"></a>
Compare this to class instance creation expressions <a href="15.doc.html#41147">(&#167;15.8)</a>, which detect the out-of-memory condition before evaluating argument expressions <a href="15.doc.html#36687">(&#167;15.8.2)</a>.<p>
<a name="41267"></a>
<h2>15.10    Field Access Expressions</h2>
<a name="37024"></a>
A field access expression may access a field of an object or array, a reference to 
which is the value of either an expression or the special keyword <code>super</code>. (It is also 
possible to refer to a field of the current instance or current class by using a simple 
name; see <a href="15.doc.html#4984">&#167;15.13.1</a>.)
<p><ul><pre>
<i>FieldAccess:<br>
</i>	<i>Primary</i><code> . </code><i>Identifier<br>
</i>	<code>super . </code><i>Identifier
</i></pre></ul><a name="37051"></a>
The meaning of a field access expression is determined using the same rules as for qualified names <a href="6.doc.html#33916">(&#167;6.6)</a>, but limited by the fact that an expression cannot denote a package, class type, or interface type.<p>
<a name="37055"></a>
<h3>15.10.1    Field Access Using a Primary</h3>
<a name="37056"></a>
The type of the <i>Primary</i> must be a reference type <i>T</i>, or a compile-time error 
occurs. The meaning of the field access expression is determined as follows:
<p><ul><a name="20394"></a>
<li>If the identifier names several accessible member fields of type <i>T</i>, then the field access is ambiguous and a compile-time error occurs.
<a name="37075"></a>
<li>If the identifier does not name an accessible member field of type <i>T</i>, then the field access is undefined and a compile-time error occurs.
<a name="20398"></a>
<li>Otherwise, the identifier names a single accessible member field of type <i>T</i> and the type of the field access expression is the declared type of the field. At run time, the result of the field access expression is computed as follows:
<ul>
<a name="37316"></a>
<li>If the field is <code>static</code>:
<ul>
<a name="37335"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified class variable in the class or interface that is the type of the <i>Primary</i> expression.
<a name="37336"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified class variable in the class that is the type of the <i>Primary</i> expression.
</ul>
<a name="37320"></a>
<li>If the field is not <code>static</code>:
<ul>
<a name="37110"></a>
<li>If the value of the <i>Primary</i> is <code>null</code>, then a <code>NullPointerException</code> is thrown.
<a name="20427"></a>
<li>If the field is <code>final</code>, then the result is the value of the specified instance variable in the object referenced by the value of the <i>Primary</i>.
<a name="20400"></a>
<li>If the field is not <code>final</code>, then the result is a variable, namely, the specified instance variable in the object referenced by the value of the <i>Primary</i>.
</ul>
</ul>
</ul><a name="37135"></a>
Note, specifically, that only the type of the <i>Primary</i> expression, not the class of the 
actual object referred to at run time, is used in determining which field to use.
<p><a name="21262"></a>
Thus, the example:<p>
<pre><a name="20890"></a>class S { int x = 0; }
<a name="20893"></a>class T extends S { int x = 1; }
<a name="20896"></a>class Test {
<a name="20897"></a>	public static void main(String[] args) {
</pre><pre><a name="20898"></a>
		T t = new T();
<a name="20899"></a>		System.out.println("t.x=" + t.x + when("t", t));
<a name="20928"></a>
		S s = new S();
<a name="20901"></a>		System.out.println("s.x=" + s.x + when("s", s));
<a name="20902"></a>
		s = t;
<a name="20916"></a>		System.out.println("s.x=" + s.x + when("s", s));
<br><a name="20904"></a>	}
<br><a name="20930"></a>
	static String when(String name, Object t) {
<a name="20931"></a>		return " when " + name + " holds a "
<a name="20959"></a>			+ t.getClass() + " at run time.";
<a name="20932"></a>	}
<a name="20905"></a>}
</pre><a name="20906"></a>
produces the output:
<p><pre><a name="20961"></a>
t.x=1 when t holds a class T at run time.
<a name="20962"></a>s.x=0 when s holds a class S at run time.
<a name="45445"></a>s.x=0 when s holds a class T at run time.
</pre><a name="45446"></a>
The last line shows that, indeed, the field that is accessed does not depend on the 
run-time class of the referenced object; even if <code>s</code> holds a reference to an object of 
class <code>T</code>, the expression <code>s.x</code> refers to the <code>x</code> field of class <code>S</code>, because the type of the 
expression <code>s</code> is <code>S</code>. Objects of class <code>T</code> contain two fields named <code>x</code>, one for class <code>T</code> 
and one for its superclass <code>S</code>.
<p><a name="22264"></a>
This lack of dynamic lookup for field accesses allows Java to run efficiently with straightforward implementations. The power of late binding and overriding is available in Java, but only when instance methods are used. Consider the same example using instance methods to access the fields:<p>
<pre><a name="37188"></a>class S { int x = 0; int z() { return x; } }
<a name="37189"></a>class T extends S { int x = 1; int z() { return x; } }
<a name="37190"></a>class Test {
</pre><pre><a name="37191"></a>
	public static void main(String[] args) {
<a name="37192"></a>		T t = new T();
<a name="37193"></a>		System.out.println("t.z()=" + t.z() + when("t", t));
<a name="37194"></a>		S s = new S();
<a name="37195"></a>		System.out.println("s.z()=" + s.z() + when("s", s));
<a name="37196"></a>		s = t;
<a name="37197"></a>		System.out.println("s.z()=" + s.z() + when("s", s));
<a name="37198"></a>	}
<a name="37199"></a>
	static String when(String name, Object t) {
<a name="37200"></a>		return " when " + name + " holds a "
<a name="37201"></a>			+ t.getClass() + " at run time.";
<a name="37202"></a>	}
<a name="37203"></a>}
</pre><a name="238134"></a>
Now the output is:
<p><pre><a name="37243"></a>
t.z()=1 when t holds a class T at run time.
<a name="37244"></a>s.z()=0 when s holds a class S at run time.
<a name="37245"></a>s.z()=1 when s holds a class T at run time.
</pre><a name="37254"></a>
The last line shows that, indeed, the method that is accessed <i>does</i> depend on the 
run-time class of referenced object; when <code>s</code> holds a reference to an object of class 
<code>T</code>, the expression <code>s.z()</code> refers to the <code>z</code> method of class <code>T</code>, despite the fact that the 
type of the expression <code>s</code> is <code>S</code>. Method <code>z</code> of class <code>T</code> overrides method <code>z</code> of class <code>S</code>.
<p><a name="22234"></a>
The following example demonstrates that a null reference may be used to access a class (<code>static</code>) variable without causing an exception:<p>
<pre><a name="37293"></a>
class Test {
<a name="37294"></a>	static String mountain = "Chocorua";
<a name="37295"></a>
	static Test favorite(){
<a name="37296"></a>		System.out.print("Mount ");
<a name="37297"></a>		return null;
<a name="37298"></a>	}
<a name="37299"></a>
	public static void main(String[] args) {
<a name="37300"></a>		System.out.println(favorite().mountain);
<a name="37301"></a>	}
<a name="37302"></a>}
</pre><a name="22242"></a>
It compiles, executes, and prints:
<p><pre><a name="22243"></a>Mount Chocorua
</pre><a name="39173"></a>
Even though the result of <code>favorite()</code> is <code>null</code>, a <code>NullPointerException</code> is <i>not</i> 
thrown. That "<code>Mount </code>" is printed demonstrates that the <i>Primary</i> expression is 
indeed fully evaluated at run time, despite the fact that only its type, not its value, 
is used to determine which field to access (because the field <code>mountain</code> is <code>static</code>).
<p><a name="20860"></a>
<h3>15.10.2    Accessing Superclass Members using <code>super</code></h3>
<a name="20451"></a>
The special form using the keyword <code>super</code> is valid only in an instance method or 
constructor, or in the initializer of an instance variable of a class; these are exactly 
the same situations in which the keyword <code>this</code> may be used <a href="15.doc.html#31980">(&#167;15.7.2)</a>. The form 
involving <code>super</code> may not be used anywhere in the class <code>Object</code>, since <code>Object</code> has 
no superclass; if <code>super</code> appears in class <code>Object</code>, then a compile-time error results.
<p><a name="37384"></a>
Suppose that a field access expression <code>super.</code><i>name</i> appears within class <i>C</i>, and the immediate superclass of <i>C</i> is class <i>S</i>. Then <code>super.</code><i>name</i> is treated exactly as if it had been the expression <code>((</code><i>S</i><code>)this).</code><i>name</i>; thus, it refers to the field named <i>name</i> of the current object, but with the current object viewed as an instance of the superclass. Thus it can access the field named <i>name</i> that is visible in class <i>S</i>, even if that field is hidden by a declaration of a field named <i>name</i> in class <i>C</i>.<p>
<a name="20763"></a>
The use of <code>super</code> is demonstrated by the following example:<p>
<pre><a name="20487"></a>
interface I { int x = 0; }
<a name="20490"></a>class T1 implements I { int x = 1; }
<a name="50230"></a>class T2 extends T1 { int x = 2; }
<a name="20497"></a>class T3 extends T2 {
<a name="20498"></a>	int x = 3;
<a name="20500"></a>	void test() {
<a name="20502"></a>		System.out.println("x=\t\t"+x);
<a name="20503"></a>		System.out.println("super.x=\t\t"+super.x);
<a name="20504"></a>		System.out.println("((T2)this).x=\t"+((T2)this).x);
<a name="20505"></a>		System.out.println("((T1)this).x=\t"+((T1)this).x);
<a name="20506"></a>		System.out.println("((I)this).x=\t"+((I)this).x);
<a name="20512"></a>	}
<a name="20513"></a>}
<a name="20514"></a>class Test {
<a name="20515"></a>	public static void main(String[] args) {
<a name="20516"></a>		new T3().test();
<a name="20518"></a>	}
<a name="20519"></a>}
</pre><a name="20520"></a>
which produces the output:
<p><pre><a name="20521"></a>
x=					3
<a name="20522"></a>super.x=					2
<a name="20523"></a>((T2)this).x=					2
<a name="20524"></a>((T1)this).x=					1
<a name="20525"></a>((I)this).x=					0
</pre><a name="37491"></a>
Within class <code>T3</code>, the expression <code>super.x</code> is treated exactly as if it were:
<p><pre><a name="37492"></a><code>((T2)this).x
</code></pre><a name="20448"></a>
<h2>15.11    Method Invocation Expressions</h2>
<a name="37518"></a>
A method invocation expression is used to invoke a class or instance method.
<p><ul><pre>
<i>MethodInvocation:<br>
</i>	<i>MethodName</i><code> ( </code><i>ArgumentList</i><sub><i>opt</i></sub><code> )<br>
</code>	<i>Primary</i><code> . </code><i>Identifier</i><code> ( </code><i>ArgumentList</i><sub><i>opt</i></sub><code> )<br>
	super . </code><i>Identifier</i><code> ( </code><i>ArgumentList</i><sub><i>opt</i></sub><code> )
</code></pre></ul><a name="8506"></a>
The definition of <i>ArgumentList</i> from <a href="15.doc.html#41147">&#167;15.8</a> is repeated here for convenience:
<p><ul><pre>
<i>ArgumentList:<br>
</i>	<i>Expression<br>
</i>	<i>ArgumentList</i><code> , </code><i>Expression
</i></pre></ul><a name="228339"></a>
Resolving a method name at compile time is more complicated than resolving a field name because of the possibility of method overloading. Invoking a method at run time is also more complicated than accessing a field because of the possibility of instance method overriding.<p>
<a name="38751"></a>
Determining the method that will be invoked by a method invocation expression involves several steps. The following three sections describe the compile-time processing of a method invocation; the determination of the type of the method invocation expression is described in <a href="15.doc.html#23617">&#167;15.11.3</a>.<p>
<a name="21692"></a>
<h3>15.11.1    Compile-Time Step 1: Determine Class or Interface to Search</h3>
<a name="37532"></a>
The first step in processing a method invocation at compile time is to figure out 
the name of the method to be invoked and which class or interface to check for 
definitions of methods of that name. There are several cases to consider, depending
on the form that precedes the left parenthesis, as follows:
<p><ul><a name="37552"></a>
<li>If the form is <i>MethodName</i>, then there are three subcases:
<ul>
<a name="37575"></a>
<li>If it is a simple name, that is, just an <i>Identifier</i>, then the name of the method is the <i>Identifier</i> and the class or interface to search is the one whose declaration contains the method invocation.
<a name="37556"></a>
<li>If it is a qualified name of the form <i>TypeName</i> <code>.</code> <i>Identifier</i>, then the name of the method is the <i>Identifier</i> and the class to search is the one named by the <i>TypeName</i>. If <i>TypeName</i> is the name of an interface rather than a class, then a compile-time error occurs, because this form can invoke only <code>static</code> methods and interfaces have no <code>static</code> methods.
<a name="37591"></a>
<li>In all other cases, the qualified name has the form <i>FieldName</i> <code>.</code> <i>Identifier</i>; then the name of the method is the <i>Identifier</i> and the class or interface to search is the declared type of the field named by the <i>FieldName</i>.
</ul>
<a name="37589"></a>
<li>If the form is <i>Primary</i> <code>.</code> <i>Identifier</i>, then the name of the method is the <i>Identifier</i> &#32;and the class or interface to be searched is the type of the <i>Primary</i> expression.
<a name="37600"></a>
<li>If the form is <code>super</code> <code>.</code> <i>Identifier</i>, then the name of the method is the <i>Identifier</i> and the class to be searched is the superclass of the class whose declaration contains the method invocation. A compile-time error occurs if such a method invocation occurs in an interface, or in the class <code>Object</code>, or in a <code>static</code> method, a static initializer, or the initializer for a <code>static</code> variable. It follows that a method invocation of this form may appear only in a class other than <code>Object</code>, and only in the body of an instance method, the body of a constructor, or an initializer for an instance variable.
</ul><a name="21693"></a>
<h3>15.11.2    Compile-Time Step 2: Determine Method Signature</h3>
<a name="19915"></a>
The second step searches the class or interface determined in the previous step for 
method declarations. This step uses the name of the method and the types of the 
argument expressions to locate method declarations that are both <i>applicable</i> and 
<i>accessible</i>, that is, declarations that can be correctly invoked on the given arguments.
There may be more than one such method declaration, in which case the 
<i>most specific</i> one is chosen. The descriptor (signature plus return type) of the most 
specific method declaration is one used at run time to do the method dispatch.
<p><a name="18427"></a>
<h4>15.11.2.1    Find Methods that are Applicable and Accessible</h4>
<a name="21818"></a>
A method declaration is <i>applicable</i> to a method invocation if and only if both of 
the following are true:
<p><ul><a name="37650"></a>
<li>The number of parameters in the method declaration equals the number of argument &#32;expressions in the method invocation.
<a name="37653"></a>
<li>The type of each actual argument can be converted by method invocation conversion <a href="5.doc.html#12687">(&#167;5.3)</a> to the type of the corresponding parameter. Method invocation conversion is the same as assignment conversion <a href="5.doc.html#170768">(&#167;5.2)</a>, except that constants of type <code>int</code> are never implicitly narrowed to <code>byte</code>, <code>short</code>, or <code>char</code>.
</ul><a name="21702"></a>
The class or interface determined by the process described in <a href="15.doc.html#21692">&#167;15.11.1</a> is searched for all method declarations applicable to this method invocation; method definitions inherited from superclasses and superinterfaces are included in this search.<p>
<a name="37690"></a>
Whether a method declaration is <i>accessible</i> to a method invocation depends on the access modifier (<code>public</code>, none, <code>protected</code>, or <code>private</code>) in the method declaration and on where the method invocation appears.<p>
<a name="37675"></a>
If the class or interface has no method declaration that is both applicable and accessible, then a compile-time error occurs.<p>
<a name="37720"></a>
In the example program:<p>
<pre><a name="37706"></a>
public class Doubler {
<a name="37707"></a>	static int two() { return two(1); }
<a name="37708"></a>	private static int two(int i) { return 2*i; }
<a name="37709"></a>}
<a name="37710"></a>
class Test extends Doubler {	
<a name="37733"></a>	public static long two(long j) {return j+j; }
<a name="37711"></a>
	public static void main(String[] args) {
<a name="37712"></a>		System.out.println(two(3));
<a name="37713"></a>		System.out.println(Doubler.two(3)); // compile-time error
<a name="37714"></a>	}
<a name="37715"></a>}
</pre><a name="37704"></a>
for the method invocation <code>two(1)</code> within class <code>Doubler</code>, there are two accessible 
methods named <code>two</code>, but only the second one is applicable, and so that is the one 
invoked at run time. For the method invocation <code>two(3)</code> within class <code>Test</code>, there 
are two applicable methods, but only the one in class <code>Test</code> is accessible, and so 
that is the one to be invoked at run time (the argument <code>3</code> is converted to type 
<code>long</code>). For the method invocation <code>Doubler.two(3)</code>, the class <code>Doubler</code>, not class 
<code>Test</code>, is searched for methods named <code>two</code>; the only applicable method is not 
accessible, and so this method invocation causes a compile-time error.
<p><a name="21942"></a>
Another example is:<p>
<pre><a name="21943"></a>
class ColoredPoint {
<a name="21949"></a>	int x, y;
<a name="21950"></a>	byte color;
<a name="21953"></a>	void setColor(byte color) { this.color = color; }
<a name="21954"></a>}
<a name="21955"></a>
class Test {
<a name="21956"></a>	public static void main(String[] args) {
<a name="21957"></a>		ColoredPoint cp = new ColoredPoint();
<a name="21958"></a>		byte color = 37;
<a name="21959"></a>		cp.setColor(color);
<a name="21960"></a>		cp.setColor(37);											// compile-time error
<a name="21961"></a>	}
<a name="21962"></a>}
</pre><a name="21881"></a>
Here, a compile-time error occurs for the second invocation of <code>setColor</code>, because 
no applicable method can be found at compile time. The type of the literal <code>37</code> is 
<code>int</code>, and <code>int</code> cannot be converted to <code>byte</code> by method invocation conversion. 
Assignment conversion, which is used in the initialization of the variable <code>color</code>, 
performs an implicit conversion of the constant from type <code>int</code> to <code>byte</code>, which is 
permitted because the value <code>37</code> is small enough to be represented in type <code>byte</code>; but 
such a conversion is not allowed for method invocation conversion.
<p><a name="21968"></a>
If the method <code>setColor</code> had, however, been declared to take an <code>int</code> instead of a <code>byte</code>, then both method invocations would be correct; the first invocation would be allowed because method invocation conversion does permit a widening conversion from <code>byte</code> to <code>int</code>. However, a narrowing cast would then be required in the body of <code>setColor</code>:<p>
<pre><a name="21973"></a>	void setColor(int color) { this.color = (byte)color; }
</pre><a name="18428"></a>
<h4>15.11.2.2    Choose the Most Specific Method</h4>
<a name="21703"></a>
If more than one method is both accessible and applicable to a method invocation, 
it is necessary to choose one to provide the descriptor for the run-time method dispatch.
Java uses the rule that the <i>most specific</i> method is chosen.
<p><a name="21708"></a>
The informal intuition is that one method declaration is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time type error.<p>
<a name="21709"></a>
The precise definition is as follows. Let <i>m</i> be a name and suppose that there are two declarations of methods named <i>m</i>, each having <i>n</i> parameters. Suppose that one declaration appears within a class or interface <i>T</i> and that the types of the parameters are <i>T1</i>,&#32;. . . ,&#32;<i>Tn</i>; suppose moreover that the other declaration appears within a class or interface <i>U</i> and that the types of the parameters are <i>U1</i>, . . . ,&#32;<i>Un</i>. Then the method <i>m</i> declared in <i>T</i> is <i>more specific</i> than the method <i>m</i> declared in <i>U</i><code></code> if and only if both of the following are true:<p>
<ul><a name="37872"></a>
<li><i>T</i> can be converted to <i>U</i><code></code> by method invocation conversion.
<a name="37876"></a>
<li><i>Tj</i> can be converted to <i>Uj</i><code></code> by method invocation conversion, for all <i>j</i> from <code>1</code> to <i>n</i>.
</ul><a name="37912"></a>
A method is said to be <i>maximally specific</i> for a method invocation if it is applicable and accessible and there is no other applicable and accessible method that is more specific.<p>
<a name="37937"></a>
If there is exactly one maximally specific method, then it is in fact <i>the most specific</i> method; it is necessarily more specific than any other method that is applicable and accessible. It is then subjected to some further compile-time checks as described in <a href="15.doc.html#23617">&#167;15.11.3</a>.<p>
<a name="37907"></a>
It is possible that no method is the most specific, because there are two or more maximally specific method declarations. In this case, we say that the method invocation is <i>ambiguous</i>, and a compile-time error occurs.<p>
<a name="21711"></a>
<h4>15.11.2.3    Example: Overloading Ambiguity</h4>
<a name="21712"></a>
Consider the example:
<p><pre><a name="21713"></a>class Point { int x, y; }
<a name="21714"></a>class ColoredPoint extends Point { int color; }
</pre><pre><a name="238137"></a>
class Test {
<a name="21716"></a>
	static void test(ColoredPoint p, Point q) {
<a name="21717"></a>		System.out.println("(ColoredPoint, Point)");
<a name="50239"></a>	}
<a name="21718"></a>
	static void test(Point p, ColoredPoint q) {
<a name="21719"></a>		System.out.println("(Point, ColoredPoint)");
<a name="50241"></a>	}
<a name="21720"></a>
	public static void main(String[] args) {
<a name="21722"></a>		ColoredPoint cp = new ColoredPoint();
<a name="21723"></a>		test(cp, cp);											// compile-time error
<a name="21724"></a>	}
<a name="21725"></a>}
</pre><a name="21726"></a>
This example produces an error at compile time. The problem is that there are two 
declarations of <code>test</code> that are applicable and accessible, and neither is more specific
than the other. Therefore, the method invocation is ambiguous.
<p><a name="38010"></a>
If a third definition of <code>test</code> were added:<p>
<pre><a name="38015"></a>
	static void test(ColoredPoint p, ColoredPoint q) {
<a name="38016"></a>		System.out.println("(ColoredPoint, ColoredPoint)");
<a name="38017"></a>	}
</pre><a name="38011"></a>
then it would be more specific than the other two, and the method invocation 
would no longer be ambiguous.
<p><a name="21727"></a>
<h4>15.11.2.4    Example: Return Type Not Considered</h4>
<a name="21728"></a>
As another example, consider:
<p><pre><a name="21729"></a>class Point { int x, y; }
<a name="21730"></a>class ColoredPoint extends Point { int color; }
<a name="21731"></a>class Test {
</pre><pre><a name="21732"></a>
	static int test(ColoredPoint p) {
<a name="21733"></a>		return color;
<a name="21734"></a>	}
<a name="21735"></a>
	static String test(Point p) {
<a name="21736"></a>		return "Point";
<a name="21737"></a>	}
<a name="21738"></a>
	public static void main(String[] args) {
<a name="21739"></a>		ColoredPoint cp = new ColoredPoint();
<a name="21740"></a>		String s = test(cp);											// compile-time error
<a name="21741"></a>	}
<a name="21742"></a>}
</pre><a name="21743"></a>
Here the most specific declaration of method <code>test</code> is the one taking a parameter 
of type <code>ColoredPoint</code>. Because the result type of the method is <code>int</code>, a compile-
time error occurs because an <code>int</code> cannot be converted to a <code>String</code> by assignment 
conversion. This example shows that, in Java, the result types of methods do not 
participate in resolving overloaded methods, so that the second <code>test</code> method, 
which returns a <code>String</code>, is not chosen, even though it has a result type that would 
allow the example program to compile without error.
<p><a name="29775"></a>
<h4>15.11.2.5    Example: Compile-Time Resolution</h4>
<a name="30681"></a>
The most applicable method is chosen at compile time; its descriptor determines 
what method is actually executed at run time. If a new method is added to a class, 
then Java code that was compiled with the old definition of the class might not use 
the new method, even if a recompilation would cause this method to be chosen.
<p><a name="30687"></a>
So, for example, consider two compilation units, one for class <code>Point</code>:<p>
<pre><a name="30688"></a>package points;
<a name="30689"></a>public class Point {
<a name="30718"></a>	public int x, y;
<a name="30706"></a>	public Point(int x, int y) { this.x = x; this.y = y; }
<a name="30774"></a>	public String toString() { return toString(""); }
</pre><pre><a name="30777"></a>
	public String toString(String s) {
<a name="30778"></a>		return "(" + x + "," + y + s + ")";
<a name="30779"></a>	}
<a name="30717"></a>}
</pre><a name="30799"></a>
and one for class <code>ColoredPoint</code>:
<p><pre><a name="30800"></a>package points;
<a name="30801"></a>public class ColoredPoint extends Point {
</pre><pre><a name="30802"></a>
	public static final int
<a name="30803"></a>		RED = 0, GREEN = 1, BLUE = 2;
<a name="30804"></a>
	public static String[] COLORS =
<a name="30805"></a>		{ "red", "green", "blue" };
<a name="30806"></a>	public byte color;
<a name="30807"></a>
	public ColoredPoint(int x, int y, int color) {
<a name="30808"></a>		super(x, y); this.color = (byte)color;
<a name="30809"></a>	}
<a name="38090"></a>
	/** Copy all relevant fields of the argument into
<a name="38091"></a>		 &#32; &#32;this <code>ColoredPoint</code> object. */
<a name="30810"></a>	public void adopt(Point p) { x = p.x; y = p.y; }
<a name="30811"></a>
	public String toString() {
<a name="30812"></a>		String s = "," + COLORS[color];
<a name="30813"></a>		return super.toString(s);
<a name="30814"></a>	}
<a name="38076"></a>}
</pre><a name="30815"></a>
Now consider a third compilation unit that uses <code>ColoredPoint</code>:
<p><pre><a name="30699"></a>import points.*;
<a name="30702"></a>class Test {
<a name="30700"></a>	public static void main(String[] args) {
<a name="30701"></a>		ColoredPoint cp =
<a name="30748"></a>			new ColoredPoint(6, 6, ColoredPoint.RED);
<a name="30722"></a>		ColoredPoint cp2 =
<a name="30751"></a>			new ColoredPoint(3, 3, ColoredPoint.GREEN);
<a name="30705"></a>		cp.adopt(cp2);
<a name="30766"></a>		System.out.println("cp: " + cp);
<a name="30720"></a>	}
<a name="30721"></a>}
</pre><a name="30754"></a>
The output is:
<p><pre><a name="30755"></a>cp: (3,3,red)
</pre><a name="30756"></a>
The application programmer who coded class <code>Test</code> has expected to see the word <code>green</code>, because the actual argument, a <code>ColoredPoint</code>, has a <code>color</code> field, and <code>color</code> would seem to be a "relevant field" (of course, the documentation for the package <code>Points</code> ought to have been much more precise!).<p>
<a name="38120"></a>
Notice, by the way, that the most specific method (indeed, the only applicable method) for the method invocation of <code>adopt</code> has a signature that indicates a method of one parameter, and the parameter is of type <code>Point</code>. This signature becomes part of the binary representation of class <code>Test</code> produced by the compiler and is used by the method invocation at run time.<p>
<a name="38098"></a>
Suppose the programmer reported this software error and the maintainer of the <code>points</code> package decided, after due deliberation, to correct it by adding a method to class <code>ColoredPoint</code>:<p>
<pre><a name="30827"></a>
public void adopt(ColoredPoint p) {
<a name="30828"></a>	adopt((Point)p); color = p.color;
<a name="30835"></a>}
</pre><a name="239516"></a>
If the application programmer then runs the old binary file for <code>Test</code> with the new binary file for <code>ColoredPoint</code>, the output is still:<p>
<pre><a name="38140"></a>cp: (3,3,red)
</pre><a name="38138"></a>
because the old binary file for <code>Test</code> still has the descriptor "one parameter, whose 
type is <code>Point</code>; <code>void</code>" associated with the method call <code>cp.adopt(cp2)</code>. If the 
source code for <code>Test</code> is recompiled, the compiler will then discover that there are 
now two applicable <code>adopt</code> methods, and that the signature for the more specific 
one is "one parameter, whose type is <code>ColoredPoint</code>; <code>void</code>"; running the program 
will then produce the desired output:
<p><pre><a name="38149"></a>cp: (3,3,green)
</pre><a name="30865"></a>
With forethought about such problems, the maintainer of the <code>points</code> package could fix the <code>ColoredPoint</code> class to work with both newly compiled and old code, by adding defensive code to the old <code>adopt</code> method for the sake of old code that still invokes it on <code>ColoredPoint</code> arguments:<p>
<pre><a name="30880"></a>
public void adopt(Point p) {
<a name="30886"></a>	if (p instanceof ColoredPoint)
<a name="30887"></a>		color = ((ColoredPoint)p).color;
<a name="30888"></a>	x = p.x; y = p.y;
<a name="30889"></a>}
</pre><a name="30914"></a>
A similar consideration applies if a method is to be moved from a class to a superclass. In this case a forwarding method can be left behind for the sake of old code. The maintainer of the <code>points</code> package might choose to move the <code>adopt</code> method that takes a <code>Point</code> argument up to class <code>Point</code>, so that all <code>Point</code> objects may enjoy the <code>adopt</code> functionality. To avoid compatibility problems with old binary code, the maintainer should leave a forwarding method behind in class <code>ColoredPoint</code>:<p>
<pre><a name="30926"></a>
public void adopt(Point p) {
<a name="30927"></a>	if (p instanceof ColoredPoint)
<a name="30928"></a>		color = ((ColoredPoint)p).color;
<a name="30929"></a>	super.adopt(p);
<a name="30930"></a>}
</pre><a name="38189"></a>
Ideally, Java code should be recompiled whenever code that it depends on is changed. However, in an environment where different Java classes are maintained by different organizations, this is not always feasible. Defensive programming with careful attention to the problems of class evolution can make upgraded code much more robust. See <a href="13.doc.html#44871">&#167;13</a> for a detailed discussion of binary compatibility and type evolution.<p>
<a name="23617"></a>
<h3>15.11.3    Compile-Time Step 3: Is the Chosen Method Appropriate?</h3>
<a name="23618"></a>
If there is a most specific method declaration for a method invocation, it is called 
the <i>compile-time declaration</i> for the method invocation. Two further checks must 
be made on the compile-time declaration:
<p><ul><a name="38457"></a>
<li>If the method invocation has, before the left parenthesis, a <i>MethodName</i> of the &#32;form <i>Identifier</i>, and the method invocation appears within a <code>static</code> method, a static initializer, or the initializer for a <code>static</code> variable, then the compile-time declaration must be <code>static</code>. If, instead, the compile-time declaration for the method invocation is for an instance method, then a compile-time error occurs. (The reason is that a method invocation of this form cannot be used to invoke an instance method in places where <code>this</code> <a href="15.doc.html#31980">(&#167;15.7.2)</a> is not defined.)
<a name="21464"></a>
<li>If the method invocation has, before the left parenthesis, a <i>MethodName</i> of the &#32;form <i>TypeName</i> <code>.</code> <i>Identifier</i>, then the compile-time declaration should be <code>static</code>. If the compile-time declaration for the method invocation is for an instance &#32;method, then a compile-time error occurs. (The reason is that a method invocation of this form does not specify a reference to an object that can serve as <code>this</code> within the instance method.)
<a name="21291"></a>
<li>If the compile-time declaration for the method invocation is <code>void</code>, then the method invocation must be a top-level expression, that is, the <i>Expression</i> in an expression statement <a href="14.doc.html#5984">(&#167;14.7)</a> or in the <i>ForInit</i> or <i>ForUpdate</i> part of a <code>for</code> statement <a href="14.doc.html#24588">(&#167;14.12)</a>, or a compile-time error occurs. (The reason is that such a method invocation produces no value and so must be used only in a situation where a value is not needed.)
</ul><a name="38703"></a>
The following compile-time information is then associated with the method invocation for use at run time:<p>
<ul><a name="38709"></a>
<li>The name of the method.
<a name="38704"></a>
<li>The class or interface that contains the compile-time declaration.
<a name="38716"></a>
<li>The number of parameters and the types of the parameters, in order.
<a name="38717"></a>
<li>The result type, or <code>void</code>, as declared in the compile-time declaration.
<a name="38712"></a>
<li>The invocation mode, computed as follows:
<ul>
<a name="38723"></a>
<li>If the compile-time declaration has the <code>static</code> modifier, then the invocation mode is <code>static</code>.
<a name="43892"></a>
<li>Otherwise, if the compile-time declaration has the <code>private</code> modifier, then the invocation mode is <code>nonvirtual</code>.
<a name="43894"></a>
<li>Otherwise, if the part of the method invocation before the left parenthesis is of the form <code>super</code> <code>.</code> <i>Identifier</i>, then the invocation mode is <code>super</code>.
<a name="38796"></a>
<li>Otherwise, if the compile-time declaration is in an interface, then the invocation mode is <code>interface</code>.
<a name="38732"></a>
<li>Otherwise, the invocation mode is <code>virtual</code>.
</ul>
</ul><a name="38220"></a>
If the compile-time declaration for the method invocation is not <code>void</code>, then the type of the method invocation expression is the result type specified in the compile-time declaration.<p>
<a name="45677"></a>
<h3>15.11.4    Runtime Evaluation of Method Invocation</h3>
<a name="45678"></a>
At run time, method invocation requires five steps. First, a <i>target reference</i> may be 
computed. Second, the argument expressions are evaluated. Third, the accessibility
of the method to be invoked is checked. Fourth, the actual code for the method 
to be executed is located. Fifth, a new activation frame is created, synchronization 
is performed if necessary, and control is transferred to the method code.
<p><a name="38359"></a>
<h4>15.11.4.1    Compute Target Reference (If Necessary)</h4>
<a name="38338"></a>
There are several cases to consider, depending on which of the three productions 
for <i>MethodInvocation</i> <a href="15.doc.html#20448">(&#167;15.11)</a> is involved:
<p><ul><a name="239420"></a>
<li>If the first production for <i>MethodInvocation</i>, which includes a <i>MethodName</i>, is involved, then there are three subcases:
<ul>
<a name="239421"></a>
<li>If the <i>MethodName</i> is a simple name, that is, just an <i>Identifier</i>, then there are two subcases:
<ul>
<a name="38362"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference.
<a name="38365"></a>
<li>Otherwise, the target reference is the value of <code>this</code>.
</ul>
<a name="38341"></a>
<li>If the <i>MethodName</i> is a qualified name of the form <i>TypeName</i> <code>.</code> <i>Identifier</i>, then there is no target reference.
<a name="38805"></a>
<li>If the <i>MethodName</i> is a qualified name of the form <i>FieldName</i> <code>.</code> <i>Identifier</i>, then there are two subcases:
<ul>
<a name="38806"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference.
<a name="38807"></a>
<li>Otherwise, the target reference is the value of the expression <i>FieldName</i>.
</ul>
</ul>
<a name="38815"></a>
<li>If the second production for <i>MethodInvocation</i>, which includes a <i>Primary</i>, is involved, then there are two subcases:
<ul>
<a name="38816"></a>
<li>If the invocation mode is <code>static</code>, then there is no target reference. The expression <i>Primary </i>is evaluated, but the result is then discarded.
<a name="38817"></a>
<li>Otherwise, the expression <i>Primary </i>is evaluated and the result is used as the target reference.
</ul>
</ul><ul><a name="38346"></a>
<br><br>In either case, if the evaluation of the <i>Primary</i> expression completes abruptly, then no part of any argument expression appears to have been evaluated, and the method invocation completes abruptly for the same reason.
</ul><ul><a name="38347"></a>
<li>If the third production for <i>MethodInvocation</i>, which includes the keyword <code>super</code>, is involved, then the target reference is the value of <code>this</code>.
</ul><a name="45449"></a>
<h4>15.11.4.2    Evaluate Arguments</h4>
<a name="21593"></a>
The argument expressions are evaluated in order, from left to right. If the evaluation
of any argument expression completes abruptly, then no part of any argument 
expression to its right appears to have been evaluated, and the method invocation 
completes abruptly for the same reason.
<p><a name="45453"></a>
<h4>15.11.4.3    Check Accessibility of Type and Method</h4>
<a name="38478"></a>
Let <i>C</i> be the class containing the method invocation, and let <i>T</i> be the class or interface
that contained the method being invoked, and <i>m</i> be the name of the method, 
as determined at compile time <a href="15.doc.html#23617">(&#167;15.11.3)</a>.
<p><a name="45463"></a>
A Java Virtual Machine must insure, as part of linkage, that the method <i>m</i> still exists in the type <i>T</i>. If this is not true, then a <code>NoSuchMethodError</code> (which is a subclass of <code>IncompatibleClassChangeError</code>) occurs. If the invocation mode is <code>interface</code>, then the virtual machine must also check that the target reference type still implements the specified interface. If the target reference type does not still implement the interface, then an <code>IncompatibleClassChangeError</code> occurs.<p>
<a name="45537"></a>
The virtual machine must also insure, during linkage, that the type <i>T</i> and the method <i>m</i> are accessible. For the type <i>T</i>:<p>
<ul><a name="45547"></a>
<li>If <i>T</i> is in the same package as <i>C</i>, then <i>T</i> is accessible.
<a name="45548"></a>
<li>If <i>T</i> is in a different package than <i>C</i>, and <i>T</i> is <code>public</code>, then <i>T</i> is accessible.
</ul><a name="239521"></a>
For the method <i>m</i>:
<p><ul><a name="45542"></a>
<li>If <i>m</i> is <code>public</code>, then <i>m</i> is accessible. (All members of interfaces are <code>public</code> <a href="9.doc.html#32392">(&#167;9.2)</a>).
<a name="45694"></a>
<li>If <i>m</i> is <code>protected</code>, then <i>m</i> is accessible if and only if either <i>T</i> is in the same package as <i>C</i>, or <i>C</i> is <i>T</i> or a subclass of <i>T</i>.
<a name="45695"></a>
<li>If <i>m</i> has default (package) access, then <i>m</i> is accessible if and only if <i>T</i> is in the same package as <i>C</i>.
<a name="45565"></a>
<li>If <i>m</i> is <code>private</code>, then <i>m</i> is accessible if and only if and <i>C</i> is <i>T</i>.
</ul><a name="45566"></a>
If either <i>T</i> or <i>m</i> is not accessible, then an <code>IllegalAccessError</code> occurs <a href="12.doc.html#44487">(&#167;12.3)</a>.
<p><a name="45606"></a>
<h4>15.11.4.4    Locate Method to Invoke</h4>
<a name="38785"></a>
The strategy for method lookup depends on the invocation mode.
<p><a name="45702"></a>
If the invocation mode is <code>static</code>, no target reference is needed and overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="45395"></a>
Otherwise, an instance method is to be invoked and there is a target reference. If the target reference is <code>null</code>, a <code>NullPointerException</code> is thrown at this point. Otherwise, the target reference is said to refer to a <i>target object</i> and will be used as the value of the keyword <code>this</code> in the invoked method. The other four possibilities for the invocation mode are then considered.<p>
<a name="38856"></a>
If the invocation mode is <code>nonvirtual</code>, overriding is not allowed. Method <i>m</i> of class <i>T</i> is the one to be invoked.<p>
<a name="38864"></a>
Otherwise, the invocation mode is <code>interface</code>, <code>virtual</code>, or <code>super</code>, and overriding may occur. A <i>dynamic method lookup</i> is used. The dynamic lookup process starts from a class <i>S</i>, determined as follows:<p>
<ul><a name="45402"></a>
<li>If the invocation mode is <code>interface</code> or <code>virtual</code>, then <i>S</i> is initially the actual run-time class <i>R</i> of the target object. If the target object is an array, <i>R</i> is the class <code>Object</code>. (Note that for invocation mode <code>interface</code>, <i>R</i> necessarily implements <i>T</i>; for invocation mode <code>virtual</code>, <i>R</i> is necessarily either <i>T</i> or a subclass of <i>T</i>.)
<a name="45403"></a>
<li>If the invocation mode is <code>super</code>, then <i>S</i> is initially the superclass of the class <i>C</i> that contains the method invocation.
</ul><a name="39033"></a>
The dynamic method lookup uses the following procedure to search class <i>S</i>, and 
then the superclasses of class <i>S</i>, as necessary, for method <i>m</i>.
<p><ol>
<a name="38917"></a>
<li>If class <i>S</i> contains a declaration for a method named <i>m</i> with the same descriptor (same number of parameters, the same parameter types, and the same return type) required by the method invocation as determined at compile time <a href="15.doc.html#23617">(&#167;15.11.3)</a>, then this is the method to be invoked, and the procedure terminates. (We note that as part of the loading and linking process that the virtual machine checks that an overriding method is at least as accessible as the overridden method; an &#32;<code>IncompatibleClassChangeError</code> occurs if this is not the case.)
<a name="38959"></a>
<li>Otherwise, if <i>S</i> is not <i>T</i>, this same lookup procedure is performed using the superclass of <i>S</i>; whatever it comes up with is the result of this lookup.
</ol>
<a name="45627"></a>
This procedure will find a suitable method when it reaches class <code>T</code>, because otherwise
an <code>IllegalAccessError</code> would have been thrown by the checks of the previous
section <a href="15.doc.html#45453">&#167;15.11.4.3</a>.
<p><a name="45714"></a>
We note that the dynamic lookup process, while described here explicitly, will often be implemented implicitly, for example as a side-effect of the construction and use of per-class method dispatch tables, or the construction of other per-class structures used for efficient dispatch.<p>
<a name="39078"></a>
<h4>15.11.4.5    Create Frame, Synchronize, Transfer Control</h4>
<a name="39080"></a>
A method <i>m</i> in some class <i>S</i> has been identified as the one to be invoked.
<p><a name="39084"></a>
Now a new <i>activation frame</i> is created, containing the target reference (if any) and the argument values (if any), as well as enough space for the local variables and stack for the method to be invoked and any other bookkeeping information that may be required by the implementation (stack pointer, program counter, reference to previous activation frame, and the like). If there is not sufficient memory available to create such an activation frame, an <code>OutOfMemoryError</code> is thrown.<p>
<a name="39085"></a>
The newly created activation frame becomes the current activation frame. The effect of this is to assign the argument values to corresponding freshly created parameter variables of the method, and to make the target reference available as <code>this</code>, if there is a target reference.<p>
<a name="42183"></a>
If the method <i>m</i> is a <code>native</code> method but the necessary native, implementation-dependent binary code has not been loaded (<a href="javalang.doc15.html#52468">&#167;20.16.14</a>, <a href="javalang.doc15.html#30190">&#167;20.16.13</a>) or otherwise cannot be dynamically linked, then an <code>UnsatisfiedLinkError</code> is thrown.<p>
<a name="41731"></a>
If the method <i>m</i> is not <code>synchronized</code>, control is transferred to the body of the method <i>m</i> to be invoked.<p>
<a name="240503"></a>
If the method <i>m</i> is <code>synchronized</code>, then an object must be locked before the transfer of control. No further progress can be made until the current thread can obtain the lock. If there is a target reference, then the target must be locked; otherwise the <code>Class</code> object for class <i>S</i>, the class of the method <i>m</i>, must be locked. Control is then transferred to the body of the method <i>m</i> to be invoked. The object is automatically unlocked when execution of the body of the method has completed, whether normally or abruptly. The locking and unlocking behavior is exactly as if the body of the method were embedded in a <code>synchronized</code> statement <a href="14.doc.html#79287">(&#167;14.17)</a>.<p>
<a name="239532"></a>
<h4>15.11.4.6    Implementation Note: Combining Frames</h4>
<a name="39099"></a>
In order to allow certain kinds of code optimization, implementations are permitted
some freedom to combine activation frames. Suppose that a method invocation 
within class <i>C</i> is to invoke a method <i>m</i> within class <i>S</i>. Then the current activation 
frame may be used to provide space for <i>S</i> instead of creating a new activation 
frame only if one of the following conditions is true:
<p><ul><a name="39104"></a>
<li>Class <i>C</i> and class <i>S</i> have the same class loader <a href="javalang.doc13.html#14462">(&#167;20.14)</a> and class <i>S</i> is not <code>SecurityManager</code> or a subclass of <code>SecurityManager</code>.
<a name="39105"></a>
<li>Class <i>S</i> has no class loader (this fact indicates that it is a system class); class <i>S</i> is not <code>SecurityManager</code> or a subclass of <code>SecurityManager</code>; and method <i>m</i> is known not to call, directly or indirectly, any method of <code>SecurityManager</code> <a href="javalang.doc16.html#46274">(&#167;20.17)</a> or any of its subclasses.
</ul><a name="39122"></a>
<h4>15.11.4.7    Example: Target Reference and Static Methods</h4>
<a name="39148"></a>
When a target reference is computed and then discarded because the invocation 
mode is <code>static</code>, the reference is not examined to see whether it is <code>null</code>:
<p><pre><a name="39128"></a>
class Test {
<a name="240507"></a>	static void mountain() {<br>
		System.out.println("Monadnock");<br>
	}
<a name="39130"></a>
	static Test favorite(){
<a name="39131"></a>		System.out.print("Mount ");
<a name="39132"></a>		return null;
<a name="39133"></a>	}
<a name="39134"></a>
	public static void main(String[] args) {
<a name="39135"></a>		favorite().mountain();
<a name="39136"></a>	}
<a name="39137"></a>}
</pre><a name="39138"></a>
which prints:
<p><pre><a name="39139"></a>Mount Monadnock
</pre><a name="39140"></a>
Here <code>favorite</code> returns <code>null</code>, yet no <code>NullPointerException</code> is thrown.
<p><a name="23837"></a>
<h4>15.11.4.8    Example: Evaluation Order</h4>
<a name="23841"></a>
As part of an instance method invocation <a href="15.doc.html#20448">(&#167;15.11)</a>, there is an expression that 
denotes the object to be invoked. This expression appears to be fully evaluated 
before any part of any argument expression to the method invocation is evaluated.
<p><a name="23842"></a>
So, for example, in:<p>
<pre><a name="23843"></a>
class Test {
<a name="45454"></a>	public static void main(String[] args) {
<a name="23844"></a>		String s = "one";
<a name="23845"></a>		if (s.startsWith(s = "two"))
<a name="23846"></a>			System.out.println("oops");
<a name="23847"></a>	}
<a name="23848"></a>}
</pre><a name="239641"></a>
the occurrence of <code>s</code> before "<code>.startsWith</code>" is evaluated first, before the argument 
expression <code>s="two"</code>. Therefore, a reference to the string <code>"one"</code> is remembered as 
the target reference before the local variable s is changed to refer to the string 
<code>"two"</code>. As a result, the <code>startsWith</code> method <a href="javalang.doc11.html#2586">(&#167;20.12.20)</a> is invoked for target 
object <code>"one"</code> with argument <code>"two"</code>, so the result of the invocation is <code>false</code>, as the 
string <code>"one"</code> does not start with <code>"two"</code>. It follows that the test program does not 
print "<code>oops</code>".
<p><a name="239650"></a>
<h4>15.11.4.9    Example: Overriding</h4>
<a name="239651"></a>
In the example:
<p><pre><a name="239652"></a>
class Point {
<a name="239653"></a>
	final int EDGE = 20;
<a name="239654"></a>	int x, y;
<a name="239655"></a>
	void move(int dx, int dy) {
<a name="239656"></a>		x += dx; y += dy;
<a name="239657"></a>		if (Math.abs(x) &gt;= EDGE || Math.abs(y) &gt;= EDGE)
<a name="239658"></a>			clear();
<a name="239659"></a>	}
<a name="239660"></a>
	void clear() {
<a name="239661"></a>		System.out.println("\tPoint clear");
<a name="239662"></a>		x = 0; y = 0;
<a name="239663"></a>	}
<a name="239664"></a>}
<a name="239665"></a>
class ColoredPoint extends Point {
<a name="239666"></a>	int color;
</pre><pre><a name="239667"></a>
	void clear() {
<a name="239668"></a>		System.out.println("\tColoredPoint clear");
<a name="239669"></a>		super.clear();
<a name="239670"></a>		color = 0;
<a name="239671"></a>	}
<a name="239672"></a>}
</pre><a name="239673"></a>
the subclass <code>ColoredPoint</code> extends the <code>clear</code> abstraction defined by its superclass
<code>Point</code>. It does so by overriding the <code>clear</code> method with its own method, 
which invokes the <code>clear</code> method of its superclass, using the form <code>super.clear</code>.
<p><a name="239674"></a>
This method is then invoked whenever the target object for an invocation of <code>clear</code> is a <code>ColoredPoint</code>. Even the method <code>move</code> in <code>Point</code> invokes the <code>clear</code> method of class <code>ColoredPoint</code> when the class of <code>this</code> is <code>ColoredPoint</code>, as shown by the output of this test program:<p>
<pre><a name="239675"></a>
class Test {
<a name="239676"></a>	public static void main(String[] args) {
<a name="239677"></a>		Point p = new Point();
<a name="239678"></a>		System.out.println("p.move(20,20):");
<a name="239679"></a>		p.move(20, 20);
<a name="239680"></a>		ColoredPoint cp = new ColoredPoint();
<a name="239681"></a>		System.out.println("cp.move(20,20):");
<a name="239682"></a>		cp.move(20, 20);
<a name="239683"></a>		p = new ColoredPoint();
<a name="239684"></a>		System.out.println("p.move(20,20), p colored:");
<a name="239685"></a>		p.move(20, 20);
<a name="239686"></a>	}
<a name="239687"></a>}
</pre><a name="239688"></a>
which is:
<p><pre><a name="239689"></a>
p.move(20,20):
<a name="239690"></a>	Point clear
<a name="239691"></a>cp.move(20,20):
<a name="239692"></a>	ColoredPoint clear
<a name="239693"></a>	Point clear
<a name="239694"></a>p.move(20,20), p colored:
<a name="239695"></a>	ColoredPoint clear
<a name="239696"></a>	Point clear
</pre><a name="239749"></a>
Overriding is sometimes called "late-bound self-reference"; in this example it means that the reference to <code>clear</code> in the body of <code>Point.move</code> (which is really syntactic shorthand for <code>this.clear</code>) invokes a method chosen "late" (at run time, based on the run-time class of the object referenced by <code>this</code>) rather than a method chosen "early" (at compile time, based only on the type of <code>this</code>). This provides the Java programmer a powerful way of extending abstractions and is a key idea in object-oriented programming.<p>
<a name="239751"></a>
<h4>15.11.4.10    Example: Method Invocation using super</h4>
<a name="239647"></a>
An overridden instance method of a superclass may be accessed by using the keyword
<code>super</code> to access the members of the immediate superclass, bypassing any 
overriding declaration in the class that contains the method invocation.
<p><a name="39225"></a>
When accessing an instance variable, <code>super</code> means the same as a cast of <code>this</code> <a href="15.doc.html#20860">(&#167;15.10.2)</a>, but this equivalence does not hold true for method invocation. This is demonstrated by the example:<p>
<pre><a name="42566"></a>
class T1 {
<a name="42567"></a>	String s() { return "1"; }
<a name="42568"></a>}
<a name="39239"></a>
class T2 extends T1 {
<a name="42569"></a>	String s() { return "2"; }
<a name="42570"></a>}
<a name="42571"></a>
class T3 extends T2 {
<a name="42572"></a>	String s() { return "3"; }
<a name="42573"></a>
	void test() {
<a name="42574"></a>		System.out.println("s()=\t\t"+s());
<a name="42575"></a>		System.out.println("super.s()=\t"+super.s());
<a name="42576"></a>		System.out.print("((T2)this).s()=\t");
<a name="237215"></a>			System.out.println(((T2)this).s());
<a name="42577"></a>		System.out.print("((T1)this).s()=\t");
<a name="237216"></a>			System.out.println(((T1)this).s());
<a name="42578"></a>	}
<a name="42579"></a>}
<a name="42580"></a>
class Test {
<a name="42581"></a>	public static void main(String[] args) {
<a name="42582"></a>		T3 t3 = new T3();
<a name="42583"></a>		t3.test();
<a name="42584"></a>	}
<a name="42585"></a>}
</pre><a name="42586"></a>
which produces the output:
<p><pre><a name="42587"></a>
s()=					3
<a name="42588"></a>super.s()=					2
<a name="42589"></a>((T2)this).s()=					3
<a name="42590"></a>((T1)this).s()=					3
</pre><a name="239537"></a>
The casts to types <code>T1</code> and <code>T2</code> do not change the method that is invoked, because 
the instance method to be invoked is chosen according to the run-time class of the 
object referred to be <code>this</code>. A cast does not change the class of an object; it only 
checks that the class is compatible with the specified type.
<p><a name="239587"></a>
<h2>15.12    Array Access Expressions</h2>
<a name="39327"></a>
An array access expression refers to a variable that is a component of an array.
<p><ul><pre>
<i>ArrayAccess:<br>
</i>	<i>ExpressionName</i><code> [ </code><i>Expression</i><code> ]<br>
</code>	<i>PrimaryNoNewArray</i><code> [ </code><i>Expression</i><code> ]
</code></pre></ul><a name="19392"></a>
An array access expression contains two subexpressions, the <i>array reference expression</i> (before the left bracket) and the <i>index expression</i> (within the brackets). Note that the array reference expression may be a name or any primary expression that is not an array creation expression <a href="15.doc.html#46168">(&#167;15.9)</a>.<p>
<a name="22123"></a>
The type of the array reference expression must be an array type (call it <i>T</i><code>[]</code>, an array whose components are of type <i>T</i>) or a compile-time error results. Then the type of the array access expression is <i>T</i>.<p>
<a name="22103"></a>
The index expression undergoes unary numeric promotion <a href="5.doc.html#170952">(&#167;5.6.1)</a>; the promoted type must be <code>int</code>.<p>
<a name="23960"></a>
The result of an array reference is a variable of type <i>T</i>, namely the variable within the array selected by the value of the index expression. This resulting variable, which is a component of the array, is never considered <code>final</code>, even if the array reference was obtained from a <code>final</code> variable.<p>
<a name="23958"></a>
<h3>15.12.1    Runtime Evaluation of Array Access</h3>
<a name="39346"></a>
An array access expression is evaluated using the following procedure:
<p><ul><a name="22142"></a>
<li>First, the array reference expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason and the index expression is not evaluated.
<a name="22130"></a>
<li>Otherwise, the index expression is evaluated. If this evaluation completes abruptly, then the array access completes abruptly for the same reason.
<a name="22098"></a>
<li>Otherwise, if the value of the array reference expression is <code>null</code>, then a <code>NullPointerException</code> &#32;is thrown.
<a name="6936"></a>
<li>Otherwise, the value of the array reference expression indeed refers to an array. If the value of the index expression is less than zero, or greater than or equal to the array's length, then an <code>IndexOutOfBoundsException</code> is thrown.
<a name="6937"></a>
<li>Otherwise, the result of the array reference is the variable of type <i>T</i>, within the array, selected by the value of the index expression. (Note that this resulting variable, which is a component of the array, is never considered <code>final</code>, even if the array reference expression is a <code>final</code> variable.)
</ul><a name="23902"></a>
<h3>15.12.2    Examples: Array Access Evaluation Order</h3>
<a name="23906"></a>
In an array access, the expression to the left of the brackets appears to be fully 
evaluated before any part of the expression within the brackets is evaluated. For 
example, in the (admittedly monstrous) expression <code>a[(a=b)[3]]</code>, the expression 
<code>a</code> is fully evaluated before the expression <code>(a=b)[3]</code>; this means that the original 
value of <code>a</code> is fetched and remembered while the expression <code>(a=b)[3]</code> is evaluated.
This array referenced by the original value of <code>a</code> is then subscripted by a value 
that is element <code>3</code> of another array (possibly the same array) that was referenced by 
<code>b</code> and is now also referenced by <code>a</code>.
<p><a name="23907"></a>
Thus, the example:<p>
<pre><a name="23908"></a>
class Test {
<a name="23909"></a>	public static void main(String[] args) {
<a name="23910"></a>		int[] a = { 11, 12, 13, 14 };
<a name="23911"></a>		int[] b = { 0, 1, 2, 3 };
<a name="23912"></a>		System.out.println(a[(a=b)[3]]);
<a name="23913"></a>	}
<a name="23914"></a>}
</pre><a name="23915"></a>
prints:
<p><pre><a name="23916"></a>14
</pre><a name="23917"></a>
because the monstrous expression's value is equivalent to <code>a[b[3]]</code> or <code>a[3]</code> or <code>14</code>.
<p><a name="23918"></a>
If evaluation of the expression to the left of the brackets completes abruptly, no part of the expression within the brackets will appear to have been evaluated. Thus, the example:<p>
<pre><a name="23920"></a>
class Test {
<a name="23921"></a>	public static void main(String[] args) {
<a name="23922"></a>		int index = 1;
<a name="23923"></a>		try {
<a name="23924"></a>			skedaddle()[index=2]++;
<a name="23925"></a>		} catch (Exception e) {
<a name="23926"></a>			System.out.println(e + ", index=" + index);
<a name="23927"></a>		}
<a name="23928"></a>	}
<a name="23929"></a>	static int[] skedaddle() throws Exception {
<a name="50244"></a>		throw new Exception("Ciao");
<a name="50246"></a>	}
<a name="23930"></a>}
</pre><a name="23931"></a>
prints: 
<p><pre><a name="23932"></a>java.lang.Exception: Ciao, index=1
</pre><a name="23933"></a>
because the embedded assignment of <code>2</code> to <code>index</code> never occurs.
<p><a name="23937"></a>
If the array reference expression produces <code>null</code> instead of a reference to an array, then a <code>NullPointerException</code> is thrown at run time, but only after all parts of the array reference expression have been evaluated and only if these evaluations completed normally. Thus, the example:<p>
<pre><a name="23939"></a>
class Test {
<a name="23940"></a>
	public static void main(String[] args) {
<a name="23941"></a>		int index = 1;
<a name="23942"></a>		try {
<a name="23943"></a>			nada()[index=2]++;
<a name="23944"></a>		} catch (Exception e) {
<a name="23945"></a>			System.out.println(e + ", index=" + index);
<a name="23946"></a>		}
<a name="23947"></a>	}
<a name="23948"></a>	static int[] nada() { return null; }
<a name="23949"></a>}
</pre><a name="23950"></a>
prints:
<p><pre><a name="23951"></a>java.lang.NullPointerException, index=2
</pre><a name="23952"></a>
because the embedded assignment of <code>2</code> to <code>index</code> occurs before the check for a null 
pointer. As a related example, the program:
<p><pre><a name="36135"></a>
class Test {
<a name="36136"></a>
	public static void main(String[] args) {
<a name="36137"></a>		int[] a = null;
<a name="36138"></a>		try {
<a name="36139"></a>			int i = a[vamoose()];
<a name="36140"></a>			System.out.println(i);
<a name="36141"></a>		} catch (Exception e) {
<a name="36142"></a>			System.out.println(e);
<a name="36143"></a>		}
<a name="36144"></a>	}
<a name="36145"></a>
	static int vamoose() throws Exception {
<a name="36146"></a>		throw new Exception("Twenty-three skidoo!");
<a name="36147"></a>	}
<a name="36148"></a>}
</pre><a name="36149"></a>
always prints:
<p><pre><a name="36150"></a>java.lang.Exception: Twenty-three skidoo!
</pre><a name="36151"></a>
A <code>NullPointerException</code> never occurs, because the index expression must be 
completely evaluated before any part of the indexing operation occurs, and that 
includes the check as to whether the value of the left-hand operand is <code>null</code>.
<p><a name="36254"></a>
<h2>15.13    Postfix Expressions</h2>
<a name="39432"></a>
Postfix expressions include uses of the postfix <code>++</code> and <code>--</code> operators. Also, as discussed
in <a href="15.doc.html#23302">&#167;15.7</a>, names are not considered to be primary expressions, but are handled
separately in the grammar to avoid certain ambiguities. They become 
interchangeable only here, at the level of precedence of postfix expressions.
<p><ul><pre>
<i>PostfixExpression:<br>
	Primary<br>
	ExpressionName<br>
	PostIncrementExpression<br>
	PostDecrementExpression
</i></pre></ul><a name="4984"></a>
<h3>15.13.1    Names</h3>
<a name="41310"></a>
A name occurring in an expression may be, syntactically, an <i>ExpressionName</i> 
<a href="6.doc.html#20569">(&#167;6.5)</a>. The meaning of such an <i>ExpressionName</i> depends on its form:
<p><ul><a name="236664"></a>
<li>If it is a simple name, that is, just an <i>Identifier</i>, then there are two cases:
<ul>
<a name="237228"></a>
<li>If the <i>Identifier</i> occurs within the scope of a parameter or local variable named by that same <i>Identifier</i>, then the type of the <i>ExpressionName</i> is the declared type of the parameter or local variable; moreover, the value of the <i>ExpressionName</i> is a variable, namely, the parameter or local variable itself.
<a name="237229"></a>
<li>Otherwise, the <i>ExpressionName</i> is treated exactly as if it had been the field access expression <a href="15.doc.html#41267">(&#167;15.10)</a>:
</ul>
<a name="236761"></a><code>	 this.</code><i>Identifier
</i><ul>
<a name="236762"></a>
<li>containing the keyword <code>this</code> <a href="15.doc.html#31980">(&#167;15.7.2)</a>.
</ul>
<a name="237236"></a>
<li>Otherwise, if it is a qualified name of the form <i>PackageName</i> <code>.</code> <i>Identifier</i>, then a compile-time error occurs.
<a name="237240"></a>
<li>Otherwise, if it is a qualified name of the form <i>TypeName</i> <code>.</code> <i>Identifier</i>, then it is refers to a <code>static</code> field of the class or interface named by the <i>TypeName</i>. A compile-time error occurs if <i>TypeName</i> does not name a class or interface. A compile-time error occurs if the class or interface named by <i>TypeName</i> does not contain an accessible static field named by the <i>Identifier</i>. The type of the <i>ExpressionName</i> is the declared type of the <code>static</code> field. The value of the <i>ExpressionName</i> is a variable, namely, the <code>static</code> field itself.
<a name="236702"></a>
<li>Otherwise, it is a qualified name of the form <i>Ename</i> <code>.</code> <i>Identifier</i>, where <i>Ename</i> is itself an <i>ExpressionName</i>, and the <i>ExpressionName</i> is treated exactly as if it had been the field access expression <a href="15.doc.html#41267">(&#167;15.10)</a>:
<a name="236763"></a>	(<i>Ename</i>).<i>Identifier
</i></ul><ul><a name="236764"></a>
<br><br>containing a parenthesized expression <a href="15.doc.html#236822">(&#167;15.7.3)</a>.
</ul><a name="39438"></a>
<h3>15.13.2    Postfix Increment Operator <code>++</code></h3>
<ul><pre>
<i>PostIncrementExpression:<br>
</i>	<i>PostfixExpression</i><code> ++
</code></pre></ul><a name="40093"></a>
A postfix expression followed by a <code>++</code> operator is a postfix increment expression. The result of the postfix expression must be a variable of a numeric type, or a compile-time error occurs. The type of the postfix increment expression is the type of the variable. The result of the postfix increment expression is not a variable, but a value.<p>
<a name="39658"></a>
At run time, if evaluation of the operand expression completes abruptly, then the postfix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value <code>1</code> is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion <a href="5.doc.html#175672">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the postfix increment expression is the value of the variable <i>before </i>the new value is stored.<p>
<a name="41336"></a>
A variable that is declared <code>final</code> cannot be incremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix increment operator.<p>
<a name="4987"></a>
<h3>15.13.3    Postfix Decrement Operator <code>--</code></h3>
<ul><pre>
<i>PostDecrementExpression:<br>
</i>	<i>PostfixExpression</i><code> --
</code></pre></ul><a name="40094"></a>
A postfix expression followed by a <code>--</code> operator is a postfix decrement expression. The result of the postfix expression must be a variable of a numeric type, or a compile-time error occurs. The type of the postfix decrement expression is the type of the variable. The result of the postfix decrement expression is not a variable, but a value.<p>
<a name="39668"></a>
At run time, if evaluation of the operand expression completes abruptly, then the postfix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value <code>1</code> is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion <a href="5.doc.html#175672">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the postfix decrement expression is the value of the variable <i>before </i>the new value is stored.<p>
<a name="41352"></a>
A variable that is declared <code>final</code> cannot be decremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a postfix decrement operator.<p>
<a name="4990"></a>
<h2>15.14    Unary Operators</h2>
<a name="31520"></a>
The <i>unary operators</i> include <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, and cast operators. Expressions 
with unary operators group right-to-left, so that <code>-~x</code> means the same as <code>-(~x)</code>.
<p><ul><pre>
<i>UnaryExpression</i>:<br>
<code>	</code><i>PreIncrementExpression<br>
</i><code>	</code><i>PreDecrementExpression<br>
</i><code>	+ </code><i>UnaryExpression<br>
</i>	<code>- </code><i>UnaryExpression<br>
</i>	<i>UnaryExpressionNotPlusMinus
</i>
<i>PreIncrementExpression</i>:<br>
<code>	++ </code><i>UnaryExpression
</i>
<i>PreDecrementExpression</i>:<br>
	<code>-- </code><i>UnaryExpression
</i>
<i>UnaryExpressionNotPlusMinus</i><code>:<br>
	</code><i>PostfixExpression<br>
</i><code>	~ </code><i>UnaryExpression<br>
</i>	<code>! </code><i>UnaryExpression<br>
</i><code>	</code><i>CastExpression
</i></pre></ul><a name="29719"></a>
The following productions from <a href="15.doc.html#238146">&#167;15.15</a> are repeated here for convenience:
<p><ul><pre>
<i>CastExpression:<br>
</i><code>	( </code><i>PrimitiveType</i><code> ) </code><i>UnaryExpression<br>
</i><code>	( </code><i>ReferenceType</i><code> )&#32;</code><i>UnaryExpressionNotPlusMinus
</i></pre></ul><a name="22479"></a>
This portion of the Java grammar contains some tricks to avoid two potential syntactic ambiguities.<p>
<a name="22502"></a>
The first potential ambiguity would arise in expressions such as <code>(p)+q</code>, which looks, to a C or C++ programmer, as though it could be either be a cast to type <code>p</code> of a unary <code>+</code> operating on <code>q</code>, or a binary addition of two quantities <code>p</code> and <code>q</code>. In C and C++, the parser handles this problem by performing a limited amount of semantic analysis as it parses, so that it knows whether <code>p</code> is the name of a type or the name of a variable.<p>
<a name="39495"></a>
Java takes a different approach. The result of the <code>+</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a cast of a unary expression. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a binary arithmetic operation. Similar remarks apply to the <code>-</code> operator. The grammar shown above splits <i>CastExpression</i> into two cases to make this distinction. The nonterminal <i>UnaryExpression </i>includes all unary operator, but the nonterminal <i>UnaryExpressionNotPlusMinus</i> excludes uses of all unary operators that could also be binary operators, which in Java are <code>+</code> and <code>-</code>.<p>
<a name="39551"></a>
The second potential ambiguity is that the expression <code>(p)++</code> could, to a C or C++ programmer, appear to be either a postfix increment of a parenthesized expression or the beginning of a cast, for example, in <code>(p)++q</code>. As before, parsers for C and C++ know whether <code>p</code> is the name of a type or the name of a variable. But a parser using only one-token lookahead and no semantic analysis during the parse would not be able to tell, when <code>++</code> is the lookahead token, whether <code>(p)</code> should be considered a <i>Primary</i> expression or left alone for later consideration as part of a <i>CastExpression</i>.<p>
<a name="39554"></a>
In Java, the result of the <code>++</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a cast of a prefix increment expression, and there had better be an operand such as <code>q</code> following the <code>++</code>. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a postfix increment of <code>p</code>. Similar remarks apply to the <code>--</code> operator. The nonterminal <i>UnaryExpressionNotPlusMinus</i> therefore also excludes uses of the prefix operators <code>++</code> and <code>--</code>.<p>
<a name="39547"></a>
<h3>15.14.1    Prefix Increment Operator <code>++</code></h3>
<a name="5002"></a>
A unary expression preceded by a <code>++</code> operator is a prefix increment expression. 
The result of the unary expression must be a variable of a numeric type, or a compile-time
error occurs. The type of the prefix increment expression is the type of 
the variable. The result of the prefix increment expression is not a variable, but a 
value.
<p><a name="39621"></a>
At run time, if evaluation of the operand expression completes abruptly, then the prefix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value <code>1</code> is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion <a href="5.doc.html#175672">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the prefix increment expression is the value of the variable <i>after </i>the new value is stored.<p>
<a name="239134"></a>
A variable that is declared <code>final</code> cannot be incremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix increment operator.<p>
<a name="239136"></a>
<h3>15.14.2    Prefix Decrement Operator <code>--</code></h3>
<a name="5005"></a>
A unary expression preceded by a <code>--</code> operator is a prefix decrement expression. 
The result of the unary expression must be a variable of a numeric type, or a compile-time
error occurs. The type of the prefix decrement expression is the type of 
the variable. The result of the prefix decrement expression is not a variable, but a 
value.
<p><a name="39634"></a>
At run time, if evaluation of the operand expression completes abruptly, then the prefix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value <code>1</code> is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> is performed on the value <code>1</code> and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion <a href="5.doc.html#175672">(&#167;5.1.3)</a> to the type of the variable before it is stored. The value of the prefix decrement expression is the value of the variable <i>after </i>the new value is stored.<p>
<a name="41323"></a>
A variable that is declared <code>final</code> cannot be decremented, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable. Thus, it cannot be used as the operand of a prefix decrement operator.<p>
<a name="24924"></a>
<h3>15.14.3    Unary Plus Operator <code>+</code></h3>
<a name="24926"></a>
The type of the operand expression of the unary <code>+</code> operator must be a primitive 
numeric type, or a compile-time error occurs. Unary numeric promotion <a href="5.doc.html#170952">(&#167;5.6.1)</a> 
is performed on the operand. The type of the unary plus expression is the promoted
type of the operand. The result of the unary plus expression is not a variable,
but a value, even if the result of the operand expression is a variable.
<p><a name="39701"></a>
At run time, the value of the unary plus expression is the promoted value of the operand.<p>
<a name="236345"></a>
<h3>15.14.4    Unary Minus Operator <code>-</code></h3>
<a name="39711"></a>
The type of the operand expression of the unary <code>-</code> operator must be a primitive 
numeric type, or a compile-time error occurs. Unary numeric promotion <a href="5.doc.html#170952">(&#167;5.6.1)</a> 
is performed on the operand. The type of the unary minus expression is the promoted
type of the operand.
<p><a name="39715"></a>
At run time, the value of the unary plus expression is the arithmetic negation of the promoted value of the operand.<p>
<a name="79921"></a>
For integer values, negation is the same as subtraction from zero. Java uses two's-complement representation for integers, and the range of two's-complement values is not symmetric, so negation of the maximum negative <code>int</code> or <code>long</code> results in that same maximum negative number. Overflow occurs in this case, but no exception is thrown. For all integer values <code>x</code>, <code>-x</code> equals <code>(~x)+1</code>.<p>
<a name="5013"></a>
For floating-point values, negation is not the same as subtraction from zero, because if <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> equals <code>+0.0</code>, but <code>-x</code> equals <code>-0.0</code>. Unary minus merely inverts the sign of a floating-point number. Special cases of interest:<p>
<ul><a name="5014"></a>
<li>If the operand is NaN, the result is NaN (recall that NaN has no sign).
<a name="5015"></a>
<li>If the operand is an infinity, the result is the infinity of opposite sign.
<a name="5016"></a>
<li>If the operand is a zero, the result is the zero of opposite sign.
</ul><a name="5017"></a>
<h3>15.14.5    Bitwise Complement Operator <code>~</code></h3>
<a name="39739"></a>
The type of the operand expression of the unary <code>~</code> operator must be a primitive 
integral type, or a compile-time error occurs. Unary numeric promotion <a href="5.doc.html#170952">(&#167;5.6.1)</a> is 
performed on the operand. The type of the unary bitwise complement expression 
is the promoted type of the operand.
<p><a name="39743"></a>
At run time, the value of the unary bitwise complement expression is the bitwise complement of the promoted value of the operand; note that, in all cases, <code>~x</code> &#32;equals <code>(-x)-1</code>.<p>
<a name="13350"></a>
<h3>15.14.6    Logical Complement Operator <code>!</code></h3>
<a name="39767"></a>
The type of the operand expression of the unary <code>!</code> operator must be <code>boolean,</code> or a 
compile-time error occurs. The type of the unary logical complement expression 
is <code>boolean</code>.
<p><a name="39771"></a>
At run time, the value of the unary logical complement expression is <code>true</code> if the operand value is <code>false</code> and <code>false</code> if the operand value is <code>true</code>.<p>
<a name="238146"></a>
<h2>15.15    Cast Expressions</h2>
<a name="236464"></a>
A cast expression converts, at run time, a value of one numeric type to a similar 
value of another numeric type; or confirms, at compile time, that the type of an 
expression is <code>boolean</code>; or checks, at run time, that a reference value refers to an 
object whose class is compatible with a specified reference type.
<p><ul><pre>
<i>CastExpression:<br>
</i><code>	( </code><i>PrimitiveType</i><code> </code><i>Dims</i><sub><i>opt</i></sub><code> ) </code><i>UnaryExpression<br>
</i><code>	( </code><i>ReferenceType</i><code> ) </code><i>UnaryExpressionNotPlusMinus
</i></pre></ul><a name="39813"></a>
See <a href="15.doc.html#4990">&#167;15.14</a> for a discussion of the distinction between <i>UnaryExpression</i> and <i>UnaryExpressionNotPlusMinus</i>.<p>
<a name="39826"></a>
The type of a cast expression is the type whose name appears within the parentheses. (The parentheses and the type they contain are sometimes called the <i>cast operator</i>.) The result of a cast expression is not a variable, but a value, even if the result of the operand expression is a variable.<p>
<a name="39835"></a>
At run time, the operand value is converted by casting conversion <a href="5.doc.html#176921">(&#167;5.4)</a> to the type specified by the cast operator.<p>
<a name="239827"></a>
Not all casts are permitted by the Java language. Some casts result in an error at compile time. For example, a primitive value may not be cast to a reference type. Some casts can be proven, at compile time, always to be correct at run time. For example, it is always correct to convert a value of a class type to the type of its superclass; such a cast should require no special action at run time. Finally, some casts cannot be proven to be either always correct or always incorrect at compile time. Such casts require a test at run time. A <code>ClassCastException</code> is thrown if a cast is found at run time to be impermissible.<p>
<a name="239829"></a>
<h2>15.16    Multiplicative Operators</h2>
<a name="5029"></a>
The operators <code>*</code>, <code>/</code>, and <code>%</code> are called the <i>multiplicative operators</i>. They have the 
same precedence and are syntactically left-associative (they group left-to-right).
<p><ul><pre>
<i>MultiplicativeExpression:<br>
</i>	<i>UnaryExpression<br>
</i>	<i>MultiplicativeExpression</i><code> * </code><i>UnaryExpression<br>
</i>	<i>MultiplicativeExpression</i><code> / </code><i>UnaryExpression<br>
</i>	<i>MultiplicativeExpression</i><code> % </code><i>UnaryExpression
</i></pre></ul><a name="39873"></a>
The type of each of the operands of a multiplicative operator must be a primitive numeric type, or a compile-time error occurs. Binary numeric promotion is performed on the operands <a href="5.doc.html#170983">(&#167;5.6.2)</a>. The type of a multiplicative expression is the promoted type of its operands. If this promoted type is <code>int</code> or <code>long</code>, then integer arithmetic is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point arithmetic is performed.<p>
<a name="5036"></a>
<h3>15.16.1    Multiplication Operator <code>*</code></h3>
<a name="5037"></a>
The binary <code>*</code> operator performs multiplication, producing the product of its operands.
Multiplication is a commutative operation if the operand expressions have 
no side effects. While integer multiplication is associative when the operands are 
all of the same type, floating-point multiplication is not associative.
<p><a name="79991"></a>
If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two's-complement format. As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.<p>
<a name="5039"></a>
The result of a floating-point multiplication is governed by the rules of IEEE 754 arithmetic:<p>
<ul><a name="5040"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5041"></a>
<li>If the result is not NaN, the sign of the result is positive if both operands have the same sign, and negative if the operands have different signs.
<a name="24701"></a>
<li>Multiplication of an infinity by a zero results in NaN.
<a name="24702"></a>
<li>Multiplication of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
<a name="5044"></a>
<li>In the remaining cases, where neither an infinity or NaN is involved, the product is computed. If the magnitude of the product is too large to represent, we say the operation overflows. The result is then an infinity of appropriate sign. If the magnitude is too small to represent, we say the operation underflows; the result is then a zero of appropriate sign. Otherwise, the product is rounded to the nearest representable value using IEEE 754 round-to-nearest mode. The Java language requires support of gradual underflow as defined by IEEE 754 <a href="4.doc.html#9249">(&#167;4.2.4)</a>.
</ul><a name="5045"></a>
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a multiplication operator <code>*</code> never throws a run-time exception.<p>
<a name="5047"></a>
<h3>15.16.2    Division Operator <code>/</code></h3>
<a name="5048"></a>
The binary <code>/</code> operator performs division, producing the quotient of its operands. 
The left-hand operand is the dividend and the right-hand operand is the divisor.
<p><a name="45471"></a>
Integer division rounds toward <code>0</code>. That is, the quotient produced for operands <i>n</i> and <i>d</i> that are integers after binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> is an integer value <i>q</i> whose magnitude is as large as possible while satisfying <img src="15.doc.anc4.gif">; moreover, <i>q </i>is positive when <img src="15.doc.anc5.gif">and <i>n</i> and <i>d</i> have the same sign, but <i>q</i> is negative when <img src="15.doc.anc6.gif">and <i>n</i> and <i>d </i>have opposite signs. There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for its type, and the divisor is <code>-1</code>, then integer overflow occurs and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case. On the other hand, if the value of the divisor in an integer division is <code>0</code>, then an <code>ArithmeticException</code> is thrown.<p>
<a name="45481"></a>
The result of a floating-point division is determined by the specification of IEEE arithmetic:<p>
<ul><a name="5054"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5055"></a>
<li>If the result is not NaN, the sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
<a name="5056"></a>
<li>Division of an infinity by an infinity results in NaN.
<a name="5057"></a>
<li>Division of an infinity by a finite value results in a signed infinity. The sign is determined by the rule stated above.
<a name="5058"></a>
<li>Division of a finite value by an infinity results in a signed zero. The sign is determined by the rule stated above.
<a name="236610"></a>
<li>Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero. The sign is determined by the rule stated above.
<a name="236611"></a>
<li>Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule stated above.
<a name="236612"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed. If the magnitude of the quotient is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, we say the operation underflows and the result is then a zero of appropriate sign. Otherwise, the quotient is rounded to the nearest representable value using IEEE 754 round-to-nearest mode. The Java language requires support of gradual underflow as defined by IEEE 754 <a href="4.doc.html#9249">(&#167;4.2.4)</a>.
</ul><a name="5062"></a>
Despite the fact that overflow, underflow, division by zero, or loss of information may occur, evaluation of a floating-point division operator <code>/</code> never throws a run-time exception.<p>
<a name="24956"></a>
<h3>15.16.3    Remainder Operator <code>%</code></h3>
<a name="24958"></a>
The binary <code>%</code> operator is said to yield the remainder of its operands from an 
implied division; the left-hand operand is the dividend and the right-hand operand 
is the divisor.
<p><a name="40092"></a>
In C and C++, the remainder operator accepts only integral operands, but in Java, it also accepts floating-point operands.<p>
<a name="15723"></a>
The remainder operation for operands that are integers after binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> produces a result value such that <code>(a/b)*b+(a%b)</code> is equal to <code>a</code>. This identity holds even in the special case that the dividend is the negative integer of largest possible magnitude for its type and the divisor is <code>-1</code> (the remainder is <code>0</code>). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor. If the value of the divisor for an integer remainder operator is <code>0</code>, then an <code>ArithmeticException</code> is thrown.<p>
<a name="40096"></a>
Examples:<p>
<pre><a name="40099"></a>
5%3 produces 2							(note that 5/3 produces 1)
<a name="40103"></a>5%(-3) produces 2							(note that 5/(-3) produces -1)
<a name="40107"></a>(-5)%3 produces -2							(note that (-5)/3 produces -1)
<a name="40111"></a>(-5)%(-3) produces -2							(note that (-5)/(-3) produces 1)
</pre><a name="5067"></a>
The result of a floating-point remainder operation as computed by the <code>%</code> operator is <i>not</i> the same as that produced by the remainder operation defined by IEEE 754. The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is <i>not</i> analogous to that of the usual integer remainder operator. Instead, the Java language defines <code>%</code> on floating-point operations to behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the C library function <code>fmod</code>. The IEEE 754 remainder operation may be computed by the Java library routine <code>Math.IEEEremainder</code> <a href="javalang.doc10.html#13956">(&#167;20.11.14)</a>.<p>
<a name="5068"></a>
The result of a Java floating-point remainder operation is determined by the rules of IEEE arithmetic:<p>
<ul><a name="5069"></a>
<li>If either operand is NaN, the result is NaN.
<a name="5070"></a>
<li>If the result is not NaN, the sign of the result equals the sign of the dividend.
<a name="5071"></a>
<li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
<a name="5072"></a>
<li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.
<a name="5073"></a>
<li>If the dividend is a zero and the divisor is finite, the result equals the dividend.
<a name="5074"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder <i>r</i> from the division of a dividend <i>n</i> by a divisor <i>d</i> is defined by the mathematical relation <img src="15.doc.anc.gif"> where <i>q</i> is an integer that is negative only if <img src="15.doc.anc1.gif"> is negative and positive only if <img src="15.doc.anc2.gif"> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <i>n</i> and <i>d</i>.
</ul><a name="5084"></a>
Evaluation of a floating-point remainder operator <code>%</code> never throws a run-time exception, even if the right-hand operand is zero. Overflow, underflow, or loss of precision cannot occur.<p>
<a name="40146"></a>
Examples:<p>
<pre><a name="40147"></a>
5.0%3.0 produces 2.0
<a name="40148"></a>5.0%(-3.0) produces 2.0
<a name="40149"></a>(-5.0)%3.0 produces -2.0
<a name="40150"></a>(-5.0)%(-3.0) produces -2.0
</pre><a name="15746"></a>
<h2>15.17    Additive Operators</h2>
<a name="15749"></a>
The operators <code>+</code> and <code>-</code> are called the <i>additive operators</i>. They have the same precedence
and are syntactically left-associative (they group left-to-right).
<p><ul><pre>
<i>AdditiveExpression:<br>
</i>	<i>MultiplicativeExpression<br>
</i>	<i>AdditiveExpression</i><code> + </code><i>MultiplicativeExpression<br>
</i><code>	</code><i>AdditiveExpression</i><code> - </code><i>MultiplicativeExpression
</i></pre></ul><a name="39987"></a>
If the type of either operand of a + operator is <code>String</code>, then the operation is string concatenation.<p>
<a name="39998"></a>
Otherwise, the type of each of the operands of the <code>+</code> operator must be a primitive numeric type, or a compile-time error occurs. <p>
<a name="40002"></a>
In every case, the type of each of the operands of the binary <code>-</code> operator must be a primitive numeric type, or a compile-time error occurs. <p>
<a name="39990"></a>
<h3>15.17.1    String Concatenation Operator <code>+</code></h3>
<a name="7894"></a>
If only one operand expression is of type <code>String</code>, then string conversion is performed
on the other operand to produce a string at run time. The result is a reference
to a newly created <code>String</code> object that is the concatenation of the two 
operand strings. The characters of the left-hand operand precede the characters of 
the right-hand operand in the newly created string.
<p><a name="40220"></a>
<h4>15.17.1.1    String Conversion</h4>
<a name="40222"></a>
Any type may be converted to type <code>String</code> by <i>string conversion</i>.
<p><a name="22621"></a>
A value <i>x</i> of primitive type <i>T</i> is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression:<p>
<ul><a name="40316"></a>
<li>If <i>T</i> is <code>boolean</code>, then use <code>new</code> <code>Boolean(</code><i>x</i><code>)</code> <a href="javalang.doc3.html#14344">(&#167;20.4)</a>.
<a name="40320"></a>
<li>If <i>T</i> is <code>char</code>, then use <code>new</code> <code>Character(</code><i>x</i><code>)</code> <a href="javalang.doc4.html#14345">(&#167;20.5)</a>.
<a name="40265"></a>
<li>If <i>T</i> is <code>byte</code>, <code>short</code>, or <code>int</code>, then use <code>new</code> <code>Integer(</code><i>x</i><code>)</code> <a href="javalang.doc6.html#14348">(&#167;20.7)</a>.
<a name="40272"></a>
<li>If <i>T</i> is <code>long</code>, then use <code>new</code> <code>Long(</code><i>x</i><code>)</code> <a href="javalang.doc7.html#46750">(&#167;20.8)</a>.
<a name="40279"></a>
<li>If <i>T</i> is <code>float</code>, then use <code>new</code> <code>Float(</code><i>x</i><code>)</code> <a href="javalang.doc8.html#14394">(&#167;20.9)</a>.
<a name="40286"></a>
<li>If <i>T</i> is <code>double</code>, then use <code>new</code> <code>Double(</code><i>x</i><code>)</code> <a href="javalang.doc9.html#14390">(&#167;20.10)</a>.
</ul><a name="40362"></a>
This reference value is then converted to type <code>String</code> by string conversion.
<p><a name="22740"></a>
Now only reference values need to be considered. If the reference is <code>null</code>, it is converted to the string "<code>null</code>" (four ASCII characters <code>n</code>, <code>u</code>, <code>l</code>, <code>l</code>). Otherwise, the conversion is performed as if by an invocation of the <code>toString</code> method of the referenced object with no arguments; but if the result of invoking the <code>toString</code> method is <code>null</code>, then the string "<code>null</code>" is used instead. The <code>toString</code> method <a href="javalang.doc1.html#1152">(&#167;20.1.2)</a> is defined by the primordial class <code>Object</code> <a href="javalang.doc1.html#46442">(&#167;20.1)</a>; many classes override it, notably <code>Boolean</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double,</code> and <code>String</code>.<p>
<a name="40226"></a>
<h4>15.17.1.2    Optimization of String Concatenation</h4>
<a name="40227"></a>
An implementation may choose to perform conversion and concatenation in one 
step to avoid creating and then discarding an intermediate <code>String</code> object. To 
increase the performance of repeated string concatenation, a Java compiler may 
use the <code>StringBuffer</code> class <a href="javalang.doc12.html#14461">(&#167;20.13)</a> or a similar technique to reduce the number 
of intermediate <code>String</code> objects that are created by evaluation of an expression.
<p><a name="22668"></a>
For primitive objects, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.<p>
<a name="40423"></a>
<h4>15.17.1.3    Examples of String Concatenation</h4>
<a name="40221"></a>
The example expression:
<p><pre><a name="21340"></a>"The square root of 2 is " + Math.sqrt(2)
</pre><a name="21343"></a>
produces the result:
<p><pre><a name="40506"></a>"The square root of 2 is 1.4142135623730952"
</pre><a name="21344"></a>
The + operator is syntactically left-associative, no matter whether it is later determined by type analysis to represent string concatenation or addition. In some cases care is required to get the desired result. For example, the expression:<p>
<pre><a name="40517"></a>a + b + c
</pre><a name="40518"></a>
is always regarded as meaning:
<p><pre><a name="40519"></a>(a + b) + c
</pre><a name="40520"></a>
Therefore the result of the expression:
<p><pre><a name="40521"></a>1 + 2 + " fiddlers"
</pre><a name="40522"></a>
is:
<p><pre><a name="40523"></a>"3 fiddlers"
</pre><a name="40524"></a>
but the result of:
<p><pre><a name="40525"></a>"fiddlers " + 1 + 2
</pre><a name="40526"></a>
is:
<p><pre><a name="238151"></a>"fiddlers 12"
</pre><a name="238156"></a>
In this jocular little example:<p>
<pre><a name="238165"></a>
class Bottles {
<a name="40430"></a>
	static void printSong(Object stuff, int n) {
<a name="40431"></a>		String plural = "s";
<a name="40432"></a>		loop: while (true) {
<a name="40433"></a>			System.out.println(n + " bottle" + plural
<a name="40434"></a>				+ " of " + stuff + " on the wall,");
<a name="40435"></a>			System.out.println(n + " bottle" + plural
<a name="40436"></a>				+ " of " + stuff + ";");
<a name="40437"></a>			System.out.println("You take one down "
<a name="40451"></a>				+ "and pass it around:");
<a name="40438"></a>			--n;
<a name="40439"></a>			plural = (n == 1) ? "" : "s";
<a name="40440"></a>			if (n == 0)
<a name="40441"></a>				break loop;
<a name="40442"></a>			System.out.println(n + " bottle" + plural
<a name="40443"></a>				+ " of " + stuff + " on the wall!");
<a name="40444"></a>			System.out.println();
<a name="40445"></a>		}
<a name="40446"></a>		System.out.println("No bottles of " +
<a name="43970"></a>								stuff + " on the wall!");
<a name="40447"></a>	}
<br><a name="40448"></a>}
</pre><a name="40427"></a>
the method <code>printSong</code> will print a version of a children's song. Popular values 
for stuff include <code>"pop"</code> and <code>"beer"</code>; the most popular value for <code>n</code> is <code>100</code>. Here is 
the output that results from <code>Bottles.printSong("slime", 3)</code>:
<p><pre><a name="40461"></a>
3 bottles of slime on the wall,
<a name="40462"></a>3 bottles of slime;
<a name="40463"></a>You take one down and pass it around:
<a name="40464"></a>2 bottles of slime on the wall!
<a name="40465"></a>
<a name="40466"></a>2 bottles of slime on the wall,
<a name="40467"></a>2 bottles of slime;
<a name="40468"></a>You take one down and pass it around:
<a name="40469"></a>1 bottle of slime on the wall!
<a name="40470"></a>
<a name="40471"></a>1 bottle of slime on the wall,
<a name="40472"></a>1 bottle of slime;
<a name="40473"></a>You take one down and pass it around:
<a name="40474"></a>No bottles of slime on the wall!
</pre><a name="40459"></a>
In the code, note the careful conditional generation of the singular "<code>bottle</code>" when appropriate rather than the plural "<code>bottles</code>"; note also how the string concatenation operator was used to break the long constant string:<p>
<pre><a name="40479"></a>"You take one down and pass it around:"
</pre><a name="40485"></a>
into two pieces to avoid an inconveniently long line in the source code.
<p><a name="13510"></a>
<h3>15.17.2    Additive Operators (<code>+</code> and <code>-</code>) for Numeric Types</h3>
<a name="235182"></a>
The binary <code>+</code> operator performs addition when applied to two operands of numeric 
type, producing the sum of the operands. The binary <code>-</code> operator performs subtraction,
producing the difference of two numeric operands.
<p><a name="39970"></a>
Binary numeric promotion is performed on the operands <a href="5.doc.html#170983">(&#167;5.6.2)</a>. The type of an additive expression on numeric operands is the promoted type of its operands. If this promoted type is <code>int</code> or <code>long</code>, then integer arithmetic is performed; if this promoted type is <code>float</code> or <code>double</code>, then floating-point arithmetic is performed.<p>
<a name="39968"></a>
Addition is a commutative operation if the operand expressions have no side effects. Integer addition is associative when the operands are all of the same type, but floating-point addition is not associative.<p>
<a name="13512"></a>
If an integer addition overflows, then the result is the low-order bits of the mathematical sum as represented in some sufficiently large two's-complement format. If overflow occurs, then the sign of the result is not the same as the sign of the mathematical sum of the two operand values.<p>
<a name="13513"></a>
The result of a floating-point addition is determined using the following rules of IEEE arithmetic:<p>
<ul><a name="13514"></a>
<li>If either operand is NaN, the result is NaN.
<a name="13515"></a>
<li>The sum of two infinities of opposite sign is NaN.
<a name="13516"></a>
<li>The sum of two infinities of the same sign is the infinity of that sign.
<a name="13517"></a>
<li>The sum of an infinity and a finite value is equal to the infinite operand.
<a name="13518"></a>
<li>The sum of two zeros of opposite sign is positive zero.
<a name="13519"></a>
<li>The sum of two zeros of the same sign is the zero of that sign.
<a name="13520"></a>
<li>The sum of a zero and a nonzero finite value is equal to the nonzero operand.
<a name="13521"></a>
<li>The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
<a name="13522"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the sum is computed. If the magnitude of the sum is too large to represent, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, we say the operation underflows; the result is then a zero of appropriate sign. Otherwise, the sum is rounded to the nearest representable value using IEEE 754 round-to-nearest mode. The Java language requires support of gradual underflow as defined by IEEE 754 <a href="4.doc.html#9249">(&#167;4.2.4)</a>.
</ul><a name="13523"></a>
The binary <code>-</code> operator performs subtraction when applied to two operands of numeric type producing the difference of its operands; the left-hand operand is the minuend and the right-hand operand is the subtrahend. For both integer and floating-point subtraction, it is always the case that <code>a-b</code> produces the same result as <code>a+(-b)</code>. Note that, for integer values, subtraction from zero is the same as negation. However, for floating-point operands, subtraction from zero is <i>not</i> the same as negation, because if <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> equals <code>+0.0</code>, but <code>-x</code> equals <code>-0.0</code>. <p>
<a name="13524"></a>
Despite the fact that overflow, underflow, or loss of information may occur, evaluation of a numeric additive operator never throws a run-time exception.<p>
<a name="5121"></a>
<h2>15.18    Shift Operators</h2>
<a name="5122"></a>
The <i>shift operators</i> include left shift <code>&lt;&lt;</code>, signed right shift <code>&gt;&gt;</code>, and unsigned right 
shift <code>&gt;&gt;&gt;</code>; they are syntactically left-associative (they group left-to-right). The left-
hand operand of a shift operator is the value to be shifted; the right-hand operand 
specifies the shift distance.
<p><ul><pre>
<i>ShiftExpression:<br>
</i>	<i>AdditiveExpression<br>
</i>	<i>ShiftExpression</i><code> &lt;&lt; </code><i>AdditiveExpression<br>
</i>	<i>ShiftExpression</i><code> &gt;&gt; </code><i>AdditiveExpression<br>
</i>	<i>ShiftExpression</i><code> &gt;&gt;&gt; </code><i>AdditiveExpression
</i></pre></ul><a name="40554"></a>
The type of each of the operands of a shift operator must be a primitive integral type, or a compile-time error occurs. Binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> is <i>not</i> performed on the operands; rather, unary numeric promotion <a href="5.doc.html#170952">(&#167;5.6.1)</a> is performed on each operand separately. The type of the shift expression is the promoted type of the left-hand operand.<p>
<a name="13680"></a>
If the promoted type of the left-hand operand is <code>int</code>, only the five lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator <code>&amp;</code> <a href="15.doc.html#5233">(&#167;15.21.1)</a> with the mask value <code>0x1f</code>. The shift distance actually used is therefore always in the range 0 to 31, inclusive.<p>
<a name="19183"></a>
If the promoted type of the left-hand operand is <code>long</code>, then only the six lowest-order bits of the right-hand operand are used as the shift distance. It is as if the right-hand operand were subjected to a bitwise logical AND operator <code>&amp;</code> <a href="15.doc.html#5233">(&#167;15.21.1)</a> with the mask value <code>0x3f</code>. The shift distance actually used is therefore always in the range 0 to 63, inclusive.<p>
<a name="19187"></a>
At run time, shift operations are performed on the two's complement integer representation of the value of the left operand.<p>
<a name="19188"></a>
The value of <code>n&lt;&lt;s</code> is <code>n</code> left-shifted <code>s</code> bit positions; this is equivalent (even if overflow occurs) to multiplication by two to the power <code>s</code>.<p>
<a name="5140"></a>
The value of <code>n&gt;&gt;s</code> is <code>n</code> right-shifted <code>s</code> bit positions with sign-extension. The resulting value is <img src="15.doc.anc3.gif">. For nonnegative values of <code>n</code>, this is equivalent to truncating integer division, as computed by the integer division operator <code>/</code>, by two to the power <code>s</code>.<p>
<a name="40638"></a>
The value of <code>n&gt;&gt;&gt;s</code> is <code>n</code> right-shifted <code>s</code> bit positions with zero-extension. If <code>n</code> is positive, then the result is the same as that of <code>n&gt;&gt;s</code>; if <code>n</code> is negative, the result is equal to that of the expression <code>(n&gt;&gt;s)+(2&lt;&lt;~s)</code> if the type of the left-hand operand is <code>int</code>, and to the result of the expression <code>(n&gt;&gt;s)+(2L&lt;&lt;~s)</code> if the type of the left-hand operand is <code>long</code>. The added term <code>(2&lt;&lt;~s)</code> or <code>(2L&lt;&lt;~s)</code> cancels out the propagated sign bit. (Note that, because of the implicit masking of the right-hand operand of a shift operator, <code>~s</code> as a shift distance is equivalent to <code>31-s</code> when shifting an <code>int</code> value and to <code>63-s</code> when shifting a <code>long</code> value.)<p>
<a name="40641"></a>
<h2>15.19    Relational Operators</h2>
<a name="139595"></a>
The <i>relational operators</i> are syntactically left-associative (they group left-to-
right), but this fact is not useful; for example, <code>a&lt;b&lt;c</code> parses as <code>(a&lt;b)&lt;c</code>, which is 
always a compile-time error, because the type of <code>a&lt;b</code> is always <code>boolean</code> and <code>&lt;</code> is 
not an operator on <code>boolean</code> values.
<p><ul><pre>
<i>RelationalExpression:<br>
</i>	<i>ShiftExpression<br>
</i>	<i>RelationalExpression</i><code> &lt; </code><i>ShiftExpression<br>
</i>	<i>RelationalExpression</i><code> &gt; </code><i>ShiftExpression<br>
</i>	<i>RelationalExpression</i><code> &lt;= </code><i>ShiftExpression<br>
</i>	<i>RelationalExpression</i><code> &gt;= </code><i>ShiftExpression<br>
</i>	<i>RelationalExpression</i><code> instanceof </code><i>ReferenceType
</i></pre></ul><a name="235261"></a>
The type of a relational expression is always <code>boolean</code>.
<p><a name="153654"></a>
<h3>15.19.1    Numerical Comparison Operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> </h3>
<a name="40647"></a>
The type of each of the operands of a numerical comparison operator must be a 
primitive numeric type, or a compile-time error occurs. Binary numeric promotion 
is performed on the operands <a href="5.doc.html#170983">(&#167;5.6.2)</a>. If the promoted type of the operands is <code>int</code> 
or <code>long</code>, then signed integer comparison is performed; if this promoted type is 
<code>float</code> or <code>double</code>, then floating-point comparison is performed.
<p><a name="5155"></a>
The result of a floating-point comparison, as determined by the specification of the IEEE 754 standard, is:<p>
<ul><a name="5156"></a>
<li>If either operand is NaN, then the result is <code>false</code>.
<a name="5157"></a>
<li>All values other than NaN are ordered, with negative infinity less than all finite values, and positive infinity greater than all finite values.
<a name="5158"></a>
<li>Positive zero and negative zero are considered equal. Therefore, <code>-0.0&lt;0.0</code> is <code>false</code>, for example, but <code>-0.0&lt;=0.0</code> is <code>true</code>. (Note, however, that the methods <code>Math.min</code> (<a href="javalang.doc10.html#13976">&#167;20.11.27</a>, <a href="javalang.doc10.html#13977">&#167;20.11.28</a>) and <code>Math.max</code> (<a href="javalang.doc10.html#6823">&#167;20.11.31</a>, <a href="javalang.doc10.html#6824">&#167;20.11.32</a>) treat negative zero as being strictly smaller than positive zero.)
</ul><a name="5159"></a>
Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:<p>
<ul><a name="5160"></a>
<li>The value produced by the <code>&lt;</code> operator is <code>true</code> if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5161"></a>
<li>The value produced by the <code>&lt;=</code> operator is <code>true</code> if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5162"></a>
<li>The value produced by the <code>&gt;</code> operator is <code>true</code> if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is <code>false</code>.
<a name="5163"></a>
<li>The value produced by the <code>&gt;=</code> operator is <code>true</code> if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is <code>false</code>.
</ul><a name="80289"></a>
<h3>15.19.2    Type Comparison Operator <code>instanceof</code></h3>
<a name="80291"></a>
The type of a <i>RelationalExpression</i> operand of the <code>instanceof</code> operator must be 
a reference type or the null type; otherwise, a compile-time error occurs. The <i>ReferenceType
</i> mentioned after the <code>instanceof</code> operator must denote a reference 
type; otherwise, a compile-time error occurs.
<p><a name="240816"></a>
At run time, the result of the <code>instanceof</code> operator is <code>true</code> if the value of the <i>RelationalExpression</i> is not <code>null</code> and the reference could be cast <a href="15.doc.html#238146">(&#167;15.15)</a> to the <i>ReferenceType</i> without raising a <code>ClassCastException</code>. Otherwise the result is <code>false</code>.<p>
<a name="19920"></a>
If a cast of the <i>RelationalExpression</i> to the <i>ReferenceType</i> would be rejected as a compile-time error, then the <code>instanceof</code> relational expression likewise produces a compile-time error. In such a situation, the result of the <code>instanceof</code> expression could never be <code>true</code>.<p>
<a name="238166"></a>
Consider the example program:<p>
<pre><a name="19921"></a>class Point { int x, y; }
<a name="22799"></a>class Element { int atomicNumber; }
<a name="238077"></a>class Test {
<a name="238078"></a>	public static void main(String[] args) {
<a name="238079"></a>		Point p = new Point();
<a name="22805"></a>		Element e = new Element();
<a name="22806"></a>		if (e instanceof Point) {											// compile-time error
<a name="22807"></a>			System.out.println("I get your point!");
<a name="22808"></a>			p = (Point)e;										// compile-time error
<a name="22809"></a>		}
<a name="22810"></a>	}
<a name="22811"></a>}
</pre><a name="22819"></a>
This example results in two compile-time errors. The cast <code>(Point)e</code> is incorrect 
because no instance of <code>Element</code> or any of its possible subclasses (none are shown 
here) could possibly be an instance of any subclass of <code>Point</code>. The <code>instanceof</code> 
expression is incorrect for exactly the same reason. If, on the other hand, the class 
<code>Point</code> were a subclass of <code>Element</code> (an admittedly strange notion in this example):
<p><pre><a name="40787"></a>class Point extends Element { int x, y; }
</pre><a name="40785"></a>
then the cast would be possible, though it would require a run-time check, and the 
<code>instanceof</code> expression would then be sensible and valid. The cast <code>(Point)e</code> 
would never raise an exception because it would not be executed if the value of <code>e</code> 
could not correctly be cast to type <code>Point</code>.
<p><a name="5192"></a>
<h2>15.20    Equality Operators</h2>
<a name="24723"></a>
The equality operators are syntactically left-associative (they group left-to-right), 
but this fact is essentially never useful; for example, <code>a==b==c</code> parses as 
<code>(a==b)==c</code>. The result type of <code>a==b</code> is always <code>boolean</code>, and <code>c</code> must therefore be 
of type <code>boolean</code> or a compile-time error occurs. Thus, <code>a==b==c</code> does <i>not</i> test to 
see whether <code>a</code>, <code>b</code>, and <code>c</code> are all equal.
<p><ul><pre>
<i>EqualityExpression:<br>
</i>	<i>RelationalExpression<br>
</i>	<i>EqualityExpression</i><code> == </code><i>RelationalExpression<br>
</i>	<i>EqualityExpression</i><code> != </code><i>RelationalExpression
</i></pre></ul><a name="5195"></a>
The == (equal to) and the != (not equal to) operators are analogous to the relational operators except for their lower precedence. Thus, <code>a&lt;b==c&lt;d</code> is <code>true</code> whenever <code>a&lt;b</code> and <code>c&lt;d</code> have the same truth value.<p>
<a name="5196"></a>
The equality operators may be used to compare two operands of numeric type, or two operands of type <code>boolean</code>, or two operands that are each of either reference type or the null type. All other cases result in a compile-time error. The type of an equality expression is always <code>boolean</code>.<p>
<a name="235280"></a>
In all cases, <code>a!=b</code> produces the same result as <code>!(a==b)</code>. The equality operators are commutative if the operand expressions have no side effects.<p>
<a name="5198"></a>
<h3>15.20.1    Numerical Equality Operators <code>==</code><code>&#32;</code>and <code>!=</code> </h3>
<a name="40803"></a>
If the operands of an equality operator are both of primitive numeric type, binary 
numeric promotion is performed on the operands <a href="5.doc.html#170983">(&#167;5.6.2)</a>. If the promoted type of 
the operands is <code>int</code> or <code>long</code>, then an integer equality test is performed; if the promoted
type is <code>float</code> or <code>double</code>, then a floating-point equality test is performed.
<p><a name="5203"></a>
Floating-point equality testing is performed in accordance with the rules of the IEEE 754 standard:<p>
<ul><a name="5204"></a>
<li>If either operand is NaN, then the result of <code>==</code> is <code>false</code> but the result of <code>!=</code> is <code>true</code>. Indeed, the test <code>x!=x</code> is true if and only if the value of <code>x</code> is NaN. (The methods <code>Float.isNaN</code> <a href="javalang.doc8.html#1484">(&#167;20.9.19)</a> and <code>Double.isNaN</code> <a href="javalang.doc9.html#13852">(&#167;20.10.17)</a> may also be used to test whether a value is NaN.)
<a name="54500"></a>
<li>Positive zero and negative zero are considered equal. Therefore, <code>-0.0==0.0</code> is <code>true</code>, for example.
<a name="54501"></a>
<li>Otherwise, two distinct floating-point values are considered unequal by the equality operators. In particular, there is one value representing positive infinity and one value representing negative infinity; each compares equal only to itself, and each compares unequal to all other values.
</ul><a name="5207"></a>
Subject to these considerations for floating-point numbers, the following rules then hold for integer operands or for floating-point operands other than NaN:<p>
<ul><a name="5208"></a>
<li>The value produced by the <code>==</code> operator is <code>true</code> if the value of the left-hand operand is equal to the value of the right-hand operand; otherwise, the result is <code>false</code>.
<a name="236629"></a>
<li>The value produced by the <code>!=</code> operator is <code>true</code> if the value of the left-hand operand is not equal to the value of the right-hand operand; otherwise, the result is <code>false</code>.
</ul><a name="54508"></a>
<h3>15.20.2    Boolean Equality Operators <code>==</code><code>&#32;</code>and <code>!=</code> </h3>
<a name="80389"></a>
If the operands of an equality operator are both of type <code>boolean</code>, then the operation
is boolean equality. The <code>boolean</code> equality operators are associative.
<p><a name="5214"></a>
The result of <code>==</code> is <code>true</code> if the operands are both <code>true</code> or both <code>false</code>; otherwise, the result is <code>false</code>.<p>
<a name="5215"></a>
The result of <code>!=</code> is <code>false</code> if the operands are both <code>true</code> or both <code>false</code>; otherwise, the result is <code>true</code>. Thus <code>!=</code> behaves the same as <code>^</code> <a href="15.doc.html#5242">(&#167;15.21.2)</a> when applied to boolean operands.<p>
<a name="236163"></a>
<h3>15.20.3    Reference Equality Operators <code>==</code><code>&#32;</code>and <code>!=</code></h3>
<a name="236164"></a>
If the operands of an equality operator are both of either reference type or the null 
type, then the operation is object equality.
<p><a name="80399"></a>
A compile-time error occurs if it is impossible to convert the type of either operand to the type of the other by a casting conversion <a href="5.doc.html#176921">(&#167;5.4)</a>. The run-time values of the two operands would necessarily be unequal.<p>
<a name="5225"></a>
At run time, the result of <code>==</code> is <code>true</code> if the operand values are both <code>null</code> or both refer to the same object or array; otherwise, the result is <code>false</code>.<p>
<a name="5226"></a>
The result of <code>!=</code> is <code>false</code> if the operand values are both <code>null</code> or both refer to the same object or array; otherwise, the result is <code>true</code>.<p>
<a name="80417"></a>
While <code>==</code> may be used to compare references of type <code>String</code>, such an equality test determines whether or not the two operands refer to the same <code>String</code> object. The result is <code>false</code> if the operands are distinct <code>String</code> objects, even if they contain the same sequence of characters. The contents of two strings <code>s</code> and <code>t</code> can be tested for equality by the method invocation <code>s.equals(t)</code> <a href="javalang.doc14.html#29026">(&#167;20.12.9)</a>. See also <a href="3.doc.html#101083">&#167;3.10.5</a> and <a href="javalang.doc11.html#14026">&#167;20.12.47</a>.<p>
<a name="5228"></a>
<h2>15.21    Bitwise and Logical Operators</h2>
<a name="5229"></a>
The <i>bitwise</i> <i>operators</i> and <i>logical operators</i> include the AND operator <code>&amp;</code>, exclusive
OR operator <code>^</code>, and inclusive OR operator <code>|</code>. These operators have different 
precedence, with <code>&amp;</code> having the highest precedence and <code>|</code> the lowest precedence. 
Each of these operators is syntactically left-associative (each groups left-to-right). 
Each operator is commutative if the operand expressions have no side effects. 
Each operator is associative.
<p><ul><pre>
<i>AndExpression:<br>
</i>	<i>EqualityExpression<br>
</i>	<i>AndExpression</i><code> &amp; </code><i>EqualityExpression
</i>
<i>ExclusiveOrExpression:<br>
</i>	<i>AndExpression<br>
</i>	<i>ExclusiveOrExpression</i><code> ^ </code><i>AndExpression
</i>
<i>InclusiveOrExpression:<br>
</i>	<i>ExclusiveOrExpression<br>
</i>	<i>InclusiveOrExpression</i><code> | </code><i>ExclusiveOrExpression
</i></pre></ul><a name="40906"></a>
The bitwise and logical operators may be used to compare two operands of numeric type or two operands of type <code>boolean</code>. All other cases result in a compile-time error.<p>
<a name="5233"></a>
<h3>15.21.1    Integer Bitwise Operators <code>&amp;</code>, <code>^</code>, and <code>|</code></h3>
<a name="5234"></a>
When both operands of an operator <code>&amp;</code>, <code>^</code>, or <code>|</code> are of primitive integral type, binary 
numeric promotion is first performed on the operands <a href="5.doc.html#170983">(&#167;5.6.2)</a>. The type of the bitwise
operator expression is the promoted type of the operands.
<p><a name="5238"></a>
For <code>&amp;</code>, the result value is the bitwise AND of the operand values.<p>
<a name="5239"></a>
For <code>^</code>, the result value is the bitwise exclusive OR of the operand values.<p>
<a name="5240"></a>
For <code>|</code>, the result value is the bitwise inclusive OR of the operand values.<p>
<a name="40979"></a>
For example, the result of the expression <code>0xff00</code> <code>&amp;</code> <code>0xf0f0</code> is <code>0xf000</code>. The result of <code>0xff00</code> <code>^</code> <code>0xf0f0</code> is <code>0x0ff0</code>.The result of <code>0xff00</code> <code>|</code> <code>0xf0f0</code> is <code>0xfff0</code>.<p>
<a name="5242"></a>
<h3>15.21.2    Boolean Logical Operators <code>&amp;</code>, <code>^</code>, and <code>|</code></h3>
<a name="5243"></a>
When both operands of a <code>&amp;</code>, <code>^</code>, or <code>|</code> operator are of type <code>boolean</code>, then the type of 
the bitwise operator expression is <code>boolean</code>.
<p><a name="5244"></a>
For <code>&amp;</code>, the result value is <code>true</code> if both operand values are <code>true</code>; otherwise, the result is <code>false</code>.<p>
<a name="5245"></a>
For <code>^</code>, the result value is <code>true</code> if the operand values are different; otherwise, the result is <code>false</code>.<p>
<a name="5246"></a>
For <code>|</code>, the result value is <code>false</code> if both operand values are <code>false</code>; otherwise, the result is <code>true</code>.<p>
<a name="5247"></a>
<h2>15.22    Conditional-And Operator <code>&amp;&amp;</code></h2>
<a name="5248"></a>
The <code>&amp;&amp;</code> operator is like <code>&amp;</code> <a href="15.doc.html#5242">(&#167;15.21.2)</a>, but evaluates its right-hand operand only if 
the value of its left-hand operand is <code>true</code>. It is syntactically left-associative (it 
groups left-to-right). It is fully associative with respect to both side effects and 
result value; that is, for any expressions <i>a</i>, <i>b</i>, and <i>c</i>, evaluation of the expression 
<code>((</code><i>a</i><code>)&amp;&amp;(</code><i>b</i><code>))&amp;&amp;(</code><i>c</i><code>)</code> produces the same result, with the same side effects occurring
in the same order, as evaluation of the expression <code>(</code><i>a</i><code>)&amp;&amp;((</code><i>b</i><code>)&amp;&amp;(</code><i>c</i><code>))</code>.
<p><ul><pre>
<i>ConditionalAndExpression:<br>
</i>	<i>InclusiveOrExpression<br>
</i>	<i>ConditionalAndExpression</i><code> &amp;&amp; </code><i>InclusiveOrExpression
</i></pre></ul><a name="5251"></a>
Each operand of <code>&amp;&amp;</code> must be of type <code>boolean</code>, or a compile-time error occurs. The type of a conditional-and expression is always <code>boolean</code>.<p>
<a name="41086"></a>
At run time, the left-hand operand expression is evaluated first; if its value is <code>false</code>, the value of the conditional-and expression is <code>false</code> and the right-hand operand expression is not evaluated. If the value of the left-hand operand is <code>true</code>, then the right-hand expression is evaluated and its value becomes the value of the conditional-and expression. Thus, <code>&amp;&amp;</code> computes the same result as <code>&amp;</code> on <code>boolean</code> operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.<p>
<a name="54532"></a>
<h2>15.23    Conditional-Or Operator <code>||</code></h2>
<a name="41053"></a>
The <code>||</code> operator is like <code>|</code> <a href="15.doc.html#5242">(&#167;15.21.2)</a>, but evaluates its right-hand operand only if 
the value of its left-hand operand is <code>false</code>. It is syntactically left-associative (it 
groups left-to-right). It is fully associative with respect to both side effects and 
result value; that is, for any expressions <i>a</i>, <i>b</i>, and <i>c</i>, evaluation of the expression 
<code>((</code><i>a</i><code>)||(</code><i>b</i><code>))||(</code><i>c</i><code>)</code> produces the same result, with the same side effects occurring
in the same order, as evaluation of the expression <code>(</code><i>a</i><code>)||((</code><i>b</i><code>)||(</code><i>c</i><code>))</code>.
<p><ul><pre>
<i>ConditionalOrExpression:<br>
</i>	<i>ConditionalAndExpression<br>
</i>	<i>ConditionalOrExpression</i><code> || </code><i>ConditionalAndExpression
</i></pre></ul><a name="41088"></a>
Each operand of <code>||</code> must be of type <code>boolean,</code> or a compile-time error occurs. The type of a conditional-or expression is always <code>boolean</code>.<p>
<a name="41089"></a>
At run time, the left-hand operand expression is evaluated first; if its value is <code>true</code>, the value of the conditional-or expression is <code>true</code> and the right-hand operand expression is not evaluated. If the value of the left-hand operand is <code>false</code>, then the right-hand expression is evaluated and its value becomes the value of the conditional-or expression. Thus, <code>||</code> computes the same result as <code>|</code> on <code>boolean</code> operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.<p>
<a name="5257"></a>
<h2>15.24    Conditional Operator <code>?&#32;:</code></h2>
<a name="5258"></a>
The conditional operator <code>?&#32;:</code> uses the boolean value of one expression to decide 
which of two other expressions should be evaluated.
<p><a name="41113"></a>
The conditional operator is syntactically right-associative (it groups right-to-left), so that <code>a?b:c?d:e?f:g</code> means the same as <code>a?b:(c?d:(e?f:g))</code>.<p>
<ul><pre>
<i>ConditionalExpression:<br>
</i>	<i>ConditionalOrExpression<br>
</i>	<i>ConditionalOrExpression</i><code> ? </code><i>Expression</i><code> : </code><i>ConditionalExpression
</i></pre></ul><a name="236253"></a>
The conditional operator has three operand expressions; <code>?</code> appears between the first and second expressions, and <code>:</code> appears between the second and third expressions.<p>
<a name="40128"></a>
The first expression must be of type <code>boolean</code>, or a compile-time error occurs.<p>
<a name="40129"></a>
The conditional operator may be used to choose between second and third operands of numeric type, or second and third operands of type <code>boolean</code>, or second and third operands that are each of either reference type or the null type. All other cases result in a compile-time error.<p>
<a name="41144"></a>
Note that it is not permitted for either the second or the third operand expression to be an invocation of a <code>void</code> method. In fact, it is not permitted for a conditional expression to appear in any context where an invocation of a <code>void</code> method could appear <a href="14.doc.html#5984">(&#167;14.7)</a>.<p>
<a name="236267"></a>
The type of a conditional expression is determined as follows:<p>
<ul><a name="41198"></a>
<li>If the second and third operands have the same type (which may be the null type), then that is the type of the conditional expression.
<a name="236254"></a>
<li>Otherwise, if the second and third operands have numeric type, then there are several cases:
<ul>
<a name="5262"></a>
<li>If one of the operands is of type <code>byte</code> and the other is of type <code>short</code>, then the type of the conditional expression is <code>short</code>.
<a name="5264"></a>
<li>If one of the operands is of type <i>T</i><em></em> where <i>T</i><em></em> is <code>byte</code>, <code>short</code>, or <code>char</code>, and the other operand is a constant expression of type <code>int</code> whose value is representable in type <i>T</i>, then the type of the conditional expression is <i>T</i>.
<a name="5268"></a>
<li>Otherwise, binary numeric promotion <a href="5.doc.html#170983">(&#167;5.6.2)</a> is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands.
</ul>
<a name="5271"></a>
<li>If one of the second and third operands is of the null type and the type of the other is a reference type, then the type of the conditional expression is that reference type.
<a name="76547"></a>
<li>If the second and third operands are of different reference types, then it must be possible to convert one of the types to the other type (call this latter type <i>T</i>) by assignment conversion <a href="5.doc.html#170768">(&#167;5.2)</a>; the type of the conditional expression is <i>T</i>. It is a compile-time error if neither type is assignment compatible with the other type.
</ul><a name="40134"></a>
At run time, the first operand expression of the conditional expression is evaluated first; its <code>boolean</code> value is then used to choose either the second or the third operand expression:<p>
<ul><a name="5277"></a>
<li>If the value of the first operand is <code>true</code>, then the second operand expression is chosen.
<a name="5278"></a>
<li>If the value of the first operand is <code>false</code>, then the third operand expression is chosen.
</ul><a name="5279"></a>
The chosen operand expression is then evaluated and the resulting value is converted
to the type of the conditional expression as determined by the rules stated 
above. The operand expression not chosen is not evaluated for that particular evaluation
of the conditional expression.
<p><a name="5281"></a>
<h2>15.25    Assignment Operators</h2>
<a name="5282"></a>
There are 12 <i>assignment operators</i>; all are syntactically right-associative (they 
group right-to-left). Thus, <code>a=b=c</code> means <code>a=(b=c)</code>, which assigns the value of <code>c</code> to 
<code>b</code> and then assigns the value of <code>b</code> to <code>a</code>.
<p><ul><pre>
<i>AssignmentExpression:<br>
</i>	<i>ConditionalExpression<br>
</i>	<i>Assignment
</i>
<i>Assignment:<br>
</i>	<i>LeftHandSide</i><code> </code><i>AssignmentOperator</i><code> </code><i>AssignmentExpression
</i>
<i>LeftHandSide:<br>
</i>	<i>ExpressionName<br>
</i>	<i>FieldAccess<br>
</i>	<i>ArrayAccess
</i>
<i>AssignmentOperator:</i> <i>one</i> <i>of<br>
</i>	<code>=&#32;*=&#32;/=&#32;%=&#32;+=&#32;-=&#32;&lt;&lt;=&#32;&gt;&gt;=&#32;&gt;&gt;&gt;=&#32;&amp;=&#32;^=&#32;|=
</code></pre></ul><a name="236643"></a>
The result of the first operand of an assignment operator must be a variable, or a compile-time error occurs. This operand may be a named variable, such as a local variable or a field of the current object or class, or it may be a computed variable, as can result from a field access <a href="15.doc.html#41267">(&#167;15.10)</a> or an array access <a href="15.doc.html#239587">(&#167;15.12)</a>. The type of the assignment expression is the type of the variable.<p>
<a name="41276"></a>
At run time, the result of the assignment expression is the value of the variable after the assignment has occurred. The result of an assignment expression is not itself a variable.<p>
<a name="41365"></a>
A variable that is declared <code>final</code> cannot be assigned to, because when an access of a <code>final</code> variable is used as an expression, the result is a value, not a variable, and so it cannot be used as the operand of an assignment operator.<p>
<a name="5295"></a>
<h3>15.25.1    Simple Assignment Operator <code>=</code></h3>
<a name="22840"></a>
A compile-time error occurs if the type of the right-hand operand cannot be converted
to the type of the variable by assignment conversion <a href="5.doc.html#170768">(&#167;5.2)</a>.
<p><a name="41396"></a>
At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then three steps are required:<p>
<ul><a name="238369"></a>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
<a name="238371"></a>
<li>Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238384"></a>
<li>Otherwise, the value of the right-hand operand is converted to the type of the left-hand variable and the result of the conversion is stored into the variable.
</ul><a name="238191"></a>
If the left-hand operand expression is an array access expression <a href="15.doc.html#239587">(&#167;15.12)</a>, then 
many steps are required:
<p><ul><a name="238214"></a>
<li>First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
<a name="238234"></a>
<li>Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
<a name="238236"></a>
<li>Otherwise, the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238216"></a>
<li>Otherwise, if the value of the array reference subexpression is <code>null</code>, then no assignment occurs and a <code>NullPointerException</code> &#32;is thrown.
<a name="238217"></a>
<li>Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than &#32;or equal to the length of the array, then no assignment occurs and an <code>IndexOutOfBoundsException</code> &#32;is thrown.
<a name="238218"></a>
<li>Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. This component is a variable; call its type <i>SC</i><i></i>. Also, let <i>TC</i> be the type of the left-hand operand of the assignment operator as determined at compile time.
<ul>
<a name="238255"></a>
<li>If <i>TC</i> is a primitive type, then <i>SC</i> is necessarily the same as <i>TC</i>. The value of the right-hand operand is converted to a value of type <i>TC</i> and stored into the selected array component.
<a name="238261"></a>
<li>If <i>T</i> is a reference type, then <i>SC</i> may not be the same as <i>T</i>, but rather a type that extends or implements <i>TC</i>. Let <i>RC</i> be the class of the object referred to by the value of the right-hand operand at run time.
<a name="238306"></a>
<li>The compiler may be able to prove at compile time that the array component will be of type <i>TC</i> exactly (for example, <i>TC</i> might be <code>final</code>). But if the compiler cannot prove at compile time that the array component will be of type <i>TC</i> exactly, then a check must be performed at run time to ensure that the class <i>RC</i> is assignment compatible <a href="5.doc.html#170768">(&#167;5.2)</a> with the actual type <i>SC</i> of the array component. This check is similar to a narrowing cast (<a href="5.doc.html#176921">&#167;5.4</a>, <a href="15.doc.html#238146">&#167;15.15</a>), except that if the check fails, an <code>ArrayStoreException</code> is thrown rather than a <code>ClassCastException</code>. Therefore:
<ul>
<a name="238321"></a>
<li>If class <i>RC</i> is not assignable to type <i>SC</i>, then no assignment occurs and an <code>ArrayStoreException</code> is thrown.
<a name="238334"></a>
<li>Otherwise, the reference value of the right-hand operand is stored into the selected array component.
</ul>
</ul>
</ul><a name="238526"></a>
The rules for assignment to an array component are illustrated by the following 
example program:
<p><pre><br><a name="238650"></a>class ArrayReferenceThrow extends RuntimeException { }
<br><br><a name="238651"></a>class IndexThrow extends RuntimeException { }
<br><br><a name="238652"></a>class RightHandSideThrow extends RuntimeException { }
<br></pre><pre><a name="238654"></a>
class IllustrateSimpleArrayAssignment {
<br><a name="238656"></a>	static Object[] objects = { new Object(), new Object() };
<br><br><a name="238657"></a>	static Thread[] threads = { new Thread(), new Thread() };
<br><a name="238658"></a>
	static Object[] arrayThrow() {
<a name="238738"></a>		throw new ArrayReferenceThrow();
<a name="238739"></a>	}
<br><br><a name="238659"></a>	static int indexThrow() { throw new IndexThrow(); }
<br><a name="238660"></a>
	static Thread rightThrow() {
<a name="238743"></a>		throw new RightHandSideThrow();
<a name="238744"></a>	}
<br><a name="238661"></a>
	static String name(Object q) {
<a name="238662"></a>		String sq = q.getClass().getName();
<a name="238663"></a>		int k = sq.lastIndexOf('.');
<a name="238664"></a>		return (k &lt; 0) ? sq : sq.substring(k+1);
<a name="238665"></a>	}
<br><a name="238666"></a>
	static void testFour(Object[] x, int j, Object y) {
<a name="238667"></a>		String sx = x == null ? "null" : name(x[0]) + "s";
<a name="238668"></a>		String sy = name(y);
<a name="238669"></a>		System.out.println();
<a name="238670"></a>		try {
<a name="238671"></a>			System.out.print(sx + "[throw]=throw =&gt; ");
<a name="238672"></a>			x[indexThrow()] = rightThrow();
<a name="238673"></a>			System.out.println("Okay!");
<a name="238674"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238675"></a>		try {
<a name="238676"></a>			System.out.print(sx + "[throw]=" + sy + " =&gt; ");
<a name="238677"></a>			x[indexThrow()] = y;
<a name="238678"></a>			System.out.println("Okay!");
<a name="238679"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238680"></a>		try {
<a name="238681"></a>			System.out.print(sx + "[" + j + "]=throw =&gt; ");
<a name="238682"></a>			x[j] = rightThrow();
<a name="238683"></a>			System.out.println("Okay!");
<a name="238684"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238685"></a>		try {
<a name="238686"></a>			System.out.print(sx + "[" + j + "]=" + sy + " =&gt; ");
<a name="238687"></a>			x[j] = y;
<a name="238688"></a>			System.out.println("Okay!");
<a name="238689"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238690"></a>	}
<br><a name="238691"></a>
	public static void main(String[] args) {
<a name="238692"></a>		try {
<a name="238693"></a>			System.out.print("throw[throw]=throw =&gt; ");
<a name="238694"></a>			arrayThrow()[indexThrow()] = rightThrow();
<a name="238695"></a>			System.out.println("Okay!");
<a name="238696"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238697"></a>		try {
<a name="238698"></a>			System.out.print("throw[throw]=Thread =&gt; ");
<a name="238699"></a>			arrayThrow()[indexThrow()] = new Thread();
<a name="238700"></a>			System.out.println("Okay!");
<a name="238701"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238702"></a>		try {
<a name="238703"></a>			System.out.print("throw[1]=throw =&gt; ");
<a name="238704"></a>			arrayThrow()[1] = rightThrow();
<a name="238705"></a>			System.out.println("Okay!");
<a name="238706"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238707"></a>		try {
<a name="238708"></a>			System.out.print("throw[1]=Thread =&gt; ");
<a name="238709"></a>			arrayThrow()[1] = new Thread();
<a name="238710"></a>			System.out.println("Okay!");
<a name="238711"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238712"></a>
		testFour(null, 1, new StringBuffer());
<a name="238713"></a>		testFour(null, 1, new StringBuffer());
<a name="238714"></a>		testFour(null, 9, new Thread());
<a name="238715"></a>		testFour(null, 9, new Thread());
<a name="238716"></a>		testFour(objects, 1, new StringBuffer());
<a name="238717"></a>		testFour(objects, 1, new Thread());
<a name="238718"></a>		testFour(objects, 9, new StringBuffer());
<a name="238719"></a>		testFour(objects, 9, new Thread());
<a name="238720"></a>		testFour(threads, 1, new StringBuffer());
<a name="238721"></a>		testFour(threads, 1, new Thread());
<a name="238722"></a>		testFour(threads, 9, new StringBuffer());
<a name="238723"></a>		testFour(threads, 9, new Thread());
<a name="238724"></a>	}
<br><a name="238725"></a>}
</pre><a name="238532"></a>
This program prints:
<p><pre><a name="238746"></a>
throw[throw]=throw =&gt; ArrayReferenceThrow
<a name="238747"></a>throw[throw]=Thread =&gt; ArrayReferenceThrow
<a name="238748"></a>throw[1]=throw =&gt; ArrayReferenceThrow
<a name="238749"></a>throw[1]=Thread =&gt; ArrayReferenceThrow
<br><a name="238751"></a>
null[throw]=throw =&gt; IndexThrow
<a name="238752"></a>null[throw]=StringBuffer =&gt; IndexThrow
<a name="238753"></a>null[1]=throw =&gt; RightHandSideThrow
<a name="238754"></a>null[1]=StringBuffer =&gt; NullPointerException
<br><a name="238756"></a>
null[throw]=throw =&gt; IndexThrow
<a name="238757"></a>null[throw]=StringBuffer =&gt; IndexThrow
<a name="238758"></a>null[1]=throw =&gt; RightHandSideThrow
<a name="238759"></a>null[1]=StringBuffer =&gt; NullPointerException
<br><a name="238761"></a>
null[throw]=throw =&gt; IndexThrow
<a name="238762"></a>null[throw]=Thread =&gt; IndexThrow
<a name="238763"></a>null[9]=throw =&gt; RightHandSideThrow
<a name="238764"></a>null[9]=Thread =&gt; NullPointerException
<br><a name="238766"></a>
null[throw]=throw =&gt; IndexThrow
<a name="238767"></a>null[throw]=Thread =&gt; IndexThrow
<a name="238768"></a>null[9]=throw =&gt; RightHandSideThrow
<a name="238769"></a>null[9]=Thread =&gt; NullPointerException
<br><a name="238771"></a>
Objects[throw]=throw =&gt; IndexThrow
<a name="238772"></a>Objects[throw]=StringBuffer =&gt; IndexThrow
<a name="238773"></a>Objects[1]=throw =&gt; RightHandSideThrow
<a name="238774"></a>Objects[1]=StringBuffer =&gt; Okay!
<br><a name="238776"></a>
Objects[throw]=throw =&gt; IndexThrow
<a name="238777"></a>Objects[throw]=Thread =&gt; IndexThrow
<a name="238778"></a>Objects[1]=throw =&gt; RightHandSideThrow
<a name="238779"></a>Objects[1]=Thread =&gt; Okay!
<br><a name="238781"></a>
Objects[throw]=throw =&gt; IndexThrow
<a name="238782"></a>Objects[throw]=StringBuffer =&gt; IndexThrow
<a name="238783"></a>Objects[9]=throw =&gt; RightHandSideThrow
<a name="238784"></a>Objects[9]=StringBuffer =&gt; IndexOutOfBoundsException
<br><a name="238786"></a>
Objects[throw]=throw =&gt; IndexThrow
<a name="238787"></a>Objects[throw]=Thread =&gt; IndexThrow
<a name="238788"></a>Objects[9]=throw =&gt; RightHandSideThrow
<a name="238789"></a>Objects[9]=Thread =&gt; IndexOutOfBoundsException
<br><a name="238791"></a>
Threads[throw]=throw =&gt; IndexThrow
<a name="238792"></a>Threads[throw]=StringBuffer =&gt; IndexThrow
<a name="238793"></a>Threads[1]=throw =&gt; RightHandSideThrow
<a name="238794"></a>Threads[1]=StringBuffer =&gt; ArrayStoreException
<br><a name="238796"></a>
Threads[throw]=throw =&gt; IndexThrow
<a name="238797"></a>Threads[throw]=Thread =&gt; IndexThrow
<a name="238798"></a>Threads[1]=throw =&gt; RightHandSideThrow
<a name="238799"></a>Threads[1]=Thread =&gt; Okay!
<br><a name="238801"></a>
Threads[throw]=throw =&gt; IndexThrow
<a name="238802"></a>Threads[throw]=StringBuffer =&gt; IndexThrow
<a name="238803"></a>Threads[9]=throw =&gt; RightHandSideThrow
<a name="238804"></a>Threads[9]=StringBuffer =&gt; IndexOutOfBoundsException
<br><a name="238806"></a>
Threads[throw]=throw =&gt; IndexThrow
<a name="238807"></a>Threads[throw]=Thread =&gt; IndexThrow
<a name="238808"></a>Threads[9]=throw =&gt; RightHandSideThrow
<a name="238809"></a>Threads[9]=Thread =&gt; IndexOutOfBoundsException
</pre><a name="238840"></a>
The most interesting case of the lot is the one thirteenth from the end:
<p><pre><a name="238843"></a>Threads[1]=StringBuffer =&gt; ArrayStoreException
</pre><a name="238841"></a>
which indicates that the attempt to store a reference to a <code>StringBuffer</code> into an 
array whose components are of type <code>Thread</code> throws an <code>ArrayStoreException</code>. 
The code is type-correct at compile time: the assignment has a left-hand side of 
type <code>Object[]</code> and a right-hand side of type <code>Object</code>. At run time, the first actual 
argument to method <code>testFour</code> is a reference to an instance of "array of <code>Thread</code>" 
and the third actual argument is a reference to an instance of class <code>StringBuffer</code>.
<p><a name="5304"></a>
<h3>15.25.2    Compound Assignment Operators</h3>
<a name="5305"></a>
All compound assignment operators require both operands to be of primitive type, 
except for <code>+=</code>, which allows the right-hand operand to be of any type if the left-
hand operand is of type <code>String</code>.
<p><a name="5306"></a>
A compound assignment expression of the form <i>E1</i> <i>op</i>= <i>E2</i> is equivalent to <i>E1</i> &#32;<code>=</code> &#32;<code>(</code><i>T</i><code>)((</code><i>E1</i><code>)</code> <i>op</i> <code>(</code><i>E2</i><code>))</code>, where <i>T</i> is the type of <i>E1</i>, except that <i>E1</i> is evaluated only once. Note that the implied cast to type <i>T</i> may be either an identity conversion <a href="5.doc.html#25209">(&#167;5.1.1)</a> or a narrowing primitive conversion <a href="5.doc.html#175672">(&#167;5.1.3)</a>. For example, the following code is correct:<p>
<pre><a name="236396"></a>
short x = 3;
<a name="236397"></a>x += 4.6;
</pre><a name="236398"></a>
and results in <code>x</code> having the value <code>7</code> because it is equivalent to:
<p><pre><a name="236400"></a>
short x = 3;
<a name="236401"></a>x = (short)(x + 4.6);
</pre><a name="238395"></a>
At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:<p>
<ul><a name="238396"></a>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.
<a name="238397"></a>
<li>Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238433"></a>
<li>Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see <a href="15.doc.html#5047">&#167;15.16.2</a>), then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238398"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the left-hand variable and the result of the conversion is stored into the variable.
</ul><a name="238402"></a>
If the left-hand operand expression is an array access expression <a href="15.doc.html#239587">(&#167;15.12)</a>, then 
many steps are required:
<p><ul><a name="238403"></a>
<li>First, the array reference subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the index subexpression (of the left-hand operand array access expression) and the right-hand operand are not evaluated and no assignment occurs.
<a name="238404"></a>
<li>Otherwise, the index subexpression of the left-hand operand array access expression is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and the right-hand operand is not evaluated and no assignment occurs.
<a name="238449"></a>
<li>Otherwise, if the value of the array reference subexpression is <code>null</code>, then no assignment occurs and a <code>NullPointerException</code> &#32;is thrown.
<a name="238450"></a>
<li>Otherwise, the value of the array reference subexpression indeed refers to an array. If the value of the index subexpression is less than zero, or greater than &#32;or equal to the length of the array, then no assignment occurs and an <code>IndexOutOfBoundsException</code> &#32;is thrown.
<a name="238405"></a>
<li>Otherwise, the value of the index subexpression is used to select a component of the array referred to by the value of the array reference subexpression. The value of this component is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs. (For a simple assignment operator, the evaluation of the right-hand operand occurs before the checks of the array reference subexpression and the index subexpression, but for a compound assignment operator, the evaluation of the right-hand operand occurs after these checks.)
<a name="238408"></a>
<li>Otherwise, consider the array component selected in the previous step, whose value was saved. This component is a variable; call its type <i>S</i><i></i>. Also, let <i>T</i> be the type of the left-hand operand of the assignment operator as determined at compile time.
<ul>
<a name="238409"></a>
<li>If <i>T</i> is a primitive type, then <i>S</i> is necessarily the same as <i>T</i>.
<ul>
<a name="238472"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see <a href="15.doc.html#5047">&#167;15.16.2</a>), then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238476"></a>
<li>Otherwise, the result of the binary operation is converted to the type of the array component and the result of the conversion is stored into the array component.
</ul>
<a name="238410"></a>
<li>If <i>T</i> is a reference type, then it must be <code>String</code>. Because class <code>String</code> is a <code>final</code> class, <i>S</i> must also be <code>String</code>. Therefore the run-time check that is sometimes required for the simple assignment operator is never required for a compound assignment operator.
<ul>
<a name="238488"></a>
<li>The saved value of the array component and the value of the right-hand operand are used to perform the binary operation (string concatenation) indicated by the compound assignment operator (which is necessarily <code>+=</code>). If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.
<a name="238492"></a>
<li>Otherwise, the <code>String</code> result of the binary operation is stored into the array component.
</ul>
</ul>
</ul><a name="238860"></a>
The rules for compound assignment to an array component are illustrated by the 
following example program:
<p><pre><br><a name="238863"></a>class ArrayReferenceThrow extends RuntimeException { }
<br><br><a name="238864"></a>class IndexThrow extends RuntimeException { }
<br><br><a name="238865"></a>class RightHandSideThrow extends RuntimeException { }
<br><a name="238867"></a>class IllustrateCompoundArrayAssignment {
<br><a name="238868"></a>	static String[] strings = { "Simon", "Garfunkel" };
<br><br><a name="238869"></a>	static double[] doubles = { Math.E, Math.PI };
<br></pre><pre><a name="238870"></a>
	static String[] stringsThrow() {
<a name="238983"></a>		throw new ArrayReferenceThrow();
<a name="238984"></a>	}
<br><a name="238871"></a>
	static double[] doublesThrow() {
<a name="238985"></a>		throw new ArrayReferenceThrow();
<a name="238986"></a>	}
<br><br><a name="238872"></a>	static int indexThrow() { throw new IndexThrow(); }
<br><a name="238873"></a>
	static String stringThrow() {
<a name="238987"></a>		throw new RightHandSideThrow();
<a name="238988"></a>	}
<br><a name="238874"></a>
	static double doubleThrow() {
<a name="238989"></a>		throw new RightHandSideThrow();
<a name="238990"></a>	}
<br><a name="238875"></a>
	static String name(Object q) {
<a name="238876"></a>		String sq = q.getClass().getName();
<a name="238877"></a>		int k = sq.lastIndexOf('.');
<a name="238878"></a>		return (k &lt; 0) ? sq : sq.substring(k+1);
<a name="238879"></a>	}
<br><a name="238880"></a>
	static void testEight(String[] x, double[] z, int j) {
<a name="238881"></a>		String sx = (x == null) ? "null" : "Strings";
<a name="238882"></a>		String sz = (z == null) ? "null" : "doubles";
<a name="238883"></a>		System.out.println();
<a name="238884"></a>		try {
<a name="238885"></a>			System.out.print(sx + "[throw]+=throw =&gt; ");
<a name="238886"></a>			x[indexThrow()] += stringThrow();
<a name="238887"></a>			System.out.println("Okay!");
<a name="238888"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238889"></a>		try {
<a name="238890"></a>			System.out.print(sz + "[throw]+=throw =&gt; ");
<a name="238891"></a>			z[indexThrow()] += doubleThrow();
<a name="238892"></a>			System.out.println("Okay!");
<a name="238893"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238894"></a>
		try {
<a name="238895"></a>			System.out.print(sx + "[throw]+=\"heh\" =&gt; ");
<a name="238896"></a>			x[indexThrow()] += "heh";
<a name="238897"></a>			System.out.println("Okay!");
<a name="238898"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238899"></a>		try {
<a name="238900"></a>			System.out.print(sz + "[throw]+=12345 =&gt; ");
<a name="238901"></a>			z[indexThrow()] += 12345;
<a name="238902"></a>			System.out.println("Okay!");
<a name="238903"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238904"></a>		try {
<a name="238905"></a>			System.out.print(sx + "[" + j + "]+=throw =&gt; ");
<a name="238906"></a>			x[j] += stringThrow();
<a name="238907"></a>			System.out.println("Okay!");
<a name="238908"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238909"></a>		try {
<a name="238910"></a>			System.out.print(sz + "[" + j + "]+=throw =&gt; ");
<a name="238911"></a>			z[j] += doubleThrow();
<a name="238912"></a>			System.out.println("Okay!");
<a name="238913"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238914"></a>		try {
<a name="238915"></a>			System.out.print(sx + "[" + j + "]+=\"heh\" =&gt; ");
<a name="238916"></a>			x[j] += "heh";
<a name="238917"></a>			System.out.println("Okay!");
<a name="238918"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238919"></a>		try {
<a name="238920"></a>			System.out.print(sz + "[" + j + "]+=12345 =&gt; ");
<a name="238921"></a>			z[j] += 12345;
<a name="238922"></a>			System.out.println("Okay!");
<a name="238923"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238924"></a>	}
<br><a name="238925"></a>
	public static void main(String[] args) {
<a name="238926"></a>		try {
<a name="238927"></a>			System.out.print("throw[throw]+=throw =&gt; ");
<a name="238928"></a>			stringsThrow()[indexThrow()] += stringThrow();
<a name="238929"></a>			System.out.println("Okay!");
<a name="238930"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238931"></a>		try {
<a name="238932"></a>			System.out.print("throw[throw]+=throw =&gt; ");
<a name="238933"></a>			doublesThrow()[indexThrow()] += doubleThrow();
<a name="238934"></a>			System.out.println("Okay!");
<a name="238935"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238936"></a>		try {
<a name="238937"></a>			System.out.print("throw[throw]+=\"heh\" =&gt; ");
<a name="238938"></a>			stringsThrow()[indexThrow()] += "heh";
<a name="238939"></a>			System.out.println("Okay!");
<a name="238940"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238941"></a>
		try {
<a name="238942"></a>			System.out.print("throw[throw]+=12345 =&gt; ");
<a name="238943"></a>			doublesThrow()[indexThrow()] += 12345;
<a name="238944"></a>			System.out.println("Okay!");
<a name="238945"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238946"></a>		try {
<a name="238947"></a>			System.out.print("throw[1]+=throw =&gt; ");
<a name="238948"></a>			stringsThrow()[1] += stringThrow();
<a name="238949"></a>			System.out.println("Okay!");
<a name="238950"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238951"></a>		try {
<a name="238952"></a>			System.out.print("throw[1]+=throw =&gt; ");
<a name="238953"></a>			doublesThrow()[1] += doubleThrow();
<a name="238954"></a>			System.out.println("Okay!");
<a name="238955"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238956"></a>		try {
<a name="238957"></a>			System.out.print("throw[1]+=\"heh\" =&gt; ");
<a name="238958"></a>			stringsThrow()[1] += "heh";
<a name="238959"></a>			System.out.println("Okay!");
<a name="238960"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238961"></a>		try {
<a name="238962"></a>			System.out.print("throw[1]+=12345 =&gt; ");
<a name="238963"></a>			doublesThrow()[1] += 12345;
<a name="238964"></a>			System.out.println("Okay!");
<a name="238965"></a>		} catch (Throwable e) { System.out.println(name(e)); }
<a name="238966"></a>
		testEight(null, null, 1);
<a name="238967"></a>		testEight(null, null, 9);
<a name="238968"></a>		testEight(strings, doubles, 1);
<a name="238969"></a>		testEight(strings, doubles, 9);
<a name="238970"></a>	}
<br><a name="238971"></a>}
</pre><a name="238992"></a>
This program prints:
<p><pre><a name="238994"></a>
throw[throw]+=throw =&gt; ArrayReferenceThrow
<a name="238995"></a>throw[throw]+=throw =&gt; ArrayReferenceThrow
<a name="238996"></a>throw[throw]+="heh" =&gt; ArrayReferenceThrow
<a name="238997"></a>throw[throw]+=12345 =&gt; ArrayReferenceThrow
<a name="238998"></a>throw[1]+=throw =&gt; ArrayReferenceThrow
<a name="238999"></a>throw[1]+=throw =&gt; ArrayReferenceThrow
<a name="239000"></a>throw[1]+="heh" =&gt; ArrayReferenceThrow
<a name="239001"></a>throw[1]+=12345 =&gt; ArrayReferenceThrow
<br><a name="239003"></a>
null[throw]+=throw =&gt; IndexThrow
<a name="239004"></a>null[throw]+=throw =&gt; IndexThrow
<a name="239005"></a>null[throw]+="heh" =&gt; IndexThrow
<a name="239006"></a>null[throw]+=12345 =&gt; IndexThrow
<a name="239007"></a>null[1]+=throw =&gt; NullPointerException
<a name="239008"></a>null[1]+=throw =&gt; NullPointerException
<a name="239009"></a>null[1]+="heh" =&gt; NullPointerException
<a name="239010"></a>null[1]+=12345 =&gt; NullPointerException
<br><a name="239012"></a>
null[throw]+=throw =&gt; IndexThrow
<a name="239013"></a>null[throw]+=throw =&gt; IndexThrow
<a name="239014"></a>null[throw]+="heh" =&gt; IndexThrow
<a name="239015"></a>null[throw]+=12345 =&gt; IndexThrow
<a name="239016"></a>null[9]+=throw =&gt; NullPointerException
<a name="239017"></a>null[9]+=throw =&gt; NullPointerException
<a name="239018"></a>null[9]+="heh" =&gt; NullPointerException
<a name="239019"></a>null[9]+=12345 =&gt; NullPointerException
<br><a name="239021"></a>
Strings[throw]+=throw =&gt; IndexThrow
<a name="239022"></a>doubles[throw]+=throw =&gt; IndexThrow
<a name="239023"></a>Strings[throw]+="heh" =&gt; IndexThrow
<a name="239024"></a>doubles[throw]+=12345 =&gt; IndexThrow
<a name="239025"></a>Strings[1]+=throw =&gt; RightHandSideThrow
<a name="239026"></a>doubles[1]+=throw =&gt; RightHandSideThrow
<a name="239027"></a>Strings[1]+="heh" =&gt; Okay!
<a name="239028"></a>doubles[1]+=12345 =&gt; Okay!
<br><a name="239030"></a>
Strings[throw]+=throw =&gt; IndexThrow
<a name="239031"></a>doubles[throw]+=throw =&gt; IndexThrow
<a name="239032"></a>Strings[throw]+="heh" =&gt; IndexThrow
<a name="239033"></a>doubles[throw]+=12345 =&gt; IndexThrow
<a name="239034"></a>Strings[9]+=throw =&gt; IndexOutOfBoundsException
<a name="239035"></a>doubles[9]+=throw =&gt; IndexOutOfBoundsException
<a name="239036"></a>Strings[9]+="heh" =&gt; IndexOutOfBoundsException
<a name="239037"></a>doubles[9]+=12345 =&gt; IndexOutOfBoundsException
</pre><a name="239051"></a>
The most interesting cases of the lot are tenth and eleventh from the end:
<p><pre><a name="239058"></a>
Strings[1]+=throw =&gt; RightHandSideThrow
<a name="239059"></a>doubles[1]+=throw =&gt; RightHandSideThrow
</pre><a name="238861"></a>
They are the cases where a right-hand side that throws an exception actually gets 
to throw the exception; moreover, they are the only such cases in the lot. This 
demonstrates that the evaluation of the right-hand operand indeed occurs after the 
checks for a null array reference value and an out-of-bounds index value.
<p><a name="240007"></a>
The following program illustrates the fact that the value of the left-hand side of a compound assignment is saved before the right-hand side is evaluated:<p>
<pre><a name="240010"></a>
class Test {
<a name="240011"></a>	public static void main(String[] args) {
<a name="240012"></a>		int k = 1;
<a name="240013"></a>		int[] a = { 1 };
<a name="240032"></a>		k += (k = 4) * (k + 2);
<a name="240016"></a>		a[0] += (a[0] = 4) * (a[0] + 2);
<a name="240041"></a>		System.out.println("k==" + k + " and a[0]==" + a[0]);
<a name="240017"></a>	}
<a name="240018"></a>}
</pre><a name="240021"></a>
This program prints:
<p><pre><a name="240024"></a>k==25 and a[0]==25
</pre><a name="240027"></a>
The value <code>1</code> of <code>k</code> is saved by the compound assignment operator <code>+=</code> before its 
right-hand operand <code>(k</code> <code>=</code> <code>4)</code> <code>*</code> <code>(k</code> <code>+</code> <code>2)</code> is evaluated. Evaluation of this right-hand 
operand then assigns <code>4</code> to <code>k</code>, calculates the value <code>6</code> for <code>k</code> <code>+</code> <code>2</code>, and then multiplies 
<code>4</code> &#32;by &#32;<code>6</code> to get <code>24</code>. This is added to the saved value <code>1</code> to get <code>25</code>, which is then stored 
into <code>k</code> by the <code>+=</code> operator. An identical analysis applies to the case that uses <code>a[0]</code>. 
In short, the statements
<p><pre><a name="240068"></a>
k += (k = 4) * (k + 2);
<a name="240069"></a>a[0] += (a[0] = 4) * (a[0] + 2);
</pre><a name="240066"></a>
behave in exactly the same manner as the statements:
<p><pre><a name="240072"></a>
k = k + (k = 4) * (k + 2);
<a name="240073"></a>a[0] = a[0] + (a[0] = 4) * (a[0] + 2);
</pre><a name="5308"></a>
<h2>15.26    Expression</h2>
<a name="5309"></a>
An <i>Expression</i> is any assignment expression:
<p><ul><pre>
<i>Expression:<br>
</i>	<i>AssignmentExpression
</i></pre></ul><a name="5311"></a>
Unlike C and C++, the Java language has no comma operator.
<p><a name="5313"></a>
<h2>15.27    Constant Expression</h2>
<ul><pre>
<i>ConstantExpression:<br>
</i>	<i>Expression
</i></pre></ul><a name="5314"></a>
A compile-time <i>constant expression</i> is an expression denoting a value of primitive type or a <code>String</code> that is composed using only the following:<p>
<ul><a name="236320"></a>
<li>Literals of primitive type and literals of type <code>String</code>
<a name="236323"></a>
<li>Casts to primitive types and casts to type <code>String</code>
<a name="236324"></a>
<li>The unary operators <code>+</code>, <code>-</code>, <code>~</code>, and <code>! </code>(but not <code>++</code> or <code>--</code>)
<a name="239222"></a>
<li>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code>
<a name="239261"></a>
<li>The additive operators <code>+</code> and <code>-</code>
<a name="239263"></a>
<li>The shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>
<a name="239226"></a>
<li>The relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;= </code>(but not <code>instanceof</code>)
<a name="239228"></a>
<li>The equality operators <code>==</code> and <code>!=</code>
<a name="239255"></a>
<li>The bitwise and logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code>
<a name="239257"></a>
<li>The conditional-and operator <code>&amp;&amp;</code> and the conditional-or operator <code>||</code>
<a name="236327"></a>
<li>The ternary conditional operator <code>?</code>&#32;<code>:</code>
<a name="8720"></a>
<li>Simple names that refer to <code>final</code> variables whose initializers are constant expressions
<a name="239286"></a>
<li>Qualified names of the form <i>TypeName</i> <code>.</code> <i>Identifier</i> that refer to <code>final</code> variables whose initializers are constant expressions
</ul><a name="5315"></a>
Compile-time constant expressions are used in <code>case</code> labels in <code>switch</code> statements 
<a href="14.doc.html#35518">(&#167;14.9)</a> and have a special significance for assignment conversion <a href="5.doc.html#170768">(&#167;5.2)</a>.
<p><a name="236407"></a>
Examples of constant expressions:<p>
<pre><a name="236408"></a>true
<a name="236411"></a>(short)(1*2*3*4*5*6)
<a name="236409"></a>Integer.MAX_VALUE / 2
<a name="239216"></a>2.0 * Math.PI
<a name="236410"></a>"The integer " + Long.MAX_VALUE + " is mighty big."
</pre>

<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="14.doc.html">Prev</a> | <a href="16.doc.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>